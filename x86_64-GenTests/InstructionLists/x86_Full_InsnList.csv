Instruction;Arg1;Arg2;Arg3;Arg4;Op1;Op2;Op3;Op4;Legacy;REX/VEX;Opcode;ModR/M;Disp;Imm;64-bits Mode;Legacy Mode;Special;Grammar;AT&T;Family;Annotate;Description;Notes;
-;;;;;;;;;;;D4;;;ib;Invalid;Valid;8086;;-;UNDEF;NA;Adjust AX after multiply to number base imm8.;;
-;;;;;;;;;;;D5;;;ib;Invalid;Valid;8086;;-;UNDEF;NA;Adjust AX before division to number base imm8.;;
AAA;;;;;;;;;;;37;;;;Invalid;Valid;8086;;AAA;ASCII;NA;ASCII adjust AL after addition.;;
AAD;;;;;;;;;;;D5 0A;;;;Invalid;Valid;8086;;AAD;ASCII;NA;ASCII adjust AX before division.;;
AAM;;;;;;;;;;;D4 0A;;;;Invalid;Valid;8086;;AAM;ASCII;NA;ASCII adjust AX after multiply.;;
AAS;;;;;;;;;;;3F;;;;Invalid;Valid;8086;;AAS;ASCII;NA;ASCII adjust AL after subtraction.;;
ADC;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;10;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with carry byte register to r/m8.;;
ADC;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;10;/r;;;Valid;N.E.;8086;;ADC;ADD;NA;Add with carry byte register to r/m64.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADC;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;11;/r;;;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF r64 to r/m64.;;
ADC;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;11;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with carry r16 to r/m16.;;
ADC;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;11;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with CF r32 to r/m32.;;
ADC;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;12;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with carry r/m8 to byte register.;;
ADC;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;12;/r;;;Valid;N.E.;8086;;ADC;ADD;NA;Add with carry r/m64 to byte register.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADC;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;13;/r;;;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF r/m64 to r64.;;
ADC;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;13;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with carry r/m16 to r16.;;
ADC;r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;13;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with CF r/m32 to r32.;;
ADC;m32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;13;/r;;;Valid;Valid;8086;;ADC;ADD;NA;Add with CF r/m32 to r32.;;
ADC;imm8;r8=AL;;;imm8;;;;;;14;;;ib;Invalid;Valid;8086;;ADC;ADD;NA;Add with carry imm8 to AL.;;
ADC;imm16;r16=AX;;;imm16;;;;;REX.W0;15;;;iw;Invalid;Valid;8086;Legacy66;ADC;ADD;NA;Add with carry imm16 to AX.;;
ADC;imm32;r32=EAX;;;imm32;;;;;REX.W0;15;;;id;Invalid;Valid;8086;;ADC;ADD;NA;Add with carry imm32 to EAX.;;
ADC;imm32;r64=RAX;;;imm32;;;;;REX.W;15;;;id;Invalid;N.E.;8086;;ADC;ADD;NA;Add with carry imm32 sign extended to 64-bits to RAX.;;
ADC;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/2;;ib;Valid;N.E.;8086;;ADC;ADD;NA;Add with carry imm8 to r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADC;imm8;r8;;;imm8;ModRM:r/m (r, w);;;;;80;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with carry imm8 to r/m8.;;
ADC;imm8;m8;;;imm8;ModRM:r/m (r, w);;;;;80;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with carry imm8 to r/m8.;;
ADC;imm16;m16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/2;;iw;Valid;Valid;8086;;ADC;ADD;NA;Add with carry imm16 to r/m16.;;
ADC;imm16;r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/2;;iw;Valid;Valid;8086;;ADC;ADD;NA;Add with carry imm16 to r/m16.;;
ADC;imm32;m64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/2;;id;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF imm32 sign extended to 64-bits to r/m64.;;
ADC;imm32;r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/2;;id;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF imm32 sign extended to 64-bits to r/m64.;;
ADC;imm32;m32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/2;;id;Valid;Valid;8086;;ADC;ADD;NA;Add with CF imm32 to r/m32.;;
ADC;imm32;r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/2;;id;Valid;Valid;8086;;ADC;ADD;NA;Add with CF imm32 to r/m32.;;
ADC;imm8;r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/2;;ib;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 into r/m64.;;
ADC;imm8;m64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/2;;ib;Valid;N.E.;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 into r/m64.;;
ADC;imm8;m16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 to r/m16.;;
ADC;imm8;r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 to r/m16.;;
ADC;imm8;m32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 into r/m32.;;
ADC;imm8;r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/2;;ib;Valid;Valid;8086;;ADC;ADD;NA;Add with CF sign-extended imm8 into r/m32.;;
ADD;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;00;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r8 to r/m8.;;
ADD;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;00;/r;;;Valid;N.E.;8086;;ADD;ADD;NA;Add r8 to r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADD;r32;m32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;01;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r32 to r/m32.;;
ADD;r32;r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;01;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r32 to r/m32.;;
ADD;r64;r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;01;/r;;;Valid;N.E.;8086;;ADD;ADD;NA;Add r64 to r/m64.;;
ADD;r64;m64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;01;/r;;;Valid;N.E.;8086;;ADD;ADD;NA;Add r64 to r/m64.;;
ADD;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;01;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r16 to r/m16.;;
ADD;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;02;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r/m8 to r8.;;
ADD;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;02;/r;;;Valid;N.E.;8086;;ADD;ADD;NA;Add r/m8 to r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADD;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;03;/r;;;Invalid;N.E.;8086;;ADD;ADD;NA;Add r/m64 to r64.;;
ADD;m64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;03;/r;;;Valid;N.E.;8086;;ADD;ADD;NA;Add r/m64 to r64.;;
ADD;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;03;/r;;;Invalid;Valid;8086;;ADD;ADD;NA;Add r/m32 to r32.;;
ADD;m32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;03;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r/m32 to r32.;;
ADD;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;03;/r;;;Valid;Valid;8086;;ADD;ADD;NA;Add r/m16 to r16.;;
ADD;imm8;r8=AL;;;imm8;;;;;;04;;;ib;Invalid;Valid;8086;;ADD;ADD;NA;Add imm8 to AL.;;
ADD;imm16;r16=AX;;;imm16;;;;;REX.W0;05;;;iw;Invalid;Valid;8086;Legacy66;ADD;ADD;NA;Add imm16 to AX.;;
ADD;imm32;r32=EAX;;;imm32;;;;;REX.W0;05;;;id;Invalid;Valid;8086;;ADD;ADD;NA;Add imm32 to EAX.;;
ADD;imm32;r64=RAX;;;imm32;;;;;REX.W;05;;;id;Invalid;N.E.;8086;;ADD;ADD;NA;Add imm32 sign-extended to 64-bits to RAX.;;
ADD;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/0;;ib;Valid;N.E.;8086;;ADD;ADD;NA;Add sign-extended imm8 to r/m64.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ADD;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/0;;ib;Valid;Valid;8086;;ADD;ADD;NA;Add imm8 to r/m8.;;
ADD;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/0;;iw;Valid;Valid;8086;;ADD;ADD;NA;Add imm16 to r/m16.;;
ADD;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/0;;id;Valid;N.E.;8086;;ADD;ADD;NA;Add imm32 sign-extended to 64-bits to r/m64.;;
ADD;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/0;;id;Valid;Valid;8086;;ADD;ADD;NA;Add imm32 to r/m32.;;
ADD;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/0;;ib;Valid;N.E.;8086;;ADD;ADD;NA;Add sign-extended imm8 to r/m64.;;
ADD;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/0;;ib;Valid;Valid;8086;;ADD;ADD;NA;Add sign-extended imm8 to r/m32.;;
ADD;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/0;;ib;Valid;Valid;8086;;ADD;ADD;NA;Add sign-extended imm8 to r/m16.;;
ADDPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 58;/r;;;Valid;Valid;SSE2;;ADDPD;ADD;NA;Add packed double-precision floating-point values from xmm2/m128 to xmm1.;;
ADDPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 58;/r;;;Valid;Valid;SSE;;ADDPS;ADD;NA;Add packed single-precision floating-point values from xmm2/m128 to xmm1.;;
ADDSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 58;/r;;;Valid;Valid;SSE2;;ADDSD;ADD;NA;Add the low double-precision floating-point value from xmm2/m64 to xmm1.;;
ADDSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 58;/r;;;Valid;Valid;SSE;;ADDSS;ADD;NA;Add the low single-precision floating-point value from xmm2/m32 to xmm1.;;
ADDSUBPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D0;/r;;;Valid;Valid;SSE3;;ADDSUBPD;ADD;NA;Add/subtract double-precision floating-point values from xmm2/m128 to xmm1.;;
ADDSUBPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F D0;/r;;;Valid;Valid;SSE3;;ADDSUBPS;ADD;NA;Add/subtract single-precision floating-point values from xmm2/m128 to xmm1.;;
AESDEC;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 DE;/r;;;Valid;Valid;AES;;AESDEC;UNDEF;NA;Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.;;
AESDECLAST;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 DF;/r;;;Valid;Valid;AES;;AESDECLAST;UNDEF;NA;Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.;;
AESENC;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 DC;/r;;;Valid;Valid;AES;;AESENC;UNDEF;NA;Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.;;
AESENCLAST;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 DD;/r;;;Valid;Valid;AES;;AESENCLAST;UNDEF;NA;Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128.;;
AESIMC;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 DB;/r;;;Valid;Valid;AES;;AESIMC;UNDEF;NA;Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.;;
AESKEYGENASSIST;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A DF;/r;;ib;Valid;Valid;AES;;AESKEYGENASSIST;UNDEF;NA;Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.;;
AND;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;20;/r;;;Valid;Valid;8086;;AND;AND;NA;r/m8 AND r8.;;
AND;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;20;/r;;;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND r8 (sign-extended).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
AND;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;21;/r;;;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND r32.;;
AND;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;21;/r;;;Valid;Valid;8086;;AND;AND;NA;r/m16 AND r16.;;
AND;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;21;/r;;;Valid;Valid;8086;;AND;AND;NA;r/m32 AND r32.;;
AND;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;22;/r;;;Valid;Valid;8086;;AND;AND;NA;r8 AND r/m8.;;
AND;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;22;/r;;;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND r8 (sign-extended).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
AND;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;23;/r;;;Valid;Valid;8086;;AND;AND;NA;r16 AND r/m16.;;
AND;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;23;/r;;;Valid;N.E.;8086;;AND;AND;NA;r64 AND r/m64.;;
AND;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;23;/r;;;Valid;Valid;8086;;AND;AND;NA;r32 AND r/m32.;;
AND;imm8;r8=AL;;;imm8;;;;;;24;;;ib;Valid;Valid;8086;;AND;AND;NA;AL AND imm8.;;
AND;imm16;r16=AX;;;imm16;;;;;REX.W0;25;;;iw;Valid;Valid;8086;Legacy66;AND;AND;NA;AX AND imm16.;;
AND;imm32;r64=RAX;;;imm32;;;;;REX.W;25;;;id;Valid;N.E.;8086;;AND;AND;NA;RAX AND imm32 sign-extended to 64-bits.;;
AND;imm32;r32=EAX;;;imm32;;;;;REX.W0;25;;;id;Valid;Valid;8086;;AND;AND;NA;EAX AND imm32.;;
AND;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/4;;ib;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND imm8 (sign-extended).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
AND;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/4;;ib;Valid;Valid;8086;;AND;AND;NA;r/m8 AND imm8.;;
AND;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/4;;iw;Valid;Valid;8086;;AND;AND;NA;r/m16 AND imm16.;;
AND;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/4;;id;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND imm32 sign extended to 64-bits.;;
AND;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/4;;id;Valid;Valid;8086;;AND;AND;NA;r/m32 AND imm32.;;
AND;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/4;;ib;Valid;N.E.;8086;;AND;AND;NA;r/m64 AND imm8 (sign-extended).;;
AND;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/4;;ib;Valid;Valid;8086;;AND;AND;NA;r/m32 AND imm8 (sign-extended).;;
AND;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/4;;ib;Valid;Valid;8086;;AND;AND;NA;r/m16 AND imm8 (sign-extended).;;
ANDNPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 55;/r;;;Valid;Valid;SSE2;;ANDNPD;AND;NA;Bitwise logical AND NOT of xmm2/m128 and xmm1.;;
ANDNPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 55;/r;;;Valid;Valid;SSE;;ANDNPS;AND;NA;Bitwise logical AND NOT of xmm2/m128 and xmm1.;;
ANDPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 54;/r;;;Valid;Valid;SSE2;;ANDPD;XOR;NA;Bitwise logical AND of xmm2/m128 and xmm1.;;
ANDPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 54;/r;;;Valid;Valid;SSE;;ANDPS;XOR;NA;Bitwise logical AND of xmm2/m128 and xmm1.;;
ARPL;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;;;63;/r;;;N.E.;Valid;8086;;ARPL;ARPL;NA;Adjust RPL of r/m16 to not less than RPL of r16.;;
BLENDPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 0D;/r;;ib;Valid;Valid;SSE4_1;;BLENDPD;UNDEF;NA;Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.;;
BLENDPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 0C;/r;;ib;Valid;Valid;SSE4_1;;BLENDPS;UNDEF;NA;Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.;;
BLENDVPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 15;/r;;;Valid;Valid;SSE4_1;;BLENDVPD;UNDEF;NA;Select packed DP FP values from xmm1 and xmm2 from;;
BLENDVPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 14;/r;;;Valid;Valid;SSE4_1;;BLENDVPS;UNDEF;NA;Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.;;
BOUND;m32&32;r32;;;ModRM:r/m (r);ModRM:reg (r);;;;;62;/r;;;Invalid;Valid;8086;;BOUND;BOUND;NA;Check if r32 (array index) is within bounds specified by m16&16.;;
BOUND;m16&16;r16;;;ModRM:r/m (r);ModRM:reg (r);;;;;62;/r;;;Invalid;Valid;8086;;BOUND;BOUND;NA;Check if r16 (array index) is within bounds specified by m16&16.;;
BSF;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BC;/r;;;Valid;Valid;8086;;BSF;BS;NA;Bit scan forward on r/m16.;;
BSF;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BC;/r;;;Valid;Valid;8086;;BSF;BS;NA;Bit scan forward on r/m32.;;
BSF;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F BC;/r;;;Valid;N.E.;8086;;BSF;BS;NA;Bit scan forward on r/m64.;;
BSR;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BD;/r;;;Valid;Valid;8086;;BSR;BS;NA;Bit scan reverse on r/m32.;;
BSR;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BD;/r;;;Valid;Valid;8086;;BSR;BS;NA;Bit scan reverse on r/m16.;;
BSR;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F BD;/r;;;Valid;N.E.;8086;;BSR;BS;NA;Bit scan reverse on r/m64.;;
BSWAP;r64;;;;ModRM:reg (r, w);;;;;REX.W;0F C8+rd;;;;Valid;N.E.;8086;;BSWAP;BSWAP;NA;Reverses the byte order of a 64-bit register.;;
BSWAP;r32;;;;ModRM:reg (r, w);;;;;REX.W0;0F C8+rd;;;;Valid;Valid;8086;;BSWAP;BSWAP;NA;Reverses the byte order of a 32-bit register.;* See IA-32 Architecture Compatibility section below.;
BT;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W0;0F A3;/r;;;Valid;Valid;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BT;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W0;0F A3;/r;;;Valid;Valid;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BT;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W;0F A3;/r;;;Valid;N.E.;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BT;imm8;m16/r16;;;imm8;ModRM:r/m (r);;;;REX.W0;0F BA;/4;;ib;Valid;Valid;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BT;imm8;m32/r32;;;imm8;ModRM:r/m (r);;;;REX.W0;0F BA;/4;;ib;Valid;Valid;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BT;imm8;m64/r64;;;imm8;ModRM:r/m (r);;;;REX.W;0F BA;/4;;ib;Valid;N.E.;8086;;BT;BT;NA;Store selected bit in CF flag.;;
BTC;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/7;;ib;Valid;Valid;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTC;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;0F BA;/7;;ib;Valid;N.E.;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTC;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/7;;ib;Valid;Valid;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTC;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F BB;/r;;;Valid;Valid;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTC;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F BB;/r;;;Valid;Valid;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTC;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;0F BB;/r;;;Valid;N.E.;8086;;BTC;BT;NA;Store selected bit in CF flag and complement.;;
BTR;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F B3;/r;;;Valid;Valid;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTR;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;0F B3;/r;;;Valid;N.E.;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTR;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F B3;/r;;;Valid;Valid;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTR;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;0F BA;/6;;ib;Valid;N.E.;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTR;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/6;;ib;Valid;Valid;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTR;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/6;;ib;Valid;Valid;8086;;BTR;BT;NA;Store selected bit in CF flag and clear.;;
BTS;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F AB;/r;;;Valid;Valid;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
BTS;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F AB;/r;;;Valid;Valid;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
BTS;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;0F AB;/r;;;Valid;N.E.;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
BTS;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/5;;ib;Valid;Valid;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
BTS;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;0F BA;/5;;ib;Valid;Valid;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
BTS;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;0F BA;/5;;ib;Valid;N.E.;8086;;BTS;BT;NA;Store selected bit in CF flag and set.;;
CALL;ptr16:32;;;;Offset;;;;;;9A;;cp;;Invalid;Valid;8086;;CALL;CALL;CALL;Call far, absolute, address given in operand.;;
CALL;ptr16:16;;;;Offset;;;;;;9A;;cd;;Invalid;Valid;8086;;CALL;CALL;CALL;Call far, absolute, address given in operand.;;
CALL;rel16;;;;Offset;;;;;;E8;;cw;;N.S.;Valid;8086;;CALL;CALL;CALL;Call near, relative, displacement relative to next instruction.;;
CALL;rel32;;;;Offset;;;;;;E8;;cd;;Valid;Valid;8086;;CALL;CALL;CALL;Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode.;;
CALL;m16:32;;;;ModRM:r/m (r);;;;;REX.W0;FF;/3;;;Valid;Valid;8086;;CALL;CALL;CALL;In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate else RIP = zero extended 32-bit offset from far pointer referenced in the instruction.;;
CALL;m16:64;;;;ModRM:r/m (r);;;;;REX.W;FF;/3;;;Valid;N.E.;8086;;CALL;CALL;CALL;In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate else RIP = 64-bit offset from far pointer referenced in the instruction.;;
CALL;m16:16;;;;ModRM:r/m (r);;;;;REX.W0;FF;/3;;;Valid;Valid;8086;;CALL;CALL;CALL;Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate else RIP = zero extended 16-bit offset from far pointer referenced in the instruction.;;
CALL;m32/r32;;;;ModRM:r/m (r);;;;;;FF;/2;;;N.E.;Valid;8086;;CALL;CALL;CALL;Call near, absolute indirect, address given in r/m32.;;
CALL;m64/r64;;;;ModRM:r/m (r);;;;;REX.W0;FF;/2;;;Valid;N.E.;8086;;CALL;CALL;CALL;Call near, absolute indirect, address given in r/m64.;;
CALL;m16/r16;;;;ModRM:r/m (r);;;;;;FF;/2;;;N.E.;Valid;8086;;CALL;CALL;CALL;Call near, absolute indirect, address given in r/m16.;;
CBW;;;;;;;;;;;98;;;;Valid;Valid;8086;Legacy66;CBW;CONVERT;NA;AX ← sign-extend of AL.;;
CDQ;;;;;;;;;;;99;;;;Valid;Valid;8086;;CLTD;CONVERT;NA;EDX:EAX ← sign-extend of EAX.;;
CDQE;;;;;;;;;;REX.W;98;;;;Valid;N.E.;8086;;CLTQ;CONVERT;NA;RAX ← sign-extend of EAX.;;
CLC;;;;;;;;;;;F8;;;;Valid;Valid;8086;;CLC;CLEAR;NA;Clear CF flag.;;
CLD;;;;;;;;;;;FC;;;;Valid;Valid;8086;;CLD;CLEAR;NA;Clear DF flag.;;
CLFLUSH;m8;;;;ModRM:r/m (w);;;;;;0F AE;/7;;;Valid;Valid;8086;;CLFLUSH;CLFLUSH;NA;Flushes cache line containing m8.;;
CLI;;;;;;;;;;;FA;;;;Valid;Valid;8086;;CLI;CLEAR;NA;Clear interrupt flag interrupts disabled when interrupt flag cleared.;;
CLTS;;;;;;;;;;;0F 06;;;;Valid;Valid;8086;;CLTS;CLEAR;NA;Clears TS flag in CR0.;;
CMC;;;;;;;;;;;F5;;;;Valid;Valid;8086;;CMC;CMC;NA;Complement CF flag.;;
CMOVA;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 47;/r;;;Valid;N.E.;8086;;CMOVA;CMOV;NA;Move if above (CF=0 and ZF=0).;;
CMOVA;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 47;/r;;;Valid;Valid;8086;;CMOVA;CMOV;NA;Move if above (CF=0 and ZF=0).;;
CMOVA;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 47;/r;;;Valid;Valid;8086;;CMOVA;CMOV;NA;Move if above (CF=0 and ZF=0).;;
CMOVAE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVAE;CMOV;NA;Move if above or equal (CF=0).;;
CMOVAE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 43;/r;;;Valid;N.E.;8086;;CMOVAE;CMOV;NA;Move if above or equal (CF=0).;;
CMOVAE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVAE;CMOV;NA;Move if above or equal (CF=0).;;
CMOVB;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVB;CMOV;NA;Move if below (CF=1).;;
CMOVB;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 42;/r;;;Valid;N.E.;8086;;CMOVB;CMOV;NA;Move if below (CF=1).;;
CMOVB;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVB;CMOV;NA;Move if below (CF=1).;;
CMOVBE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 46;/r;;;Valid;Valid;8086;;CMOVBE;CMOV;NA;Move if below or equal (CF=1 or ZF=1).;;
CMOVBE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 46;/r;;;Valid;N.E.;8086;;CMOVBE;CMOV;NA;Move if below or equal (CF=1 or ZF=1).;;
CMOVBE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 46;/r;;;Valid;Valid;8086;;CMOVBE;CMOV;NA;Move if below or equal (CF=1 or ZF=1).;;
CMOVC;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 42;/r;;;Valid;N.E.;8086;;CMOVC;CMOV;NA;Move if carry (CF=1).;;
CMOVC;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVC;CMOV;NA;Move if carry (CF=1).;;
CMOVC;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVC;CMOV;NA;Move if carry (CF=1).;;
CMOVE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 44;/r;;;Valid;N.E.;8086;;CMOVE;CMOV;NA;Move if equal (ZF=1).;;
CMOVE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 44;/r;;;Valid;Valid;8086;;CMOVE;CMOV;NA;Move if equal (ZF=1).;;
CMOVE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 44;/r;;;Valid;Valid;8086;;CMOVE;CMOV;NA;Move if equal (ZF=1).;;
CMOVG;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4F;/r;;;Valid;N.E.;8086;;CMOVG;CMOV;NA;Move if greater (ZF=0 and SF=OF).;;
CMOVG;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4F;/r;;;Valid;Valid;8086;;CMOVG;CMOV;NA;Move if greater (ZF=0 and SF=OF).;;
CMOVG;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4F;/r;;;Valid;Valid;8086;;CMOVG;CMOV;NA;Move if greater (ZF=0 and SF=OF).;;
CMOVGE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4D;/r;;;Valid;N.E.;8086;;CMOVGE;CMOV;NA;Move if greater or equal (SF=OF).;;
CMOVGE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4D;/r;;;Valid;Valid;8086;;CMOVGE;CMOV;NA;Move if greater or equal (SF=OF).;;
CMOVGE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4D;/r;;;Valid;Valid;8086;;CMOVGE;CMOV;NA;Move if greater or equal (SF=OF).;;
CMOVL;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4C;/r;;;Valid;N.E.;8086;;CMOVL;CMOV;NA;Move if less (SF≠ OF).;;
CMOVL;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4C;/r;;;Valid;Valid;8086;;CMOVL;CMOV;NA;Move if less (SF≠ OF).;;
CMOVL;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4C;/r;;;Valid;Valid;8086;;CMOVL;CMOV;NA;Move if less (SF≠ OF).;;
CMOVLE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4E;/r;;;Valid;N.E.;8086;;CMOVLE;CMOV;NA;Move if less or equal (ZF=1 or SF≠ OF).;;
CMOVLE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4E;/r;;;Valid;Valid;8086;;CMOVLE;CMOV;NA;Move if less or equal (ZF=1 or SF≠ OF).;;
CMOVLE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4E;/r;;;Valid;Valid;8086;;CMOVLE;CMOV;NA;Move if less or equal (ZF=1 or SF≠ OF).;;
CMOVNA;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 46;/r;;;Valid;Valid;8086;;CMOVNA;CMOV;NA;Move if not above (CF=1 or ZF=1).;;
CMOVNA;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 46;/r;;;Valid;Valid;8086;;CMOVNA;CMOV;NA;Move if not above (CF=1 or ZF=1).;;
CMOVNA;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 46;/r;;;Valid;N.E.;8086;;CMOVNA;CMOV;NA;Move if not above (CF=1 or ZF=1).;;
CMOVNAE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVNAE;CMOV;NA;Move if not above or equal (CF=1).;;
CMOVNAE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 42;/r;;;Valid;N.E.;8086;;CMOVNAE;CMOV;NA;Move if not above or equal (CF=1).;;
CMOVNAE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 42;/r;;;Valid;Valid;8086;;CMOVNAE;CMOV;NA;Move if not above or equal (CF=1).;;
CMOVNB;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVNB;CMOV;NA;Move if not below (CF=0).;;
CMOVNB;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 43;/r;;;Valid;N.E.;8086;;CMOVNB;CMOV;NA;Move if not below (CF=0).;;
CMOVNB;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVNB;CMOV;NA;Move if not below (CF=0).;;
CMOVNBE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 47;/r;;;Valid;N.E.;8086;;CMOVNBE;CMOV;NA;Move if not below or equal (CF=0 and ZF=0).;;
CMOVNBE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 47;/r;;;Valid;Valid;8086;;CMOVNBE;CMOV;NA;Move if not below or equal (CF=0 and ZF=0).;;
CMOVNBE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 47;/r;;;Valid;Valid;8086;;CMOVNBE;CMOV;NA;Move if not below or equal (CF=0 and ZF=0).;;
CMOVNC;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 43;/r;;;Valid;N.E.;8086;;CMOVNC;CMOV;NA;Move if not carry (CF=0).;;
CMOVNC;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVNC;CMOV;NA;Move if not carry (CF=0).;;
CMOVNC;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 43;/r;;;Valid;Valid;8086;;CMOVNC;CMOV;NA;Move if not carry (CF=0).;;
CMOVNE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 45;/r;;;Valid;Valid;8086;;CMOVNE;CMOV;NA;Move if not equal (ZF=0).;;
CMOVNE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 45;/r;;;Valid;N.E.;8086;;CMOVNE;CMOV;NA;Move if not equal (ZF=0).;;
CMOVNE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 45;/r;;;Valid;Valid;8086;;CMOVNE;CMOV;NA;Move if not equal (ZF=0).;;
CMOVNG;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4E;/r;;;Valid;N.E.;8086;;CMOVNG;CMOV;NA;Move if not greater (ZF=1 or SF≠ OF).;;
CMOVNG;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4E;/r;;;Valid;Valid;8086;;CMOVNG;CMOV;NA;Move if not greater (ZF=1 or SF≠ OF).;;
CMOVNG;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4E;/r;;;Valid;Valid;8086;;CMOVNG;CMOV;NA;Move if not greater (ZF=1 or SF≠ OF).;;
CMOVNGE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4C;/r;;;Valid;Valid;8086;;CMOVNGE;CMOV;NA;Move if not greater or equal (SF≠ OF).;;
CMOVNGE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4C;/r;;;Valid;Valid;8086;;CMOVNGE;CMOV;NA;Move if not greater or equal (SF≠ OF).;;
CMOVNGE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4C;/r;;;Valid;N.E.;8086;;CMOVNGE;CMOV;NA;Move if not greater or equal (SF≠ OF).;;
CMOVNL;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4D;/r;;;Valid;N.E.;8086;;CMOVNL;CMOV;NA;Move if not less (SF=OF).;;
CMOVNL;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4D;/r;;;Valid;Valid;8086;;CMOVNL;CMOV;NA;Move if not less (SF=OF).;;
CMOVNL;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4D;/r;;;Valid;Valid;8086;;CMOVNL;CMOV;NA;Move if not less (SF=OF).;;
CMOVNLE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4F;/r;;;Valid;Valid;8086;;CMOVNLE;CMOV;NA;Move if not less or equal (ZF=0 and SF=OF).;;
CMOVNLE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4F;/r;;;Valid;Valid;8086;;CMOVNLE;CMOV;NA;Move if not less or equal (ZF=0 and SF=OF).;;
CMOVNLE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4F;/r;;;Valid;N.E.;8086;;CMOVNLE;CMOV;NA;Move if not less or equal (ZF=0 and SF=OF).;;
CMOVNO;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 41;/r;;;Valid;Valid;8086;;CMOVNO;CMOV;NA;Move if not overflow (OF=0).;;
CMOVNO;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 41;/r;;;Valid;N.E.;8086;;CMOVNO;CMOV;NA;Move if not overflow (OF=0).;;
CMOVNO;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 41;/r;;;Valid;Valid;8086;;CMOVNO;CMOV;NA;Move if not overflow (OF=0).;;
CMOVNP;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4B;/r;;;Valid;N.E.;8086;;CMOVNP;CMOV;NA;Move if not parity (PF=0).;;
CMOVNP;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4B;/r;;;Valid;Valid;8086;;CMOVNP;CMOV;NA;Move if not parity (PF=0).;;
CMOVNP;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4B;/r;;;Valid;Valid;8086;;CMOVNP;CMOV;NA;Move if not parity (PF=0).;;
CMOVNS;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 49;/r;;;Valid;Valid;8086;;CMOVNS;CMOV;NA;Move if not sign (SF=0).;;
CMOVNS;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 49;/r;;;Valid;Valid;8086;;CMOVNS;CMOV;NA;Move if not sign (SF=0).;;
CMOVNS;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 49;/r;;;Valid;N.E.;8086;;CMOVNS;CMOV;NA;Move if not sign (SF=0).;;
CMOVNZ;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 45;/r;;;Valid;Valid;8086;;CMOVNZ;CMOV;NA;Move if not zero (ZF=0).;;
CMOVNZ;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 45;/r;;;Valid;N.E.;8086;;CMOVNZ;CMOV;NA;Move if not zero (ZF=0).;;
CMOVNZ;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 45;/r;;;Valid;Valid;8086;;CMOVNZ;CMOV;NA;Move if not zero (ZF=0).;;
CMOVO;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 40;/r;;;Valid;Valid;8086;;CMOVO;CMOV;NA;Move if overflow (OF=0).;;
CMOVO;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 40;/r;;;Valid;Valid;8086;;CMOVO;CMOV;NA;Move if overflow (OF=0).;;
CMOVO;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 40;/r;;;Valid;N.E.;8086;;CMOVO;CMOV;NA;Move if overflow (OF=0).;;
CMOVP;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4A;/r;;;Valid;N.E.;8086;;CMOVP;CMOV;NA;Move if parity (PF=1).;;
CMOVP;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4A;/r;;;Valid;Valid;8086;;CMOVP;CMOV;NA;Move if parity (PF=1).;;
CMOVP;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4A;/r;;;Valid;Valid;8086;;CMOVP;CMOV;NA;Move if parity (PF=1).;;
CMOVPE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4A;/r;;;Valid;Valid;8086;;CMOVPE;CMOV;NA;Move if parity even (PF=1).;;
CMOVPE;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4A;/r;;;Valid;Valid;8086;;CMOVPE;CMOV;NA;Move if parity even (PF=1).;;
CMOVPE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4A;/r;;;Valid;N.E.;8086;;CMOVPE;CMOV;NA;Move if parity even (PF=1).;;
CMOVPO;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 4B;/r;;;Valid;N.E.;8086;;CMOVPO;CMOV;NA;Move if parity odd (PF=0).;;
CMOVPO;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4B;/r;;;Valid;Valid;8086;;CMOVPO;CMOV;NA;Move if parity odd (PF=0).;;
CMOVPO;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 4B;/r;;;Valid;Valid;8086;;CMOVPO;CMOV;NA;Move if parity odd (PF=0).;;
CMOVS;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 48;/r;;;Valid;N.E.;8086;;CMOVS;CMOV;NA;Move if sign (SF=1).;;
CMOVS;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 48;/r;;;Valid;Valid;8086;;CMOVS;CMOV;NA;Move if sign (SF=1).;;
CMOVS;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 48;/r;;;Valid;Valid;8086;;CMOVS;CMOV;NA;Move if sign (SF=1).;;
CMOVZ;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 44;/r;;;Valid;Valid;8086;;CMOVZ;CMOV;NA;Move if zero (ZF=1).;;
CMOVZ;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 44;/r;;;Valid;Valid;8086;;CMOVZ;CMOV;NA;Move if zero (ZF=1).;;
CMOVZ;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F 44;/r;;;Valid;N.E.;8086;;CMOVZ;CMOV;NA;Move if zero (ZF=1).;;
CMP;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;38;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r8 with r/m8.;;
CMP;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;38;/r;;;Valid;N.E.;8086;;CMP;CMP;NA;Compare r8 with r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
CMP;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;39;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r16 with r/m16.;;
CMP;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;39;/r;;;Valid;N.E.;8086;;CMP;CMP;NA;Compare r64 with r/m64.;;
CMP;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;39;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r32 with r/m32.;;
CMP;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;3A;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r/m8 with r8.;;
CMP;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;3A;/r;;;Valid;N.E.;8086;;CMP;CMP;NA;Compare r/m8 with r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
CMP;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;3B;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r/m16 with r16.;;
CMP;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;3B;/r;;;Valid;Valid;8086;;CMP;CMP;NA;Compare r/m32 with r32.;;
CMP;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;3B;/r;;;Valid;N.E.;8086;;CMP;CMP;NA;Compare r/m64 with r64.;;
CMP;imm8;r8=AL;;;imm8;;;;;;3C;;;ib;Valid;Valid;8086;;CMP;CMP;NA;Compare imm8 with AL.;;
CMP;imm16;r16=AX;;;imm16;;;;;REX.W0;3D;;;iw;Valid;Valid;8086;Legacy66;CMP;CMP;NA;Compare imm16 with AX.;;
CMP;imm32;r64=RAX;;;imm32;;;;;REX.W;3D;;;id;Valid;N.E.;8086;;CMP;CMP;NA;Compare imm32 sign-extended to 64-bits with RAX.;;
CMP;imm32;r32=EAX;;;imm32;;;;;REX.W0;3D;;;id;Valid;Valid;8086;;CMP;CMP;NA;Compare imm32 with EAX.;;
CMP;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/7;;ib;Valid;Valid;8086;;CMP;CMP;NA;Compare imm8 with r/m8.;;
CMP;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/7;;ib;Valid;N.E.;8086;;CMP;CMP;NA;Compare imm8 with r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
CMP;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/7;;iw;Valid;Valid;8086;;CMP;CMP;NA;Compare imm16 with r/m16.;;
CMP;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/7;;id;Valid;Valid;8086;;CMP;CMP;NA;Compare imm32 with r/m32.;;
CMP;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/7;;id;Valid;N.E.;8086;;CMP;CMP;NA;Compare imm32 sign-extended to 64-bits with r/m64.;;
CMP;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/7;;ib;Valid;Valid;8086;;CMP;CMP;NA;Compare imm8 with r/m16.;;
CMP;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/7;;ib;Valid;Valid;8086;;CMP;CMP;NA;Compare imm8 with r/m32.;;
CMP;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/7;;ib;Valid;N.E.;8086;;CMP;CMP;NA;Compare imm8 with r/m64.;;
CMPPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;REX.W0;0F C2;/r;;ib;Valid;Valid;SSE2;;CMPPD;CMP;NA;Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using imm8 as comparison predicate.;;
CMPPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;0F C2;/r;;ib;Valid;Valid;SSE;;CMPPS;CMP;NA;Compare packed single-precision floating-point values in xmm2/mem and xmm1 using imm8 as comparison predicate.;;
CMPS;m8=ES:(E)DI;m8=DS:(E)SI;;;;;;;;REX.W0;A6;;;;Valid;Valid;8086;;CMPS;CMP;NA;For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly.;;
CMPS;m16=ES:(E)DI;m16=DS:(E)SI;;;;;;;;REX.W0;A7;;;;Valid;Valid;8086;;CMPS;CMP;NA;For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.;;
CMPS;m32=ES:(E)DI;m32=DS:(E)SI;;;;;;;;REX.W0;A7;;;;Valid;Valid;8086;;CMPS;CMP;NA;For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly.;;
CMPS;m64=(R)DI/(E)DI;m64=(R)SI/(E)SI;;;;;;;;REX.W;A7;;;;Valid;N.E.;8086;;CMPS;CMP;NA;Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.;;
CMPSB;;;;;;;;;;;A6;;;;Valid;Valid;8086;;CMPSB;CMP;NA;For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly.;;
CMPSD;imm8;xmm/m64;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;F2;REX.W0;0F C2;/r;;ib;Valid;Valid;SSE2;;CMPSD;CMP;NA;Compare low double-precision floating-point value in xmm2/m64 and xmm1 using imm8 as comparison predicate.;;
CMPSD;;;;;;;;;;;A7;;;;Valid;Valid;8086;Legacy66;CMPSD;CMP;NA;For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly.;;
CMPSQ;;;;;;;;;;REX.W;A7;;;;Valid;N.E.;8086;;CMPSQ;CMP;NA;Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly.;;
CMPSS;imm8;xmm/m32;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;F3;REX.W0;0F C2;/r;;ib;Valid;Valid;SSE;;CMPSS;CMP;NA;Compare low single-precision floating-point value in xmm2/m32 and xmm1 using imm8 as comparison predicate.;;
CMPSW;;;;;;;;;;;A7;;;;Valid;Valid;8086;;CMPSL;CMP;NA;For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly.;;
CMPXCHG;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;0F B0;/r;;;Valid;Valid;8086;;CMPXCHG;CMPXCHG;NA;Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.;* See the IA-32 Architecture Compatibility section below.;
CMPXCHG;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;0F B0;/r;;;Valid;N.E.;8086;;CMPXCHG;CMPXCHG;NA;Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
CMPXCHG;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;0F B1;/r;;;Valid;N.E.;8086;;CMPXCHG;CMPXCHG;NA;Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX.;;
CMPXCHG;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F B1;/r;;;Valid;Valid;8086;;CMPXCHG;CMPXCHG;NA;Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX.;* See the IA-32 Architecture Compatibility section below.;
CMPXCHG;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F B1;/r;;;Valid;Valid;8086;;CMPXCHG;CMPXCHG;NA;Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX.;* See the IA-32 Architecture Compatibility section below.;
CMPXCHG16B;m128;;;;ModRM:r/m (r, w);;;;;REX.W;0F C7;/1;;;Valid;N.E.;8086;;CMPXCHG16B;CMPXCHG;NA;Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX.;;
CMPXCHG8B;m64;;;;ModRM:r/m (r, w);;;;;REX.W0;0F C7;/1;;;Valid;Valid;8086;;CMPXCHG8B;CMPXCHG;NA;Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX.;;
COMISD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;66;REX.W0;0F 2F;/r;;;Valid;Valid;SSE2;;COMISD;CMP;NA;Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.;;
COMISS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;REX.W0;0F 2F;/r;;;Valid;Valid;SSE;;COMISS;CMP;NA;Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.;;
CPUID;;;;;;;;;;;0F A2;;;;Valid;Valid;8086;;CPUID;CPUID;NA;Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (and, in some cases, ECX).;;
CQO;;;;;;;;;;REX.W;99;;;;Valid;N.E.;8086;;CQTO;CONVERT;NA;RDX:RAX← sign-extend of RAX.;;
CRC32;m8/r8;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;;0F 38 F0;/r;;;Valid;Valid;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m8.;;
CRC32;m8/r8<>[ABCD]H;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX;0F 38 F0;/r;;;Valid;N.E.;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m8.;;
CRC32;m8/r8;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W;0F 38 F0;/r;;;Valid;N.E;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m8.;;
CRC32;m16/r16;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;;0F 38 F1;/r;;;Valid;Valid;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m16.;;
CRC32;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;;0F 38 F1;/r;;;Valid;Valid;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m32.;;
CRC32;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W;0F 38 F1;/r;;;Valid;N.E;8086;;CRC32;UNDEF;NA;Accumulate CRC32 on r/m64.;;
CVTDQ2PD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F E6;/r;;;Valid;Valid;SSE2;;CVTDQ2PD;CONVERT;NA;Convert two packed signed doubleword integers from xmm2/m128 to two packed double-precision floating-point values in xmm1.;;
CVTDQ2PS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 5B;/r;;;Valid;Valid;SSE2;;CVTDQ2PS;CONVERT;NA;Convert four packed signed doubleword integers from xmm2/m128 to four packed single-precision floating-point values in xmm1.;;
CVTPD2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F E6;/r;;;Valid;Valid;SSE2;;CVTPD2DQ;CONVERT;NA;Convert two packed double-precision floating-point values from xmm2/m128 to two packed signed doubleword integers in xmm1.;;
CVTPD2PI;xmm/m128;mm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 2D;/r;;;Valid;Valid;8086;;CVTPD2PI;CONVERT;NA;Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm.;;
CVTPD2PS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 5A;/r;;;Valid;Valid;SSE2;;CVTPD2PS;CONVERT;NA;Convert two packed double-precision floating-point values in xmm2/m128 to two packed single-precision floating-point values in xmm1.;;
CVTPI2PD;mm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 2A;/r;;;Valid;Valid;8086;;CVTPI2PD;CONVERT;NA;Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm.;* Operation is different for different operand sets – see the Description section.;
CVTPI2PS;mm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 2A;/r;;;Valid;Valid;8086;;CVTPI2PS;CONVERT;NA;Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm.;;
CVTPS2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 5B;/r;;;Valid;Valid;SSE2;;CVTPS2DQ;CONVERT;NA;Convert four packed single-precision floating-point values from xmm2/m128 to four packed signed doubleword integers in xmm1.;;
CVTPS2PD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 5A;/r;;;Valid;Valid;SSE2;;CVTPS2PD;CONVERT;NA;Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1.;;
CVTPS2PI;xmm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 2D;/r;;;Valid;Valid;8086;;CVTPS2PI;CONVERT;NA;Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm.;;
CVTSD2SI;xmm/m64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W;0F 2D;/r;;;Valid;N.E.;SSE2;;CVTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm/m64 to one signed quadword integer sign-extended into r64.;;
CVTSD2SI;xmm/m64;r32;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 2D;/r;;;Valid;Valid;SSE2;;CVTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer r32.;;
CVTSD2SS;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 5A;/r;;;Valid;Valid;SSE2;;CVTSD2SS;CONVERT;NA;Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1.;;
CVTSI2SD;m32/r32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 2A;/r;;;Valid;Valid;SSE2;;CVTSI2SD;CONVERT;NA;Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm.;;
CVTSI2SD;m64/r64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W;0F 2A;/r;;;Valid;N.E.;SSE2;;CVTSI2SD;CONVERT;NA;Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm.;;
CVTSI2SS;m32/r32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 2A;/r;;;Valid;Valid;SSE;;CVTSI2SS;CONVERT;NA;Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm.;;
CVTSI2SS;m64/r64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W;0F 2A;/r;;;Valid;N.E.;SSE;;CVTSI2SS;CONVERT;NA;Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm.;;
CVTSS2SD;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 5A;/r;;;Valid;Valid;SSE2;;CVTSS2SD;CONVERT;NA;Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1.;;
CVTSS2SI;xmm/m32;r64;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W;0F 2D;/r;;;Valid;N.E.;SSE;;CVTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64.;;
CVTSS2SI;xmm/m32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 2D;/r;;;Valid;Valid;SSE;;CVTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32.;;
CVTTPD2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F E6;/r;;;Valid;Valid;SSE2;;CVTTPD2DQ;CONVERT;NA;Convert two packed double-precision floating-point values from xmm2/m128 to two packed signed doubleword integers in xmm1 using truncation.;;
CVTTPD2PI;xmm/m128;mm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 2C;/r;;;Valid;Valid;8086;;CVTTPD2PI;CONVERT;NA;Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation.;;
CVTTPS2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 5B;/r;;;Valid;Valid;SSE2;;CVTTPS2DQ;CONVERT;NA;Convert four single-precision floating-point values from xmm2/m128 to four signed doubleword integers in xmm1 using truncation.;;
CVTTPS2PI;xmm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 2C;/r;;;Valid;Valid;8086;;CVTTPS2PI;CONVERT;NA;Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation.;;
CVTTSD2SI;xmm/m64;r32;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 2C;/r;;;Valid;Valid;SSE2;;CVTTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm/m64 to one signed doubleword integer in r32 using truncation.;;
CVTTSD2SI;xmm/m64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W;0F 2C;/r;;;Valid;N.E.;SSE2;;CVTTSD2SI;CONVERT;NA;Convert one double precision floating-point value from xmm/m64 to one signed quadword integer in r64 using truncation.;;
CVTTSS2SI;xmm/m32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 2C;/r;;;Valid;Valid;SSE;;CVTTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm/m32 to one signed doubleword integer in r32 using truncation.;;
CVTTSS2SI;xmm/m32;r64;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W;0F 2C;/r;;;Valid;N.E.;SSE;;CVTTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm/m32 to one signed quadword integer in r64 using truncation.;;
CWD;;;;;;;;;;;99;;;;Valid;Valid;8086;Legacy66;CWD;CONVERT;NA;DX:AX ← sign-extend of AX.;;
CWDE;;;;;;;;;;;98;;;;Valid;Valid;8086;;CWTL;CONVERT;NA;EAX ← sign-extend of AX.;;
DAA;;;;;;;;;;;27;;;;Invalid;Valid;8086;;DAA;DA;NA;Decimal adjust AL after addition.;;
DAS;;;;;;;;;;;2F;;;;Invalid;Valid;8086;;DAS;DA;NA;Decimal adjust AL after subtraction.;;
DEC;r32;;;;ModRM:reg (r, w);;;;;;48+rd;;;;N.E.;Valid;8086;;DEC;DEC;NA;Decrement r32 by 1.;;
DEC;r16;;;;ModRM:reg (r, w);;;;;;48+rw;;;;N.E.;Valid;8086;;DEC;DEC;NA;Decrement r16 by 1.;;
DEC;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;;REX;FE;/1;;;Valid;N.E.;8086;;DEC;DEC;NA;Decrement r/m8 by 1.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
DEC;m8/r8;;;;ModRM:r/m (r, w);;;;;;FE;/1;;;Valid;Valid;8086;;DEC;DEC;NA;Decrement r/m8 by 1.;;
DEC;m64/r64;;;;ModRM:r/m (r, w);;;;;REX.W;FF;/1;;;Valid;N.E.;8086;;DEC;DEC;NA;Decrement r/m64 by 1.;;
DEC;m32/r32;;;;ModRM:r/m (r, w);;;;;REX.W0;FF;/1;;;Valid;Valid;8086;;DEC;DEC;NA;Decrement r/m32 by 1.;;
DEC;m16/r16;;;;ModRM:r/m (r, w);;;;;REX.W0;FF;/1;;;Valid;Valid;8086;;DEC;DEC;NA;Decrement r/m16 by 1.;;
DIV;m8/r8;;;;ModRM:r/m (r);;;;;;F6;/6;;;Valid;Valid;8086;;DIV;DIV;NA;Unsigned divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder.;;
DIV;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;F6;/6;;;Valid;N.E.;8086;;DIV;DIV;NA;Unsigned divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
DIV;m32/r32;;;;ModRM:r/m (r);;;;;REX.W0;F7;/6;;;Valid;Valid;8086;;DIV;DIV;NA;Unsigned divide EDX:EAX by r/m32, with result stored in EAX ← Quotient, EDX ← Remainder.;;
DIV;m64/r64;;;;ModRM:r/m (r);;;;;REX.W;F7;/6;;;Valid;N.E.;8086;;DIV;DIV;NA;Unsigned divide RDX:RAX by r/m64, with result stored in RAX ← Quotient, RDX ← Remainder.;;
DIV;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;F7;/6;;;Valid;Valid;8086;;DIV;DIV;NA;Unsigned divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder.;;
DIVPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 5E;/r;;;Valid;Valid;SSE2;;DIVPD;DIV;NA;Divide packed double-precision floating- point values in xmm1 by packed double-precision floating-point values xmm2/m128.;;
DIVPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 5E;/r;;;Valid;Valid;SSE;;DIVPS;DIV;NA;Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point valuesxmm2/m128.;;
DIVSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 5E;/r;;;Valid;Valid;SSE2;;DIVSD;DIV;NA;Divide low double-precision floating-point value n xmm1 by low double-precision floating-point value in xmm2/mem64.;;
DIVSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 5E;/r;;;Valid;Valid;SSE;;DIVSS;DIV;NA;Divide low single-precision floating- point value in xmm1 by low single-precision floating-point value in xmm2/m32.;;
DPPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 3A 41;/r;;ib;Valid;Valid;SSE4_1;;DPPD;UNDEF;NA;Selectively multiply packed DP floating-point values from xmm1 with packed DP floating-point values from xmm2, add and selectively store the packed DP floating-point values to xmm1.;;
DPPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 3A 40;/r;;ib;Valid;Valid;SSE4_1;;DPPS;UNDEF;NA;Selectively multiply packed SP floating-point values from xmm1 with packed SP floating-point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1.;;
EMMS;;;;;;;;;;;0F 77;;;;Valid;Valid;8086;;EMMS;EMMS;NA;Set the x87 FPU tag word to empty.;;
ENTER;imm16;imm8;;;imm16;Offset;;;;;C8;;cw;ib;Valid;Valid;8086;;ENTER;ENTER;NA;Create a nested stack frame for a procedure.;;
ENTER;imm16;imm8=1;;;imm16;Offset;;;;;C8;;cw;1;Valid;Valid;8086;R;ENTER;ENTER;NA;Create a nested stack frame for a procedure.;;
ENTER;imm16;imm8=0;;;imm16;Offset;;;;;C8;;cw;0;Valid;Valid;8086;R;ENTER;ENTER;NA;Create a stack frame for a procedure.;;
EXTRACTPS;imm8;xmm;m32/r32;;imm8;ModRM:reg (r);ModRM:r/m (w);;66;REX.W0;0F 3A 17;/r;;ib;Valid;Valid;SSE4_1;;EXTRACTPS;EXTRACTPS;NA;Extract a single-precision floating-point value from xmm2 at the source offset specified by imm8 and store the result to reg or m32. The upper 32 bits of r64 is zeroed if reg is r64.;;
F2XM1;;;;;;;;;;;D9 F0;;;;Valid;Valid;8086;;F2XM1;F2XM1;NA;Replace ST(0) with (2ST(0) – 1).;;
FABS;;;;;;;;;;;D9 E1;;;;Valid;Valid;8086;;FABS;FABS;NA;Replace ST with its absolute value.;;
FADD;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/0;;;Valid;Valid;8086;;FADD;FADD;NA;Add m32fp to ST(0) and store result in ST(0).;;
FADD;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 C0+i;;;;Valid;Valid;8086;;FADD;FADD;NA;Add ST(0) to ST(i) and store result in ST(0).;;
FADD;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/0;;;Valid;Valid;8086;;FADD;FADD;NA;Add m64fp to ST(0) and store result in ST(0).;;
FADD;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC C0+i;;;;Valid;Valid;8086;;FADD;FADD;NA;Add ST(i) to ST(0) and store result in ST(i).;;
FADDP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE C0+i;;;;Valid;Valid;8086;;FADDP;FADD;NA;Add ST(0) to ST(i), store result in ST(i), and pop the register stack.;;
FADDP;;;;;;;;;;;DE C1;;;;Valid;Valid;8086;R;FADDP;FADD;NA;Add ST(0) to ST(1), store result in ST(1), and pop the register stack.;;
FBLD;m80bcd;;;;ModRM:r/m (r);;;;;REX.W0;DF;/4;;;Valid;Valid;8086;;FBLD;FBLD;NA;Convert BCD value to floating-point and push onto the FPU stack.;;
FBSTP;m80bcd;;;;ModRM:r/m (r);;;;;REX.W0;DF;/6;;;Valid;Valid;8086;;FBSTP;FBSTP;NA;Store ST(0) in m80bcd and pop ST(0).;;
FCHS;;;;;;;;;;;D9 E0;;;;Valid;Valid;8086;;FCHS;FCHS;NA;Complements sign of ST(0).;;
FCLEX;;;;;;;;;;;9B DB E2;;;;Valid;Valid;8086;;FCLEX;FCLEX;NA;Clear floating-point exception flags after checking for pending unmasked floating-point exceptions.;;
FCMOVB;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DA C0+i;;;;Valid;Valid;8086;;FCMOVB;FCMOV;NA;Move if below (CF=1).;;
FCMOVBE;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DA D0+i;;;;Valid;Valid;8086;;FCMOVBE;FCMOV;NA;Move if below or equal (CF=1 or ZF=1).;;
FCMOVE;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DA C8+i;;;;Valid;Valid;8086;;FCMOVE;FCMOV;NA;Move if equal (ZF=1).;;
FCMOVNB;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB C0+i;;;;Valid;Valid;8086;;FCMOVNB;FCMOV;NA;Move if not below (CF=0).;;
FCMOVNBE;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB D0+i;;;;Valid;Valid;8086;;FCMOVNBE;FCMOV;NA;Move if not below or equal;;
FCMOVNE;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB C8+i;;;;Valid;Valid;8086;;FCMOVNE;FCMOV;NA;Move if not equal (ZF=0).;;
FCMOVNU;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB D8+i;;;;Valid;Valid;8086;;FCMOVNU;FCMOV;NA;Move if not unordered (PF=0).;;
FCMOVU;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DA D8+i;;;;Valid;Valid;8086;;FCMOVU;FCMOV;NA;Move if unordered (PF=1).;;
FCOM;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/2;;;Valid;Valid;8086;;FCOM;FCOM;NA;Compare ST(0) with m32fp.;;
FCOM;ST(i);;;;Opcode (r);;;;;;D8 D0+i;;;;Valid;Valid;8086;;FCOM;FCOM;NA;Compare ST(0) with ST(i).;;
FCOM;;;;;;;;;;;D8 D1;;;;Valid;Valid;8086;R;FCOM;FCOM;NA;Compare ST(0) with ST(1).;;
FCOM;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/2;;;Valid;Valid;8086;;FCOM;FCOM;NA;Compare ST(0) with m64fp.;;
FCOMI;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB F0+i;;;;Valid;Valid;8086;;FCOMI;FCOM;NA;Compare ST(0) with ST(i) and set status flags accordingly.;;
FCOMIP;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DF F0+i;;;;Valid;Valid;8086;;FCOMIP;FCOM;NA;Compare ST(0) with ST(i), set status flags accordingly, and pop register stack.;;
FCOMP;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/3;;;Valid;Valid;8086;;FCOMP;FCOM;NA;Compare ST(0) with m32fp and pop register stack.;;
FCOMP;ST(i);;;;Opcode (r);;;;;;D8 D8+i;;;;Valid;Valid;8086;;FCOMP;FCOM;NA;Compare ST(0) with ST(i) and pop register stack.;;
FCOMP;;;;;;;;;;;D8 D9;;;;Valid;Valid;8086;R;FCOMP;FCOM;NA;Compare ST(0) with ST(1) and pop register stack.;;
FCOMP;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/3;;;Valid;Valid;8086;;FCOMP;FCOM;NA;Compare ST(0) with m64fp and pop register stack.;;
FCOMPP;;;;;;;;;;;DE D9;;;;Valid;Valid;8086;;FCOMPP;FCOM;NA;Compare ST(0) with ST(1) and pop register stack twice.;;
FCOS;;;;;;;;;;;D9 FF;;;;Valid;Valid;8086;;FCOS;FCOS;NA;Replace ST(0) with its cosine.;;
FDECSTP;;;;;;;;;;;D9 F6;;;;Valid;Valid;8086;;FDECSTP;FDECSTP;NA;Decrement TOP field in FPU status word.;;
FDISI;;;;;;;;;;;9B DB E1;;;;Invalid;Invalid;8087;;FDISI;FDISI;NA;;;
FDIV;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/6;;;Valid;Valid;8086;;FDIV;FDIV;NA;Divide ST(0) by m32fp and store result in ST(0).;;
FDIV;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 F0+i;;;;Valid;Valid;8086;;FDIV;FDIV;NA;Divide ST(0) by ST(i) and store result in ST(0).;;
FDIV;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/6;;;Valid;Valid;8086;;FDIV;FDIV;NA;Divide ST(0) by m64fp and store result in ST(0).;;
FDIV;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC F8+i;;;;Valid;Valid;8086;;FDIV;FDIV;NA;Divide ST(i) by ST(0) and store result in ST(i).;;
FDIVP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE F8+i;;;;Valid;Valid;8086;;FDIVP;FDIV;NA;Divide ST(i) by ST(0), store result in ST(i), and pop the register stack.;;
FDIVP;;;;;;;;;;;DE F9;;;;Valid;Valid;8086;R;FDIVP;FDIV;NA;Divide ST(1) by ST(0), store result in ST(1), and pop the register stack.;;
FDIVR;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/7;;;Valid;Valid;8086;;FDIVR;FDIV;NA;Divide m32fp by ST(0) and store result in ST(0).;;
FDIVR;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 F8+i;;;;Valid;Valid;8086;;FDIVR;FDIV;NA;Divide ST(i) by ST(0) and store result in ST(0).;;
FDIVR;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/7;;;Valid;Valid;8086;;FDIVR;FDIV;NA;Divide m64fp by ST(0) and store result in ST(0).;;
FDIVR;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC F0+i;;;;Valid;Valid;8086;;FDIVR;FDIV;NA;Divide ST(0) by ST(i) and store result in ST(i).;;
FDIVRP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE F0+i;;;;Valid;Valid;8086;;FDIVRP;FDIV;NA;Divide ST(0) by ST(i), store result in ST(i), and pop the register stack.;;
FDIVRP;;;;;;;;;;;DE F1;;;;Valid;Valid;8086;R;FDIVRP;FDIV;NA;Divide ST(0) by ST(1), store result in ST(1), and pop the register stack.;;
FEMMS;;;;;;;;;;;0F 0E;;;;Valid;Valid;3DNow;;FEMMS;FEMMS;NA;;;
FENI;;;;;;;;;;;9B DB E0;;;;Invalid;Invalid;8087;;FENI;FENI;NA;;;
FFREE;ST(i);;;;Opcode;;;;;;DD C0+i;;;;Valid;Valid;8086;;FFREE;FFREE;NA;Sets tag for ST(i) to empty.;;
FIADD;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/0;;;Valid;Valid;8086;;FIADD;FADD;NA;Add m32int to ST(0) and store result in ST(0).;;
FIADD;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/0;;;Valid;Valid;8086;;FIADD;FADD;NA;Add m16int to ST(0) and store result in ST(0).;;
FICOM;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/2;;;Valid;Valid;8086;;FICOM;CMP;NA;Compare ST(0) with m32int.;;
FICOM;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/2;;;Valid;Valid;8086;;FICOM;CMP;NA;Compare ST(0) with m16int.;;
FICOMP;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/3;;;Valid;Valid;8086;;FICOMP;CMP;NA;Compare ST(0) with m32int and pop stack register.;;
FICOMP;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/3;;;Valid;Valid;8086;;FICOMP;CMP;NA;Compare ST(0) with m16int and pop stack register.;;
FIDIV;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/6;;;Valid;Valid;8086;;FIDIV;FIDIV;NA;Divide ST(0) by m32int and store result in ST(0).;;
FIDIV;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/6;;;Valid;Valid;8086;;FIDIV;FIDIV;NA;Divide ST(0) by m64int and store result in ST(0).;;
FIDIVR;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/7;;;Valid;Valid;8086;;FIDIVR;FIDIV;NA;Divide m32int by ST(0) and store result in ST(0).;;
FIDIVR;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/7;;;Valid;Valid;8086;;FIDIVR;FIDIV;NA;Divide m16int by ST(0) and store result in ST(0).;;
FILD;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DB;/0;;;Valid;Valid;8086;;FILD;FILD;NA;Push m32int onto the FPU register stack.;;
FILD;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/0;;;Valid;Valid;8086;;FILD;FILD;NA;Push m16int onto the FPU register stack.;;
FILD;m64int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/5;;;Valid;Valid;8086;;FILD;FILD;NA;Push m64int onto the FPU register stack.;;
FIMUL;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/1;;;Valid;Valid;8086;;FIMUL;FMUL;NA;Multiply ST(0) by m32int and store result in ST(0).;;
FIMUL;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/1;;;Valid;Valid;8086;;FIMUL;FMUL;NA;Multiply ST(0) by m16int and store result in ST(0).;;
FINCSTP;;;;;;;;;;;D9 F7;;;;Valid;Valid;8086;;FINCSTP;FINCSTP;NA;Increment the TOP field in the FPU status register.;;
FINIT;;;;;;;;;;;9B DB E3;;;;Valid;Valid;8086;;FINIT;FINIT;NA;Initialize FPU after checking for pending unmasked floating-point exceptions.;;
FIST;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DB;/2;;;Valid;Valid;8086;;FIST;FIST;NA;Store ST(0) in m32int.;;
FIST;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/2;;;Valid;Valid;8086;;FIST;FIST;NA;Store ST(0) in m16int.;;
FISTP;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DB;/3;;;Valid;Valid;8086;;FISTP;FIST;NA;Store ST(0) in m32int and pop register stack.;;
FISTP;m64int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/7;;;Valid;Valid;8086;;FISTP;FIST;NA;Store ST(0) in m64int and pop register stack.;;
FISTP;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/3;;;Valid;Valid;8086;;FISTP;FIST;NA;Store ST(0) in m16int and pop register stack.;;
FISTTP;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DB;/1;;;Valid;Valid;8086;;FISTTP;FIST;NA;Store ST(0) in m32int with truncation.;;
FISTTP;m64int;;;;ModRM:r/m (r);;;;;REX.W0;DD;/1;;;Valid;Valid;8086;;FISTTP;FIST;NA;Store ST(0) in m64int with truncation.;;
FISTTP;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DF;/1;;;Valid;Valid;8086;;FISTTP;FIST;NA;Store ST(0) in m16int with truncation.;;
FISUB;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/4;;;Valid;Valid;8086;;FISUB;FIST;NA;Subtract m32int from ST(0) and store result in ST(0).;;
FISUB;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/4;;;Valid;Valid;8086;;FISUB;FSUB;NA;Subtract m16int from ST(0) and store result in ST(0).;;
FISUBR;m32int;;;;ModRM:r/m (r);;;;;REX.W0;DA;/5;;;Valid;Valid;8086;;FISUBR;FSUB;NA;Subtract ST(0) from m32int and store result in ST(0).;;
FISUBR;m16int;;;;ModRM:r/m (r);;;;;REX.W0;DE;/5;;;Valid;Valid;8086;;FISUBR;FSUB;NA;Subtract ST(0) from m16int and store result in ST(0).;;
FLD;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D9;/0;;;Valid;Valid;8086;;FLD;FLD;NA;Push m32fp onto the FPU register stack.;;
FLD;ST(i);;;;Opcode (r);;;;;;D9 C0+i;;;;Valid;Valid;8086;;FLD;FLD;NA;Push ST(i) onto the FPU register stack.;;
FLD;m80fp;;;;ModRM:r/m (r);;;;;REX.W0;DB;/5;;;Valid;Valid;8086;;FLD;FLD;NA;Push m80fp onto the FPU register stack.;;
FLD;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DD;/0;;;Valid;Valid;8086;;FLD;FLD;NA;Push m64fp onto the FPU register stack.;;
FLD1;;;;;;;;;;;D9 E8;;;;Valid;Valid;8086;;FLD1;FLD;NA;Push +1.0 onto the FPU register stack.;;
FLDCW;m2B;;;;ModRM:r/m (r);;;;;REX.W0;D9;/5;;;Valid;Valid;8086;;FLDCW;FLD;NA;Load FPU control word from m2byte.;;
FLDENV;m14B/m28B;;;;ModRM:r/m (r);;;;;REX.W0;D9;/4;;;Valid;Valid;8086;;FLDENV;FLD;NA;Load FPU environment from m14byte or m28byte.;;
FLDL2E;;;;;;;;;;;D9 EA;;;;Valid;Valid;8086;;FLDL2E;FLD;NA;Push log2e onto the FPU register stack.;;
FLDL2T;;;;;;;;;;;D9 E9;;;;Valid;Valid;8086;;FLDL2T;FLD;NA;Push log210 onto the FPU register stack.;;
FLDLG2;;;;;;;;;;;D9 EC;;;;Valid;Valid;8086;;FLDLG2;FLD;NA;Push log102 onto the FPU register stack.;;
FLDLN2;;;;;;;;;;;D9 ED;;;;Valid;Valid;8086;;FLDLN2;FLD;NA;Push loge2 onto the FPU register stack.;;
FLDPI;;;;;;;;;;;D9 EB;;;;Valid;Valid;8086;;FLDPI;FLD;NA;Push π onto the FPU register stack.;;
FLDZ;;;;;;;;;;;D9 EE;;;;Valid;Valid;8086;;FLDZ;FLD;NA;Push +0.0 onto the FPU register stack.;;
FMUL;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/1;;;Valid;Valid;8086;;FMUL;FMUL;NA;Multiply ST(0) by m32fp and store result in ST(0).;;
FMUL;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 C8+i;;;;Valid;Valid;8086;;FMUL;FMUL;NA;Multiply ST(0) by ST(i) and store result in ST(0).;;
FMUL;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/1;;;Valid;Valid;8086;;FMUL;FMUL;NA;Multiply ST(0) by m64fp and store result in ST(0).;;
FMUL;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC C8+i;;;;Valid;Valid;8086;;FMUL;FMUL;NA;Multiply ST(i) by ST(0) and store result in ST(i).;;
FMULP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE C8+i;;;;Valid;Valid;8086;;FMULP;FMUL;NA;Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack.;;
FMULP;;;;;;;;;;;DE C9;;;;Valid;Valid;8086;R;FMULP;FMUL;NA;Multiply ST(1) by ST(0), store resultin ST(1), and pop the register stack.;;
FNCLEX;;;;;;;;;;;DB E2;;;;Valid;Valid;8086;;FNCLEX;FCLEX;NA;Clear floating-point exception flags without checking for pending unmasked floating-point exceptions.;See IA-32 Architecture Compatibility section below.;
FNDISI;;;;;;;;;;;DB E1;;;;Invalid;Invalid;8087;;FNDISI;FDISI;NA;;;
FNENI;;;;;;;;;;;DB E0;;;;Invalid;Invalid;8087;;FNENI;FENI;NA;;;
FNINIT;;;;;;;;;;;DB E3;;;;Valid;Valid;8086;;FNINIT;FINIT;NA;Initialize FPU without checking for pending unmasked floating-point exceptions.;* See IA-32 Architecture Compatibility section below.;
FNOP;;;;;;;;;;;D9 D0;;;;Valid;Valid;8086;;FNOP;FNOP;NA;No operation is performed.;;
FNSAVE;m94B/m108B;;;;ModRM:r/m (w);;;;;REX.W0;DD;/6;;;Valid;Valid;8086;;FNSAVE;FSAVE;NA;Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU.;* See IA-32 Architecture Compatibility section below.;
FNSTCW;m2B;;;;ModRM:r/m (w);;;;;REX.W0;D9;/7;;;Valid;Valid;8086;;FNSTCW;FST;NA;Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions.;* See IA-32 Architecture Compatibility section below.;
FNSTENV;m14B/m28B;;;;ModRM:r/m (w);;;;;REX.W0;D9;/6;;;Valid;Valid;8086;;FNSTENV;FST;NA;Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.;* See IA-32 Architecture Compatibility section below.;
FNSTSW;m2B;;;;ModRM:r/m (w);;;;;REX.W0;DD;/7;;;Valid;Valid;8086;;FNSTSW;FST;NA;Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions.;* See IA-32 Architecture Compatibility section below.;
FNSTSW;r16=AX;;;;;;;;;;DF E0;;;;Valid;Valid;8086;;FNSTSW;FST;NA;Store FPU status word in AX register without checking for pending unmasked floating-point exceptions.;* See IA-32 Architecture Compatibility section below.;
FPATAN;;;;;;;;;;;D9 F3;;;;Valid;Valid;8086;;FPATAN;FPATAN;NA;Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack.;* See IA-32 Architecture Compatibility section below.;
FPREM;;;;;;;;;;;D9 F8;;;;Valid;Valid;8086;;FPREM;FPREM;NA;Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1).;;
FPREM1;;;;;;;;;;;D9 F5;;;;Valid;Valid;8086;;FPREM1;FRPEM;NA;Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1).;;
FPTAN;;;;;;;;;;;D9 F2;;;;Valid;Valid;8086;;FPTAN;FPTAN;NA;Replace ST(0) with its tangent and push 1 onto the FPU stack.;;
FRNDINT;;;;;;;;;;;D9 FC;;;;Valid;Valid;8086;;FRNDINT;FDNDINT;NA;Round ST(0) to an integer.;;
FRSTOR;m94B/m108B;;;;ModRM:r/m (r);;;;;REX.W0;DD;/4;;;Valid;Valid;8086;;FRSTOR;FSTOR;NA;Load FPU state from m94byte or m108byte.;;
FSAVE;m94B/m108B;;;;ModRM:r/m (w);;;;;REX.W0;9B DD;/6;;;Valid;Valid;8086;;FSAVE;FSAVE;NA;Store FPU state to m94byte or m108byte after checking for pending unmasked floating- point exceptions. Then re-initialize the FPU.;;
FSCALE;;;;;;;;;;;D9 FD;;;;Valid;Valid;8086;;FSCALE;FSCALE;NA;Scale ST(0) by ST(1).;;
FSIN;;;;;;;;;;;D9 FE;;;;Valid;Valid;8086;;FSIN;FSIN;NA;Replace ST(0) with its sine.;;
FSINCOS;;;;;;;;;;;D9 FB;;;;Valid;Valid;8086;;FSINCOS;FSINCOS;NA;Compute the sine and cosine of ST(0) replace ST(0) with the sine, and push the cosine onto the register stack.;;
FSQRT;;;;;;;;;;;D9 FA;;;;Valid;Valid;8086;;FSQRT;FSQRT;NA;Computes square root of ST(0) and stores the result in ST(0).;;
FST;m32fp;;;;ModRM:r/m (w);;;;;REX.W0;D9;/2;;;Valid;Valid;8086;;FST;FST;NA;Copy ST(0) to m32fp.;;
FST;m64fp;;;;ModRM:r/m (w);;;;;REX.W0;DD;/2;;;Valid;Valid;8086;;FST;FST;NA;Copy ST(0) to m64fp.;;
FST;ST(i);;;;Opcode (w);;;;;;DD D0+i;;;;Valid;Valid;8086;;FST;FST;NA;Copy ST(0) to ST(i).;;
FSTCW;m2B;;;;ModRM:r/m (w);;;;;REX.W0;9B D9;/7;;;Valid;Valid;8086;;FSTCW;FST;NA;Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions.;;
FSTENV;m14B/m28B;;;;ModRM:r/m (w);;;;;REX.W0;9B D9;/6;;;Valid;Valid;8086;;FSTENV;FST;NA;Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions.;;
FSTP;m32fp;;;;ModRM:r/m (w);;;;;REX.W0;D9;/3;;;Valid;Valid;8086;;FSTP;FST;NA;Copy ST(0) to m32fp and pop register stack.;;
FSTP;m80fp;;;;ModRM:r/m (w);;;;;REX.W0;DB;/7;;;Valid;Valid;8086;;FSTP;FST;NA;Copy ST(0) to m80fp and pop register stack.;;
FSTP;m64fp;;;;ModRM:r/m (w);;;;;REX.W0;DD;/3;;;Valid;Valid;8086;;FSTP;FST;NA;Copy ST(0) to m64fp and pop register stack.;;
FSTP;ST(i);;;;Opcode (w);;;;;;DD D8+i;;;;Valid;Valid;8086;;FSTP;FST;NA;Copy ST(0) to ST(i) and pop register stack.;;
FSTSW;m2B;;;;ModRM:r/m (w);;;;;REX.W0;9B DD;/7;;;Valid;Valid;8086;;FSTSW;FST;NA;Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions.;;
FSTSW;r16=AX;;;;;;;;;;9B DF E0;;;;Valid;Valid;8086;;FSTSW;FST;NA;Store FPU status word in AX register after checking for pending unmasked floating-point exceptions.;;
FSUB;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/4;;;Valid;Valid;8086;;FSUB;FSUB;NA;Subtract m32fp from ST(0) and store result in ST(0).;;
FSUB;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 E0+i;;;;Valid;Valid;8086;;FSUB;FSUB;NA;Subtract ST(i) from ST(0) and store result in ST(0).;;
FSUB;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/4;;;Valid;Valid;8086;;FSUB;FSUB;NA;Subtract m64fp from ST(0) and store result in ST(0).;;
FSUB;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC E8+i;;;;Valid;Valid;8086;;FSUB;FSUB;NA;Subtract ST(0) from ST(i) and store result in ST(i).;;
FSUBP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE E8+i;;;;Valid;Valid;8086;;FSUBP;FSUB;NA;Subtract ST(0) from ST(i), store result in ST(i), and pop register stack.;;
FSUBP;;;;;;;;;;;DE E9;;;;Valid;Valid;8086;R;FSUBP;FSUB;NA;Subtract ST(0) from ST(1), store result in ST(1), and pop register stack.;;
FSUBR;m32fp;;;;ModRM:r/m (r);;;;;REX.W0;D8;/5;;;Valid;Valid;8086;;FSUBR;FSUB;NA;Subtract ST(0) from m32fp and store result in ST(0).;;
FSUBR;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;D8 E8+i;;;;Valid;Valid;8086;;FSUBR;FSUB;NA;Subtract ST(0) from ST(i) and store result in ST(0).;;
FSUBR;m64fp;;;;ModRM:r/m (r);;;;;REX.W0;DC;/5;;;Valid;Valid;8086;;FSUBR;FSUB;NA;Subtract ST(0) from m64fp and store result in ST(0).;;
FSUBR;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DC E0+i;;;;Valid;Valid;8086;;FSUBR;FSUB;NA;Subtract ST(i) from ST(0) and store result in ST(i).;;
FSUBRP;ST(i)=ST(0);ST(i);;;;Opcode (r, w);;;;;DE E0+i;;;;Valid;Valid;8086;;FSUBRP;FSUB;NA;Subtract ST(i) from ST(0), store result in ST(i), and pop register stack.;;
FSUBRP;;;;;;;;;;;DE E1;;;;Valid;Valid;8086;R;FSUBRP;FSUB;NA;Subtract ST(1) from ST(0), store result in ST(1), and pop register stack.;;
FTST;;;;;;;;;;;D9 E4;;;;Valid;Valid;8086;;FTST;FTST;NA;Compare ST(0) with 0.0.;;
FUCOM;ST(i);;;;Opcode (r);;;;;;DD E0+i;;;;Valid;Valid;8086;;FUCOM;UCMP;NA;Compare ST(0) with ST(i).;;
FUCOM;;;;;;;;;;;DD E1;;;;Valid;Valid;8086;R;FUCOM;UCMP;NA;Compare ST(0) with ST(1).;;
FUCOMI;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DB E8+i;;;;Valid;Valid;8086;;FUCOMI;UCMP;NA;Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly.;;
FUCOMIP;ST(i);ST(i)=ST(0);;;Opcode (r);;;;;;DF E8+i;;;;Valid;Valid;8086;;FUCOMIP;UCMP;NA;Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack.;;
FUCOMP;ST(i);;;;Opcode (r);;;;;;DD E8+i;;;;Valid;Valid;8086;;FUCOMP;UCMP;NA;Compare ST(0) with ST(i) and pop register stack.;;
FUCOMP;;;;;;;;;;;DD E9;;;;Valid;Valid;8086;R;FUCOMP;UCMP;NA;Compare ST(0) with ST(1) and pop register stack.;;
FUCOMPP;;;;;;;;;;;DA E9;;;;Valid;Valid;8086;;FUCOMPP;UCMP;NA;Compare ST(0) with ST(1) and pop register stack twice.;;
FWAIT;;;;;;;;;;;9B;;;;Valid;Valid;8086;;FWAIT;WAIT;NA;Check pending unmasked floating-point exceptions.;;
FXAM;;;;;;;;;;;D9 E5;;;;Valid;Valid;8086;;FXAM;FXAM;NA;Classify value or number in ST(0).;;
FXCH;ST(i);;;;Opcode (r, w);;;;;;D9 C8+i;;;;Valid;Valid;8086;;FXCH;FXCH;NA;Exchange the contents of ST(0) and ST(i).;;
FXCH;;;;;;;;;;;D9 C9;;;;Valid;Valid;8086;R;FXCH;FXCH;NA;Exchange the contents of ST(0) and ST(1).;;
FXRSTOR;m512B;;;;ModRM:r/m (r);;;;;;0F AE;/1;;;Valid;Valid;8086;;FXRSTOR;FRSTOR;NA;Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte.;;
FXSAVE;m512B;;;;ModRM:r/m (w);;;;;;0F AE;/0;;;Valid;Valid;8086;;FXSAVE;FXSAVE;NA;Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte.;;
FXTRACT;;;;;;;;;;;D9 F4;;;;Valid;Valid;8086;;FXTRACT;FXTRACT;NA;Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack.;;
FYL2X;;;;;;;;;;;D9 F1;;;;Valid;Valid;8086;;FYL2X;FYL;NA;Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack.;;
FYL2XP1;;;;;;;;;;;D9 F9;;;;Valid;Valid;8086;;FYL2XP1;FYL;NA;Replace ST(1) with ST(1) ∗ log2(ST(0)+ 1.0) and pop the register stack.;;
GETSEC;;;;;;;;;;;0F 37;;;;Valid;Valid;8086;;GETSEC;UNDEF;NA;Depends of EAX value.;;
HADDPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 7C;/r;;;Valid;Valid;SSE3;;HADDPD;HADD;NA;Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1.;;
HADDPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 7C;/r;;;Valid;Valid;SSE3;;HADDPS;HADD;NA;Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1.;;
HLT;;;;;;;;;;;F4;;;;Valid;Valid;8086;;HLT;HLT;NA;Halt;;
HSUBPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 7D;/r;;;Valid;Valid;SSE3;;HSUBPD;HSUB;NA;Horizontal subtract packed double- precision floating-point values from xmm2/m128 to xmm1.;;
HSUBPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 7D;/r;;;Valid;Valid;SSE3;;HSUBPS;HSUB;NA;Horizontal subtract packed single- precision floating-point values from xmm2/m128 to xmm1.;;
IDIV;m8/r8;;;;ModRM:r/m (r);;;;;;F6;/7;;;Valid;Valid;8086;;IDIV;IDIV;NA;Signed divide AX by r/m8, with result stored in: AL ← Quotient, AH ← Remainder.;;
IDIV;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;F6;/7;;;Valid;N.E.;8086;;IDIV;IDIV;NA;Signed divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
IDIV;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;F7;/7;;;Valid;Valid;8086;;IDIV;IDIV;NA;Signed divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder.;;
IDIV;m64/r64;;;;ModRM:r/m (r);;;;;REX.W;F7;/7;;;Valid;N.E.;8086;;IDIV;IDIV;NA;Signed divide RDX:RAX by r/m64, with result stored in RAX ← Quotient, RDX ← Remainder.;;
IDIV;m32/r32;;;;ModRM:r/m (r);;;;;REX.W0;F7;/7;;;Valid;Valid;8086;;IDIV;IDIV;NA;Signed divide EDX:EAX by r/m32, with result stored in EAX ←Quotient, EDX ← Remainder.;;
IMUL;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0F AF;/r;;;Valid;N.E.;8086;;IMUL;IMUL;NA;Quadword register ← Quadword register ∗ r/m64.;;
IMUL;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F AF;/r;;;Valid;Valid;8086;;IMUL;IMUL;NA;word register ← word register ∗ r/m16.;;
IMUL;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F AF;/r;;;Valid;Valid;8086;;IMUL;IMUL;NA;doubleword register ← doubleword register ∗ r/m32.;;
IMUL;imm16;m16/r16;r16;;imm16;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;69;/r;;iw;Valid;Valid;8086;;IMUL;IMUL;NA;word register ← r/m16 ∗ immediate word.;;
IMUL;imm32;m32/r32;r32;;imm32;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;69;/r;;id;Valid;Valid;8086;;IMUL;IMUL;NA;doubleword register ← r/m32 ∗immediate doubleword.;;
IMUL;imm32;m64/r64;r64;;imm32;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W;69;/r;;id;Valid;N.E.;8086;;IMUL;IMUL;NA;Quadword register ← r/m64 ∗ immediate doubleword.;;
IMUL;imm8;m16/r16;r16;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;6B;/r;;ib;Valid;Valid;8086;;IMUL;IMUL;NA;word register ← r/m16 ∗ sign- extended immediate byte.;;
IMUL;imm8;m64/r64;r64;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W;6B;/r;;ib;Valid;N.E.;8086;;IMUL;IMUL;NA;Quadword register ← r/m64 ∗ sign-extended immediate byte.;;
IMUL;imm8;m32/r32;r32;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;6B;/r;;ib;Valid;Valid;8086;;IMUL;IMUL;NA;doubleword register ← r/m32 ∗sign-extended immediate byte.;;
IMUL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;;;F6;/5;;;Valid;Valid;8086;;IMUL;IMUL;NA;AX← AL ∗ r/m byte.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
IMUL;m16/r16;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/5;;;Valid;Valid;8086;;IMUL;IMUL;NA;DX:AX ← AX ∗ r/m word.;;
IMUL;m32/r32;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/5;;;Valid;Valid;8086;;IMUL;IMUL;NA;EDX:EAX ← EAX ∗ r/m32.;;
IMUL;m64/r64;;;;ModRM:r/m (r, w);;;;;REX.W;F7;/5;;;Valid;N.E.;8086;;IMUL;IMUL;NA;RDX:RAX ← RAX ∗ r/m64.;;
IN;imm8;r8=AL;;;imm8;;;;;;E4;;;ib;Valid;Valid;8086;;IN;IN;NA;Input byte from imm8 I/O port address into AL.;;
IN;imm8;r16=AX;;;imm8;;;;;;E5;;;ib;Valid;Valid;8086;Legacy66;IN;IN;NA;Input word from imm8 I/O port address into AX.;;
IN;imm8;r32=EAX;;;imm8;;;;;;E5;;;ib;Valid;Valid;8086;;IN;IN;NA;Input dword from imm8 I/O port address into EAX.;;
IN;r16=DX;r8=AL;;;;;;;;;EC;;;;Valid;Valid;8086;;IN;IN;NA;Input byte from I/O port in DX into AL.;;
IN;r16=DX;r32=EAX;;;;;;;;;ED;;;;Valid;Valid;8086;Legacy-3;IN;IN;NA;Input doubleword from I/O port in DX into EAX.;;
IN;r16=DX;r16=AX;;;;;;;;;ED;;;;Valid;Valid;8086;Legacy66;IN;IN;NA;Input word from I/O port in DX into AX.;;
INC;r32;;;;ModRM:reg (r, w);;;;;;40+rd;;;;N.E.;Valid;8086;;INC;INC;NA;Increment doubleword register by 1.;;
INC;r16;;;;ModRM:reg (r, w);;;;;;40+rw;;;;N.E.;Valid;8086;;INC;INC;NA;Increment word register by 1.;** 40H through 47H are REX prefixes in 64-bit mode.;
INC;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;;REX;FE;/0;;;Valid;N.E.;8086;;INC;INC;NA;Increment r/m byte by 1.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
INC;m8/r8;;;;ModRM:r/m (r, w);;;;;;FE;/0;;;Valid;Valid;8086;;INC;INC;NA;Increment r/m byte by 1.;;
INC;m16/r16;;;;ModRM:r/m (r, w);;;;;REX.W0;FF;/0;;;Valid;Valid;8086;;INC;INC;NA;Increment r/m word by 1.;;
INC;m64/r64;;;;ModRM:r/m (r, w);;;;;REX.W;FF;/0;;;Valid;N.E.;8086;;INC;INC;NA;Increment r/m quadword by 1.;;
INC;m32/r32;;;;ModRM:r/m (r, w);;;;;REX.W0;FF;/0;;;Valid;Valid;8086;;INC;INC;NA;Increment r/m doubleword by 1.;;
INS;r16=DX;m8=ES:(E)DI;;;;;;;;;6C;;;;Valid;Valid;8086;Legacy-1;INS;IN;NA;Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INS;r16=DX;m16=ES:(E)DI;;;;;;;;;6D;;;;Valid;Valid;8086;Legacy-1;INS;IN;NA;Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INS;r16=DX;m32=ES:(E)DI;;;;;;;;;6D;;;;Valid;Valid;8086;Legacy-1;INS;IN;NA;Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INSB;;;;;;;;;;;6C;;;;Valid;Valid;8086;;INSB;IN;NA;Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INSD;;;;;;;;;;;6D;;;;Valid;Valid;8086;;INSL;IN;NA;Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INSERTPS;imm8;xmm/m32;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W0;0F 3A 21;/r;;ib;Valid;Valid;SSE4_1;;INSERTPS;INSERTPS;NA;Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.;;
INSW;;;;;;;;;;;6D;;;;Valid;Valid;8086;Legacy66;INSW;IN;NA;Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1;1. n 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported;
INT;imm8=3;;;;;;;;;;CC;;;;Valid;Valid;8086;;INT;INT;NA;Interrupt 3—trap to debugger.;;
INT;imm8;;;;imm8;;;;;;CD;;;ib;Valid;Valid;8086;;INT;INT;NA;Interrupt vector number specified by immediate byte.;;
INTO;;;;;;;;;;;CE;;;;Invalid;Valid;8086;;INTO;INT;NA;Interrupt 4—if overflow flag is 1.;;
INVD;;;;;;;;;;;0F 08;;;;Valid;Valid;8086;;INVD;INV;NA;Flush internal caches - initiate flushing of external caches.;* See the IA-32 Architecture Compatibility section below.;
INVEPT;m128;r64;;;ModRM:r/m (r);ModRM:reg (r);;;66;;0F 38 80;/r;;;Valid;N.E;8086;;INVEPT;UNDEF;NA;Invalidates EPT-derived entries in the TLBs and paging-structure caches (in 64-bit mode);;
INVEPT;m128;r32;;;ModRM:r/m (r);ModRM:reg (r);;;66;;0F 38 80;/r;;;N.E.;Valid;8086;;INVEPT;UNDEF;NA;Invalidates EPT-derived entries in the TLBs and paging-structure caches (outside 64-bit mode);;
INVLPG;m;;;;ModRM:r/m (r);;;;;REX.W0;0F 01;/7;;;Valid;Valid;8086;;INVLPG;INV;NA;Invalidate TLB Entry for page that contains m.;;
INVVPID;m128;r64;;;ModRM:r/m (r);ModRM:reg (r);;;66;;0F 38 81;/r;;;Valid;N.E;8086;;INVVPID;UNDEF;NA;Invalidates entries in the TLBs and paging-structure caches based on VPID (in 64-bit mode);;
INVVPID;m128;r32;;;ModRM:r/m (r);ModRM:reg (r);;;66;;0F 38 81;/r;;;N.E.;Valid;8086;;INVVPID;UNDEF;NA;Invalidates entries in the TLBs and paging-structure caches based on VPID (outside 64-bit mode);;
IRET;;;;;;;;;;;CF;;;;Valid;Valid;8086;;IRET;IRET;JRET;Interrupt return (16-bit operand size).;;
IRETD;;;;;;;;;;;CF;;;;Valid;Valid;8086;;IRETL;IRET;JRET;Interrupt return (32-bit operand size).;;
IRETQ;;;;;;;;;;REX.W;CF;;;;Valid;N.E.;8086;;IRETQ;IRET;JRET;Interrupt return (64-bit operand size).;;
JA;rel32;;;;Offset;;;;;;0F 87;;cd;;Valid;Valid;8086;;JA;JUMP;JCOND;Jump near if above (CF=0 and ZF=0).;;
JA;rel16;;;;Offset;;;;;;0F 87;;cw;;N.S.;Valid;8086;;JA;JUMP;JCOND;Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode.;;
JA;rel8;;;;Offset;;;;;;77;;cb;;Valid;Valid;8086;;JA;JUMP;JCOND;Jump short if above (CF=0 and ZF=0).;;
JAE;rel32;;;;Offset;;;;;;0F 83;;cd;;Valid;Valid;8086;;JAE;JUMP;JCOND;Jump near if above or equal (CF=0).;;
JAE;rel16;;;;Offset;;;;;;0F 83;;cw;;N.S.;Valid;8086;;JAE;JUMP;JCOND;Jump near if above or equal (CF=0). Not supported in 64-bit mode.;;
JAE;rel8;;;;Offset;;;;;;73;;cb;;Valid;Valid;8086;;JAE;JUMP;JCOND;Jump short if above or equal (CF=0).;;
JB;rel32;;;;Offset;;;;;;0F 82;;cd;;Valid;Valid;8086;;JB;JUMP;JCOND;Jump near if below (CF=1).;;
JB;rel16;;;;Offset;;;;;;0F 82;;cw;;N.S.;Valid;8086;;JB;JUMP;JCOND;Jump near if below (CF=1). Not supported in 64-bit mode.;;
JB;rel8;;;;Offset;;;;;;72;;cb;;Valid;Valid;8086;;JB;JUMP;JCOND;Jump short if below (CF=1).;;
JBE;rel32;;;;Offset;;;;;;0F 86;;cd;;Valid;Valid;8086;;JBE;JUMP;JCOND;Jump near if below or equal (CF=1 or ZF=1).;;
JBE;rel16;;;;Offset;;;;;;0F 86;;cw;;N.S.;Valid;8086;;JBE;JUMP;JCOND;Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode.;;
JBE;rel8;;;;Offset;;;;;;76;;cb;;Valid;Valid;8086;;JBE;JUMP;JCOND;Jump short if below or equal (CF=1 or ZF=1).;;
JC;rel16;;;;Offset;;;;;;0F 82;;cw;;N.S.;Valid;8086;;JC;JUMP;JCOND;Jump near if carry (CF=1). Not supported in 64-bit mode.;;
JC;rel32;;;;Offset;;;;;;0F 82;;cd;;Valid;Valid;8086;;JC;JUMP;JCOND;Jump near if carry (CF=1).;;
JC;rel8;;;;Offset;;;;;;72;;cb;;Valid;Valid;8086;;JC;JUMP;JCOND;Jump short if carry (CF=1).;;
JCXZ;rel8;;;;Offset;;;;;;E3;;cb;;N.E.;Valid;8086;;JCXZ;JUMP;JCOND;Jump short if CX register is 0.;;
JE;rel16;;;;Offset;;;;;;0F 84;;cw;;N.S.;Valid;8086;;JE;JUMP;JCOND;Jump near if equal (ZF=1). Not supported in 64-bit mode.;;
JE;rel32;;;;Offset;;;;;;0F 84;;cd;;Valid;Valid;8086;;JE;JUMP;JCOND;Jump near if equal (ZF=1).;;
JE;rel8;;;;Offset;;;;;;74;;cb;;Valid;Valid;8086;;JE;JUMP;JCOND;Jump short if equal (ZF=1).;;
JECXZ;rel8;;;;Offset;;;;;;E3;;cb;;Valid;Valid;8086;;JECXZ;JUMP;JCOND;Jump short if ECX register is 0.;;
JG;rel16;;;;Offset;;;;;;0F 8F;;cw;;N.S.;Valid;8086;;JG;JUMP;JCOND;Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode.;;
JG;rel32;;;;Offset;;;;;;0F 8F;;cd;;Valid;Valid;8086;;JG;JUMP;JCOND;Jump near if greater (ZF=0 and SF=OF).;;
JG;rel8;;;;Offset;;;;;;7F;;cb;;Valid;Valid;8086;;JG;JUMP;JCOND;Jump short if greater (ZF=0 and SF=OF).;;
JGE;rel32;;;;Offset;;;;;;0F 8D;;cd;;Valid;Valid;8086;;JGE;JUMP;JCOND;Jump near if greater or equal (SF=OF).;;
JGE;rel16;;;;Offset;;;;;;0F 8D;;cw;;N.S.;Valid;8086;;JGE;JUMP;JCOND;Jump near if greater or equal (SF=OF). Not supported in 64-bit mode.;;
JGE;rel8;;;;Offset;;;;;;7D;;cb;;Valid;Valid;8086;;JGE;JUMP;JCOND;Jump short if greater or equal (SF=OF).;;
JL;rel32;;;;Offset;;;;;;0F 8C;;cd;;Valid;Valid;8086;;JL;JUMP;JCOND;Jump near if less (SF≠ OF).;;
JL;rel16;;;;Offset;;;;;;0F 8C;;cw;;N.S.;Valid;8086;;JL;JUMP;JCOND;Jump near if less (SF≠ OF). Not supported in 64-bit mode.;;
JL;rel8;;;;Offset;;;;;;7C;;cb;;Valid;Valid;8086;;JL;JUMP;JCOND;Jump short if less (SF≠ OF).;;
JLE;rel32;;;;Offset;;;;;;0F 8E;;cd;;Valid;Valid;8086;;JLE;JUMP;JCOND;Jump near if less or equal (ZF=1 or SF≠OF).;;
JLE;rel16;;;;Offset;;;;;;0F 8E;;cw;;N.S.;Valid;8086;;JLE;JUMP;JCOND;Jump near if less or equal (ZF=1 or SF≠OF). Not supported in 64-bit mode.;;
JLE;rel8;;;;Offset;;;;;;7E;;cb;;Valid;Valid;8086;;JLE;JUMP;JCOND;Jump short if less or equal (ZF=1 or SF≠ OF).;;
JMP;rel16;;;;Offset;;;;;;E9;;cw;;N.S.;Valid;8086;;JMP;JUMP;JUMP;Jump near, relative, displacement relative to next instruction. Not supported in 64- bit mode.;;
JMP;rel32;;;;Offset;;;;;;E9;;cd;;Valid;Valid;8086;;JMP;JUMP;JUMP;Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits;;
JMP;ptr16:32;;;;Offset;;;;;;EA;;cp;;Invalid;Valid;8086;;JMP;JUMP;JUMP;Jump far, absolute, address given in operand;;
JMP;ptr16:16;;;;Offset;;;;;;EA;;cd;;Invalid;Valid;8086;;JMP;JUMP;JUMP;Jump far, absolute, address given in operand;;
JMP;rel8;;;;Offset;;;;;;EB;;cb;;Valid;Valid;8086;;JMP;JUMP;JUMP;Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits;;
JMP;m16:32;;;;ModRM:r/m (r);;;;;REX.W0;FF;/5;;;Valid;Valid;8086;;JMP;JUMP;JUMP;Jump far, absolute indirect, address given in m16:32.;;
JMP;m64/r64;;;;ModRM:r/m (r);;;;;REX.W0;FF;/4;;;Valid;N.E.;8086;;JMP;JUMP;JUMP;Jump near, absolute indirect, RIP = 64-Bit offset from register or memory;;
JMP;m16:64;;;;ModRM:r/m (r);;;;;REX.W;FF;/5;;;Valid;N.E.;8086;;JMP;JUMP;JUMP;Jump far, absolute indirect, address given in m16:64.;;
JMP;m32/r32;;;;ModRM:r/m (r);;;;;;FF;/4;;;N.S.;Valid;8086;;JMP;JUMP;JUMP;Jump near, absolute indirect, address = sign-extended r/m32. Not supported in 64-bit mode.;;
JMP;m16/r16;;;;ModRM:r/m (r);;;;;;FF;/4;;;N.S.;Valid;8086;;JMP;JUMP;JUMP;Jump near, absolute indirect, address = sign-extended r/m16. Not supported in 64-bit mode.;;
JMP;m16:16;;;;ModRM:r/m (r);;;;;REX.W0;FF;/5;;;Valid;Valid;8086;;JMP;JUMP;JUMP;Jump far, absolute indirect, address given in m16:16;;
JNA;rel32;;;;Offset;;;;;;0F 86;;cd;;Valid;Valid;8086;;JNA;JUMP;JCOND;Jump near if not above (CF=1 or ZF=1).;;
JNA;rel16;;;;Offset;;;;;;0F 86;;cw;;N.S.;Valid;8086;;JNA;JUMP;JCOND;Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode.;;
JNA;rel8;;;;Offset;;;;;;76;;cb;;Valid;Valid;8086;;JNA;JUMP;JCOND;Jump short if not above (CF=1 or ZF=1).;;
JNAE;rel32;;;;Offset;;;;;;0F 82;;cd;;Valid;Valid;8086;;JNAE;JUMP;JCOND;Jump near if not above or equal (CF=1).;;
JNAE;rel16;;;;Offset;;;;;;0F 82;;cw;;N.S.;Valid;8086;;JNAE;JUMP;JCOND;Jump near if not above or equal (CF=1). Not supported in 64-bit mode.;;
JNAE;rel8;;;;Offset;;;;;;72;;cb;;Valid;Valid;8086;;JNAE;JUMP;JCOND;Jump short if not above or equal (CF=1).;;
JNB;rel32;;;;Offset;;;;;;0F 83;;cd;;Valid;Valid;8086;;JNB;JUMP;JCOND;Jump near if not below (CF=0).;;
JNB;rel16;;;;Offset;;;;;;0F 83;;cw;;N.S.;Valid;8086;;JNB;JUMP;JCOND;Jump near if not below (CF=0). Not supported in 64-bit mode.;;
JNB;rel8;;;;Offset;;;;;;73;;cb;;Valid;Valid;8086;;JNB;JUMP;JCOND;Jump short if not below (CF=0).;;
JNBE;rel16;;;;Offset;;;;;;0F 87;;cw;;N.S.;Valid;8086;;JNBE;JUMP;JCOND;Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode.;;
JNBE;rel32;;;;Offset;;;;;;0F 87;;cd;;Valid;Valid;8086;;JNBE;JUMP;JCOND;Jump near if not below or equal (CF=0 and ZF=0).;;
JNBE;rel8;;;;Offset;;;;;;77;;cb;;Valid;Valid;8086;;JNBE;JUMP;JCOND;Jump short if not below or equal (CF=0 and ZF=0).;;
JNC;rel32;;;;Offset;;;;;;0F 83;;cd;;Valid;Valid;8086;;JNC;JUMP;JCOND;Jump near if not carry (CF=0).;;
JNC;rel16;;;;Offset;;;;;;0F 83;;cw;;N.S.;Valid;8086;;JNC;JUMP;JCOND;Jump near if not carry (CF=0). Not supported in 64-bit mode.;;
JNC;rel8;;;;Offset;;;;;;73;;cb;;Valid;Valid;8086;;JNC;JUMP;JCOND;Jump short if not carry (CF=0).;;
JNE;rel32;;;;Offset;;;;;;0F 85;;cd;;Valid;Valid;8086;;JNE;JUMP;JCOND;Jump near if not equal (ZF=0).;;
JNE;rel16;;;;Offset;;;;;;0F 85;;cw;;N.S.;Valid;8086;;JNE;JUMP;JCOND;Jump near if not equal (ZF=0). Not supported in 64-bit mode.;;
JNE;rel8;;;;Offset;;;;;;75;;cb;;Valid;Valid;8086;;JNE;JUMP;JCOND;Jump short if not equal (ZF=0).;;
JNG;rel32;;;;Offset;;;;;;0F 8E;;cd;;Valid;Valid;8086;;JNG;JUMP;JCOND;Jump near if not greater (ZF=1 or SF≠OF).;;
JNG;rel16;;;;Offset;;;;;;0F 8E;;cw;;N.S.;Valid;8086;;JNG;JUMP;JCOND;Jump near if not greater (ZF=1 or SF≠OF). Not supported in 64-bit mode.;;
JNG;rel8;;;;Offset;;;;;;7E;;cb;;Valid;Valid;8086;;JNG;JUMP;JCOND;Jump short if not greater (ZF=1 or SF≠ OF).;;
JNGE;rel32;;;;Offset;;;;;;0F 8C;;cd;;Valid;Valid;8086;;JNGE;JUMP;JCOND;Jump near if not greater or equal (SF≠OF).;;
JNGE;rel16;;;;Offset;;;;;;0F 8C;;cw;;N.S.;Valid;8086;;JNGE;JUMP;JCOND;Jump near if not greater or equal (SF≠OF). Not supported in 64-bit mode.;;
JNGE;rel8;;;;Offset;;;;;;7C;;cb;;Valid;Valid;8086;;JNGE;JUMP;JCOND;Jump short if not greater or equal (SF≠ OF).;;
JNL;rel16;;;;Offset;;;;;;0F 8D;;cw;;N.S.;Valid;8086;;JNL;JUMP;JCOND;Jump near if not less (SF=OF). Not supported in 64-bit mode.;;
JNL;rel32;;;;Offset;;;;;;0F 8D;;cd;;Valid;Valid;8086;;JNL;JUMP;JCOND;Jump near if not less (SF=OF).;;
JNL;rel8;;;;Offset;;;;;;7D;;cb;;Valid;Valid;8086;;JNL;JUMP;JCOND;Jump short if not less (SF=OF).;;
JNLE;rel16;;;;Offset;;;;;;0F 8F;;cw;;N.S.;Valid;8086;;JNLE;JUMP;JCOND;Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode.;;
JNLE;rel32;;;;Offset;;;;;;0F 8F;;cd;;Valid;Valid;8086;;JNLE;JUMP;JCOND;Jump near if not less or equal (ZF=0 and SF=OF).;;
JNLE;rel8;;;;Offset;;;;;;7F;;cb;;Valid;Valid;8086;;JNLE;JUMP;JCOND;Jump short if not less or equal (ZF=0 and SF=OF).;;
JNO;rel32;;;;Offset;;;;;;0F 81;;cd;;Valid;Valid;8086;;JNO;JUMP;JCOND;Jump near if not overflow (OF=0).;;
JNO;rel16;;;;Offset;;;;;;0F 81;;cw;;N.S.;Valid;8086;;JNO;JUMP;JCOND;Jump near if not overflow (OF=0). Not supported in 64-bit mode.;;
JNO;rel8;;;;Offset;;;;;;71;;cb;;Valid;Valid;8086;;JNO;JUMP;JCOND;Jump short if not overflow (OF=0).;;
JNP;rel16;;;;Offset;;;;;;0F 8B;;cw;;N.S.;Valid;8086;;JNP;JUMP;JCOND;Jump near if not parity (PF=0). Not supported in 64-bit mode.;;
JNP;rel32;;;;Offset;;;;;;0F 8B;;cd;;Valid;Valid;8086;;JNP;JUMP;JCOND;Jump near if not parity (PF=0).;;
JNP;rel8;;;;Offset;;;;;;7B;;cb;;Valid;Valid;8086;;JNP;JUMP;JCOND;Jump short if not parity (PF=0).;;
JNS;rel32;;;;Offset;;;;;;0F 89;;cd;;Valid;Valid;8086;;JNS;JUMP;JCOND;Jump near if not sign (SF=0).;;
JNS;rel16;;;;Offset;;;;;;0F 89;;cw;;N.S.;Valid;8086;;JNS;JUMP;JCOND;Jump near if not sign (SF=0). Not supported in 64-bit mode.;;
JNS;rel8;;;;Offset;;;;;;79;;cb;;Valid;Valid;8086;;JNS;JUMP;JCOND;Jump short if not sign (SF=0).;;
JNZ;rel32;;;;Offset;;;;;;0F 85;;cd;;Valid;Valid;8086;;JNZ;JUMP;JCOND;Jump near if not zero (ZF=0).;;
JNZ;rel16;;;;Offset;;;;;;0F 85;;cw;;N.S.;Valid;8086;;JNZ;JUMP;JCOND;Jump near if not zero (ZF=0). Not supported in 64-bit mode.;;
JNZ;rel8;;;;Offset;;;;;;75;;cb;;Valid;Valid;8086;;JNZ;JUMP;JCOND;Jump short if not zero (ZF=0).;;
JO;rel32;;;;Offset;;;;;;0F 80;;cd;;Valid;Valid;8086;;JO;JUMP;JCOND;Jump near if overflow (OF=1).;;
JO;rel16;;;;Offset;;;;;;0F 80;;cw;;N.S.;Valid;8086;;JO;JUMP;JCOND;Jump near if overflow (OF=1). Not supported in 64-bit mode.;;
JO;rel8;;;;Offset;;;;;;70;;cb;;Valid;Valid;8086;;JO;JUMP;JCOND;Jump short if overflow (OF=1).;;
JP;rel16;;;;Offset;;;;;;0F 8A;;cw;;N.S.;Valid;8086;;JP;JUMP;JCOND;Jump near if parity (PF=1). Not supported in 64-bit mode.;;
JP;rel32;;;;Offset;;;;;;0F 8A;;cd;;Valid;Valid;8086;;JP;JUMP;JCOND;Jump near if parity (PF=1).;;
JP;rel8;;;;Offset;;;;;;7A;;cb;;Valid;Valid;8086;;JP;JUMP;JCOND;Jump short if parity (PF=1).;;
JPE;rel32;;;;Offset;;;;;;0F 8A;;cd;;Valid;Valid;8086;;JPE;JUMP;JCOND;Jump near if parity even (PF=1).;;
JPE;rel16;;;;Offset;;;;;;0F 8A;;cw;;N.S.;Valid;8086;;JPE;JUMP;JCOND;Jump near if parity even (PF=1). Not supported in 64-bit mode.;;
JPE;rel8;;;;Offset;;;;;;7A;;cb;;Valid;Valid;8086;;JPE;JUMP;JCOND;Jump short if parity even (PF=1).;;
JPO;rel32;;;;Offset;;;;;;0F 8B;;cd;;Valid;Valid;8086;;JPO;JUMP;JCOND;Jump near if parity odd (PF=0).;;
JPO;rel16;;;;Offset;;;;;;0F 8B;;cw;;N.S.;Valid;8086;;JPO;JUMP;JCOND;Jump near if parity odd (PF=0). Not supported in 64-bit mode.;;
JPO;rel8;;;;Offset;;;;;;7B;;cb;;Valid;Valid;8086;;JPO;JUMP;JCOND;Jump short if parity odd (PF=0).;;
JRCXZ;rel8;;;;Offset;;;;;;E3;;cb;;Valid;N.E.;8086;;JRCXZ;JUMP;JCOND;Jump short if RCX register is 0.;;
JS;rel32;;;;Offset;;;;;;0F 88;;cd;;Valid;Valid;8086;;JS;JUMP;JCOND;Jump near if sign (SF=1).;;
JS;rel16;;;;Offset;;;;;;0F 88;;cw;;N.S.;Valid;8086;;JS;JUMP;JCOND;Jump near if sign (SF=1). Not supported in 64-bit mode.;;
JS;rel8;;;;Offset;;;;;;78;;cb;;Valid;Valid;8086;;JS;JUMP;JCOND;Jump short if sign (SF=1).;;
JZ;rel32;;;;Offset;;;;;;0F 84;;cd;;Valid;Valid;8086;;JZ;JUMP;JCOND;Jump near if 0 (ZF=1).;;
JZ;rel16;;;;Offset;;;;;;0F 84;;cw;;N.S.;Valid;8086;;JZ;JUMP;JCOND;Jump near if 0 (ZF=1). Not supported in 64-bit mode.;;
JZ;rel8;;;;Offset;;;;;;74;;cb;;Valid;Valid;8086;;JZ;JUMP;JCOND;Jump short if zero (ZF ← 1).;;
LAHF;;;;;;;;;;;9F;;;;Invalid;Valid;8086;;LAHF;LAHF;NA;Load: AH ← EFLAGS(SF:ZF:0:AF:0:PF:1:CF).;64 bits mode valid in specific steppings. See Description section.;
LAR;r32/m16;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 02;/r;;;Valid;Valid;8086;Legacy-3;LAR;LAR;NA;r32 ← r32/m16 masked by 00FxFF00H;1. For all loads (regardless of source or destination sizing) only bits 16-0 are used. Other bits are ignored.;
LAR;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 02;/r;;;Valid;Valid;8086;Legacy66;LAR;LAR;NA;r16 ← r16/m16 masked by FF00H.;;
LAR;r64/m16;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F 02;/r;;;Valid;N.E.;8086;;LAR;LAR;NA;r64 ← r32/m16 masked by 00FxFF00H and zero extended;1. For all loads (regardless of source or destination sizing) only bits 16-0 are used. Other bits are ignored.;
LDDQU;m;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F F0;/r;;;Valid;Valid;SSE3;;LDDQU;LDDQU;NA;Load unaligned data from mem and return double quadword in xmm1.;;
LDMXCSR;m32;;;;ModRM:r/m (r);;;;;;0F AE;/2;;;Valid;Valid;SSE;;LDMXCSR;LDMXCSR;NA;Load MXCSR register from m32.;;
LDS;m16:32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;C5;/r;;;Invalid;Valid;8086;;LDS;LFP;NA;Load DS:r32 with far pointer from memory.;;
LDS;m16:16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;;C5;/r;;;Invalid;Valid;8086;;LDS;LFP;NA;Load DS:r16 with far pointer from memory.;;
LEA;m;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;8D;/r;;;Valid;N.E.;8086;;LEA;LEA;NA;Store effective address for m in register r64.;;
LEA;m;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;8D;/r;;;Valid;Valid;8086;;LEA;LEA;NA;Store effective address for m in register r16.;;
LEA;m;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;8D;/r;;;Valid;Valid;8086;;LEA;LEA;NA;Store effective address for m in register r32.;;
LEAVE;;;;;;;;;;;C9;;;;Valid;Valid;8086;;LEAVE;LEAVE;NA;Set SP to BP, then pop BP.;;
LEAVE;;;;;;;;;;;C9;;;;N.E.;Valid;8086;;LEAVE;LEAVE;NA;Set ESP to EBP, then pop EBP.;;
LEAVE;;;;;;;;;;;C9;;;;Valid;N.E.;8086;;LEAVE;LEAVE;NA;Set RSP to RBP, then pop RBP.;;
LES;m16:16;;;;ModRM:r/m (r);;;;;;C4;/r;;;Invalid;Valid;8086;;LES;LFP;NA;Load ES:r16 with far pointer from memory.;;
LES;m16:32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;C4;/r;;;Invalid;Valid;8086;;LES;LFP;NA;Load ES:r32 with far pointer from memory.;;
LFENCE;;;;;;;;;;;0F AE E8;;;;Valid;Valid;8086;;LFENCE;LFENCE;NA;Serializes load operations.;;
LFS;m16:32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B4;/r;;;Valid;Valid;8086;Legacy-3;LFS;LFP;NA;Load FS:r32 with far pointer from memory.;;
LFS;m16:64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX;0F B4;/r;;;Valid;N.E.;8086;;LFS;LFP;NA;Load FS:r64 with far pointer from memory.;;
LFS;m16:16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B4;/r;;;Valid;Valid;8086;Legacy66;LFS;LFP;NA;Load FS:r16 with far pointer from memory.;;
LGDT;m16&32;;;;ModRM:r/m (r);;;;;;0F 01;/2;;;N.E.;Valid;8086;;LGDT;LDT;NA;Load m into GDTR.;;
LGDT;m16&64;;;;ModRM:r/m (r);;;;;REX.W0;0F 01;/2;;;Valid;N.E.;8086;;LGDT;LDT;NA;Load m into GDTR.;;
LGS;m16:32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B5;/r;;;Valid;Valid;8086;Legacy-3;LGS;LFP;NA;Load GS:r32 with far pointer from memory.;;
LGS;m16:64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX;0F B5;/r;;;Valid;N.E.;8086;;LGS;LFP;NA;Load GS:r64 with far pointer from memory.;;
LGS;m16:16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B5;/r;;;Valid;Valid;8086;Legacy66;LGS;LFP;NA;Load GS:r16 with far pointer from memory.;;
LIDT;m16&32;;;;ModRM:r/m (r);;;;;;0F 01;/3;;;N.E.;Valid;8086;;LIDT;LDT;NA;Load m into IDTR.;;
LIDT;m16&64;;;;ModRM:r/m (r);;;;;REX.W0;0F 01;/3;;;Valid;N.E.;8086;;LIDT;LDT;NA;Load m into IDTR.;;
LLDT;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;0F 00;/2;;;Valid;Valid;8086;;LLDT;LDT;NA;Load segment selector r/m16 into LDTR.;;
LMSW;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;0F 01;/6;;;Valid;Valid;8086;;LMSW;LMSW;NA;Loads r/m16 in machine status word of CR0.;;
LOCK;;;;;;;;;;;F0;;;;Valid;Valid;8086;;LOCK;LOCK;NA;Asserts LOCK# signal for duration of the accompanying instruction.;;
LODS;m8=(R)SI;;;;;;;;;REX.W0;AC;;;;Valid;Valid;8086;;LODS;LODS;NA;For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.;;
LODS;m16=(R)SI;;;;;;;;;REX.W0;AD;;;;Valid;Valid;8086;Legacy66;LODS;LODS;NA;For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.;;
LODS;m64=(R)SI;;;;;;;;;REX.W;AD;;;;Valid;N.E.;8086;;LODS;LODS;NA;Load qword at address (R)SI into RAX.;;
LODS;m32=(R)SI;;;;;;;;;REX.W0;AD;;;;Valid;Valid;8086;Legacy-3;LODS;LODS;NA;For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.;;
LODSB;;;;;;;;;;;AC;;;;Valid;Valid;8086;Legacy-3;LODSB;LODS;NA;For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL.;;
LODSD;;;;;;;;;;;AD;;;;Valid;Valid;8086;;LODSL;LODS;NA;For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX.;;
LODSQ;;;;;;;;;;REX.W;AD;;;;Valid;N.E.;8086;;LODSQ;LODS;NA;Load qword at address (R)SI into RAX.;;
LODSW;;;;;;;;;;;AD;;;;Valid;Valid;8086;Legacy66;LODSW;LODS;NA;For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX.;;
LOOP;rel8;;;;Offset;;;;;;E2;;cb;;Valid;Valid;8086;;LOOP;LOOP;NA;Decrement count jump short if count ≠ 0.;;
LOOPE;rel8;;;;Offset;;;;;;E1;;cb;;Valid;Valid;8086;;LOOPE;LOOP;NA;Decrement count jump short if count ≠ 0 and ZF = 1.;;
LOOPNE;rel8;;;;Offset;;;;;;E0;;cb;;Valid;Valid;8086;;LOOPNE;LOOP;NA;Decrement count jump short if count ≠ 0 and ZF = 0.;;
LOOPNZ;rel8;;;;Offset;;;;;;E0;;cb;;Valid;Valid;8086;;LOOPNZ;LOOP;NA;Decrement count jump short if count ≠ 0 and ZF = 0.;;
LOOPZ;rel8;;;;Offset;;;;;;E1;;cb;;Valid;Valid;8086;;LOOPZ;LOOP;NA;Decrement count jump short if count ≠ 0 and ZF = 1.;;
LSL;r32/m16;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 03;/r;;;Valid;Valid;8086;Legacy-3;LSL;LSL;NA;Load: r32 ← segment limit, selector r32/m16.;1 For all loads (regardless of destination sizing), only bits 16-0 are used. Other bits are ignored.;
LSL;r64/m16;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F 03;/r;;;Valid;Valid;8086;;LSL;LSL;NA;Load: r64 ← segment limit, selector r32/m16;1 For all loads (regardless of destination sizing), only bits 16-0 are used. Other bits are ignored.;
LSL;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 03;/r;;;Valid;Valid;8086;Legacy66;LSL;LSL;NA;Load: r16 ← segment limit, selector r16/m16.;;
LSS;m16:16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B2;/r;;;Valid;Valid;8086;Legacy66;LSS;LFP;NA;Load SS:r16 with far pointer from memory.;;
LSS;m16:64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX;0F B2;/r;;;Valid;N.E.;8086;;LSS;LFP;NA;Load SS:r64 with far pointer from memory.;;
LSS;m16:32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F B2;/r;;;Valid;Valid;8086;Legacy-3;LSS;LFP;NA;Load SS:r32 with far pointer from memory.;;
LTR;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;0F 00;/3;;;Valid;Valid;8086;;LTR;LTR;NA;Load r/m16 into task register.;;
MASKMOVDQU;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F F7;/r;;;Valid;Valid;SSE2;;MASKMOVDQU;MASKMOVQ;NA;Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:EDI.;;
MASKMOVQ;mm;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F F7;/r;;;Valid;Valid;8086;;MASKMOVQ;MASKMOVQ;NA;Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:EDI.;;
MAXPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 5F;/r;;;Valid;Valid;SSE2;;MAXPD;MAX;NA;Return the maximum double- precision floating-point values between xmm2/m128 and xmm1.;;
MAXPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 5F;/r;;;Valid;Valid;SSE;;MAXPS;MAX;NA;Return the maximum single-precision floating-point values between xmm2/m128 and xmm1.;;
MAXSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 5F;/r;;;Valid;Valid;SSE2;;MAXSD;MAX;NA;Return the maximum scalar double-precision floating-point value between xmm2/mem64 and xmm1.;;
MAXSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 5F;/r;;;Valid;Valid;SSE;;MAXSS;MAX;NA;Return the maximum scalar single-precision floating-point value between xmm2/mem32 and xmm1.;;
MFENCE;;;;;;;;;;;0F AE F0;;;;Valid;Valid;8086;;MFENCE;MFENCE;NA;Serializes load and store operations.;;
MINPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 5D;/r;;;Valid;Valid;SSE2;;MINPD;MIN;NA;Return the minimum double- precision floating-point values between xmm2/m128 and xmm1.;;
MINPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 5D;/r;;;Valid;Valid;SSE;;MINPS;MIN;NA;Return the minimum single- precision floating-point values between xmm2/m128 and xmm1.;;
MINSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 5D;/r;;;Valid;Valid;SSE2;;MINSD;MIN;NA;Return the minimum scalar double- precision floating-point value between xmm2/mem64 and xmm1.;;
MINSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 5D;/r;;;Valid;Valid;SSE;;MINSS;MIN;NA;Return the minimum scalar single- precision floating-point value between xmm2/mem32 and xmm1.;;
MONITOR;;;;;;;;;;;0F 01 C8;;;;Valid;Valid;8086;;MONITOR;MONITOR;NA;Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write-back memory caching type. The default address is DS:EAX.;;
MOV;creg;r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 20;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move extended CR0-7 to r64.;;
MOV;creg;r32;;;ModRM:reg (r);ModRM:r/m (w);;;;;0F 20;/r;;;N.E.;Valid;8086;;MOV;MOV;NA;Move CR0-7 to r32.;;
MOV;creg=CR8;r64;;;;ModRM:r/m (w);;;;REX;0F 20;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move extended CR8 to r64.1;1. MOV CR* instructions, except for MOV CR8, are serializing instructions. MOV CR8 is not architecturally defined as a serializing instruction. For more information, see Chapter 7 in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.;
MOV;dreg;r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;0F 21;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move extended debug register to r64.;;
MOV;dreg;r32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 21;/e;;;N.E.;Valid;8086;;MOV;MOV;NA;Move debug register to r32;;
MOV;r64;creg=CR8;;;ModRM:r/m (r);;;;;REX;0F 22;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r64 to extended CR8.;;
MOV;r64;creg;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 22;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r64 to extended CR0-7.;;
MOV;r32;creg;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F 22;/r;;;N.E.;Valid;8086;;MOV;MOV;NA;Move r32 to CR0-7.;;
MOV;r32;dreg;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 23;/e;;;N.E.;Valid;8086;;MOV;MOV;NA;Move r32 to debug register;;
MOV;r64;dreg;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F 23;/e;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r64 to extended debug register.;;
MOV;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (w);;;;REX;88;/r;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r8 to r/m8.;***In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOV;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (w);;;;;88;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r8 to r/m8.;;
MOV;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;89;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r32 to r/m32.;;
MOV;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;89;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r16 to r/m16.;;
MOV;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;89;/r;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r64 to r/m64.;;
MOV;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (w);;;;REX;8A;/r;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r/m8 to r8.;***In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOV;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (w);;;;;8A;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r/m8 to r8.;;
MOV;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;8B;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r/m16 to r16.;;
MOV;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;8B;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r/m32 to r32.;;
MOV;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;8B;/r;;;Valid;N.E.;8086;;MOV;MOV;NA;Move r/m64 to r64.;;
MOV;Sreg;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;8C;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move segment register to r/m16.;** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction (see the following “Description” section for further information).;
MOV;Sreg;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;8C;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move zero extended 16-bit segment register to r/m64.;** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction (see the following “Description” section for further information).;
MOV;m64/r64;Sreg;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;8E;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move lower 16 bits of r/m64 to segment register.;** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction (see the following “Description” section for further information).;
MOV;m16/r16;Sreg;;;ModRM:r/m (r);ModRM:reg (w);;;;;8E;/r;;;Valid;Valid;8086;;MOV;MOV;NA;Move r/m16 to segment register.;** In 32-bit mode, the assembler may insert the 16-bit operand-size prefix with this instruction (see the following “Description” section for further information).;
MOV;moffs8;r8=AL;;;Offset;;;;;REX.W;A0;;cb;;Valid;N.E.;8086;;MOV;MOV;NA;Move byte at (offset) to AL.;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;moffs8;r8=AL;;;Offset;;;;;REX.W0;A0;;cb;;Valid;Valid;8086;;MOV;MOV;NA;Move byte at (seg:offset) to AL.;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;moffs16;r16=AX;;;Offset;;;;;REX.W0;A1;;cw;;Valid;Valid;8086;Legacy66;MOV;MOV;NA;Move word at (seg:offset) to AX.;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;moffs64;r64=RAX;;;Offset;;;;;REX.W;A1;;co;;Valid;N.E.;8086;;MOV;MOV;NA;Move quadword at (offset) to RAX.;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;moffs32;r32=EAX;;;Offset;;;;;REX.W0;A1;;cd;;Valid;Valid;8086;Legacy-3;MOV;MOV;NA;Move doubleword at EAX,moffs32* (seg:offset) to EAX.;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;r8=AL;moffs8;;;;Offset;;;;REX.W;A2;;cb;;Valid;N.E.;8086;;MOV;MOV;NA;Move AL to (offset).;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits. ;
MOV;r8=AL;moffs8;;;;Offset;;;;REX.W0;A2;;cb;;Valid;Valid;8086;;MOV;MOV;NA;Move AL to (seg:offset).;;
MOV;r16=AX;moffs16;;;;Offset;;;;REX.W0;A3;;cw;;Valid;Valid;8086;Legacy66;MOV;MOV;NA;Move AX to (seg:offset).;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;r64=RAX;moffs64;;;;Offset;;;;REX.W;A3;;co;;Valid;N.E.;8086;;MOV;MOV;NA;Move RAX to (offset).;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;r32=EAX;moffs32;;;;Offset;;;;REX.W0;A3;;cd;;Valid;Valid;8086;Legacy-3;MOV;MOV;NA;Move EAX to (seg:offset).;* The moffs8, moffs16, moffs32 and moffs64 operands specify a simple offset relative to the segment base, where 8, 16, 32 and 64 refer to the size of the data. The address-size attribute of the instruction determines the size of the offset, either 16, 32 or 64 bits.;
MOV;imm8;r8;;;imm8;ModRM:reg (w);;;;;B0+rb;;;ib;Valid;Valid;8086;;MOV;MOV;NA;Move imm8 to r8.;;
MOV;imm8;r8<>[ABCD]H;;;imm8;ModRM:reg (w);;;;REX;B0+rb;;;ib;Valid;N.E.;8086;;MOV;MOV;NA;Move imm8 to r8.;***In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOV;imm64;r64;;;imm64;ModRM:reg (w);;;;REX.W;B8+rd;;;io;Valid;N.E.;8086;;MOV;MOV;NA;Move imm64 to r64.;;
MOV;imm32;r32;;;imm32;ModRM:reg (w);;;;REX.W0;B8+rd;;;id;Valid;Valid;8086;;MOV;MOV;NA;Move imm32 to r32.;;
MOV;imm16;r16;;;imm16;ModRM:reg (w);;;;REX.W0;B8+rw;;;iw;Valid;Valid;8086;;MOV;MOV;NA;Move imm16 to r16.;;
MOV;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;C6;/0;;ib;Valid;N.E.;8086;;MOV;MOV;NA;Move imm8 to r/m8.;***In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOV;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;C6;/0;;ib;Valid;Valid;8086;;MOV;MOV;NA;Move imm8 to r/m8.;;
MOV;imm16;m16/r16;;;imm16;ModRM:r/m (w);;;;REX.W0;C7;/0;;iw;Valid;Valid;8086;;MOV;MOV;NA;Move imm16 to r/m16.;;
MOV;imm32;m64/r64;;;imm32;ModRM:r/m (w);;;;REX.W;C7;/0;;id;Valid;N.E.;8086;;MOV;MOV;NA;Move imm32 sign extended to 64-bits to r/m64.;;
MOV;imm32;m32/r32;;;imm32;ModRM:r/m (w);;;;REX.W0;C7;/0;;id;Valid;Valid;8086;;MOV;MOV;NA;Move imm32 to r/m32.;;
MOVAPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 28;/r;;;Valid;Valid;SSE2;;MOVAPD;MOV;NA;Move packed double-precision floating-point values from xmm2/m128 to xmm1.;;
MOVAPD;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 29;/r;;;Valid;Valid;SSE2;;MOVAPD;MOV;NA;Move packed double-precision floating-point values from xmm1 to xmm2/m128.;;
MOVAPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 28;/r;;;Valid;Valid;SSE;;MOVAPS;MOV;NA;Move packed single-precision floating-point values from xmm2/m128 to xmm1.;;
MOVAPS;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 29;/r;;;Valid;Valid;SSE;;MOVAPS;MOV;NA;Move packed single-precision floating-point values from xmm1 to xmm2/m128.;;
MOVBE;m16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F 38 F0;/r;;;Valid;Valid;8086;;MOVBE;MOV;NA;Reverse byte order in m16 and move to r16.;;
MOVBE;m32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F 38 F0;/r;;;Valid;Valid;8086;;MOVBE;MOV;NA;Reverse byte order in m32 and move to r32.;;
MOVBE;m64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;;0F 38 F0;/r;;;Valid;N.E;8086;;MOVBE;MOV;NA;Reverse byte order in m64 and move to r64.;;
MOVBE;r16;m16;;;ModRM:reg (r);ModRM:r/m (w);;;;;0F 38 F1;/r;;;Valid;Valid;8086;;MOVBE;MOV;NA;Reverse byte order in r16 and move to m16.;;
MOVBE;r32;m32;;;ModRM:reg (r);ModRM:r/m (w);;;;;0F 38 F1;/r;;;Valid;Valid;8086;;MOVBE;MOV;NA;Reverse byte order in r32 and move to m32.;;
MOVBE;r64;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;;0F 38 F1;/r;;;Valid;N.E;8086;;MOVBE;MOV;NA;Reverse byte order in r64 and move to m64.;;
MOVD;m32/r32;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 6E;/r;;;Valid;Valid;SSE2;;MOVD;MOV;NA;Move doubleword from r/m32 to mm.;;
MOVD;m32/r32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 6E;/r;;;Valid;Valid;SSE2;;MOVD;MOV;NA;Move doubleword from r/m32 to xmm.;;
MOVD;mm;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 7E;/r;;;Valid;Valid;SSE2;;MOVD;MOV;NA;Move doubleword from mm to r/m32.;;
MOVD;xmm;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 7E;/r;;;Valid;Valid;SSE2;;MOVD;MOV;NA;Move doubleword from xmm register to r/m32.;;
MOVDDUP;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 12;/r;;;Valid;Valid;SSE3;;MOVDDUP;MOV;NA;Move one double-precision floating- point value from the lower 64-bit operand in xmm2/m64 to xmm1 and duplicate.;;
MOVDQ2Q;xmm;mm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F D6;/r;;;Valid;Valid;8086;;MOVDQ2Q;MOV;NA;Move low quadword from xmm to mmx register.;;
MOVDQA;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 6F;/r;;;Valid;Valid;SSE2;;MOVDQA;MOV;NA;Move aligned double quadword from xmm2/m128 to xmm1.;;
MOVDQA;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 7F;/r;;;Valid;Valid;SSE2;;MOVDQA;MOV;NA;Move aligned double quadword from xmm1 to xmm2/m128.;;
MOVDQU;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 6F;/r;;;Valid;Valid;SSE2;;MOVDQU;MOV;NA;Move unaligned double quadword from xmm2/m128 to xmm1.;;
MOVDQU;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;F3;REX.W0;0F 7F;/r;;;Valid;Valid;SSE2;;MOVDQU;MOV;NA;Move unaligned double quadword from xmm1 to xmm2/m128.;;
MOVHLPS;xmm;xmm;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 12;/r;;;Valid;Valid;SSE3;;MOVHLPS;MOV;NA;Move two packed single- precision floating-point values from high quadword of xmm2 to low quadword of xmm1.;;
MOVHPD;m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 16;/r;;;Valid;Valid;SSE2;;MOVHPD;MOV;NA;Move double-precision floating-point value from m64 to high quadword of xmm.;;
MOVHPD;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 17;/r;;;Valid;Valid;SSE2;;MOVHPD;MOV;NA;Move double-precision floating-point value from high quadword of xmm to m64.;;
MOVHPS;m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 16;/r;;;Valid;Valid;SSE;;MOVHPS;MOV;NA;Move two packed single-precision floating-point values from m64 to high quadword of xmm.;;
MOVHPS;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 17;/r;;;Valid;Valid;SSE;;MOVHPS;MOV;NA;Move two packed single-precision floating-point values from high quadword of xmm to m64.;;
MOVLHPS;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 16;/r;;;Valid;Valid;SSE;;MOVLHPS;MOV;NA;Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1.;;
MOVLPD;m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 12;/r;;;Valid;Valid;SSE2;;MOVLPD;MOV;NA;Move double-precision floating-point value from m64 to low quadword of xmm register.;;
MOVLPD;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 13;/r;;;Valid;Valid;SSE2;;MOVLPD;MOV;NA;Move double-precision floating-point nvalue from low quadword of xmm register to m64.;;
MOVLPS;m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 12;/r;;;Valid;Valid;SSE;;MOVLPS;MOV;NA;Move two packed single-precision floating-point values from m64 to low quadword of xmm.;;
MOVLPS;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 13;/r;;;Valid;Valid;SSE;;MOVLPS;MOV;NA;Move two packed single-precision floating-point values from low quadword of xmm to m64.;;
MOVMSKPD;xmm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 50;/r;;;Valid;Valid;SSE2;;MOVMSKPD;MOV;NA;Extract 2-bit sign mask from xmm and store in r32.;;
MOVMSKPD;xmm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W;0F 50;/r;;;Valid;N.E.;SSE2;;MOVMSKPD;MOV;NA;Extract 2-bit sign mask from xmm and store in r64. Zero extend 32-bit results to 64-bits.;;
MOVMSKPS;xmm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 50;/r;;;Valid;Valid;SSE;;MOVMSKPS;MOV;NA;Extract 4-bit sign mask from xmm and store in r32.;;
MOVMSKPS;xmm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F 50;/r;;;Valid;N.E.;SSE;;MOVMSKPS;MOV;NA;Extract 4-bit sign mask from xmm and store in r64. Zero extend 32-bit results to 64-bits.;;
MOVNTDQ;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F E7;/r;;;Valid;Valid;SSE2;;MOVNTDQ;MOV;NA;Move double quadword from xmm to m128 using non-temporal hint.;;
MOVNTDQA;m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 2A;/r;;;Valid;Valid;SSE4_1;;MOVNTDQA;MOV;NA;Move double quadword from m128 to xmm using non-temporal hint if WC memory type.;;
MOVNTI;r64;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;0F C3;/r;;;Valid;N.E.;8086;;MOVNTI;MOV;NA;Move quadword from r64 to m64 using non-temporal hint.;;
MOVNTI;r32;m32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F C3;/r;;;Valid;Valid;8086;;MOVNTI;MOV;NA;Move doubleword from r32 to m32 using non-temporal hint.;;
MOVNTPD;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 2B;/r;;;Valid;Valid;SSE2;;MOVNTPD;MOV;NA;Move packed double-precision floating-point values from xmm to m128 using non-temporal hint.;;
MOVNTPS;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 2B;/r;;;Valid;Valid;SSE;;MOVNTPS;MOV;NA;Move packed single-precision floating- point values from xmm to m128 using non-temporal hint.;;
MOVNTQ;mm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F E7;/r;;;Valid;Valid;8086;;MOVNTQ;MOV;NA;Move quadword from mm to m64 using non-temporal hint.;;
MOVQ;m64/r64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W;0F 6E;/r;;;Valid;N.E.;SSE2;;MOVQ;MOV;NA;Move quadword from r/m64 to xmm.;;
MOVQ;m64/r64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F 6E;/r;;;Valid;N.E.;SSE2;;MOVQ;MOV;NA;Move quadword from r/m64 to mm.;;
MOVQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 6F;/r;;;Valid;Valid;8086;;MOVQ;MOV;NA;Move quadword from mm/m64 to mm.;;
MOVQ;xmm;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W;0F 7E;/r;;;Valid;N.E.;SSE2;;MOVQ;MOV;NA;Move quadword from xmm register to r/m64.;;
MOVQ;mm;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;0F 7E;/r;;;Valid;N.E.;SSE2;;MOVQ;MOV;NA;Move quadword from mm to r/m64.;;
MOVQ;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 7E;/r;;;Valid;Valid;SSE2;;MOVQ;MOV;NA;Move quadword from xmm2/mem64 to xmm1.;;
MOVQ;mm;mm/m64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 7F;/r;;;Valid;Valid;8086;;MOVQ;MOV;NA;Move quadword from mm to mm/m64.;;
MOVQ;xmm;xmm/m64;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F D6;/r;;;Valid;Valid;8086;;MOVQ;MOV;NA;Move quadword from xmm1 to xmm2/mem64.;;
MOVQ2DQ;mm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F D6;/r;;;Valid;Valid;8086;;MOVQ2DQ;MOV;NA;Move quadword from mmx to low quadword of xmm.;;
MOVS;m8=DS:(E)SI;m8=ES:(E)DI;;;;;;;;REX.W0;A4;;;;Valid;Valid;8086;;MOVS;MOV;NA;For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.;;
MOVS;m16=DS:(E)SI;m16=ES:(E)DI;;;;;;;;REX.W0;A5;;;;Valid;Valid;8086;;MOVS;MOV;NA;For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.;;
MOVS;m64=DS:(E)SI;m64=ES:(E)DI;;;;;;;;REX.W;A5;;;;Valid;N.E.;8086;;MOVS;MOV;NA;Move qword from address (R|E)SI to (R|E)DI.;;
MOVS;m32=DS:(E)SI;m32=ES:(E)DI;;;;;;;;REX.W0;A5;;;;Valid;Valid;8086;;MOVS;MOV;NA;For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.;;
MOVSB;;;;;;;;;;;A4;;;;Valid;Valid;8086;;MOVSB;MOV;NA;For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI.;;
MOVSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 10;/r;;;Valid;Valid;SSE2;;MOVSD;MOV;NA;Move scalar double-precision floating-point value from xmm2/m64 to xmm1 register.;;
MOVSD;xmm;xmm/m64;;;ModRM:reg (r);ModRM:r/m (w);;;F2;REX.W0;0F 11;/r;;;Valid;Valid;SSE2;;MOVSD;MOV;NA;Move scalar double-precision floating-point value from xmm1 register to xmm2/m64.;;
MOVSD;;;;;;;;;;;A5;;;;Valid;Valid;8086;;MOVSL;MOV;NA;For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI.;;
MOVSHDUP;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 16;/r;;;Valid;Valid;SSE3;;MOVSHDUP;MOV;NA;Move two single-precision floating-point values from the higher 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the lower 32-bits of each qword.;;
MOVSLDUP;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 12;/r;;;Valid;Valid;SSE3;;MOVSLDUP;MOV;NA;Move two single-precision floating- point values from the lower 32-bit operand of each qword in xmm2/m128 to xmm1 and duplicate each 32-bit operand to the higher 32-bits of each qword.;;
MOVSQ;;;;;;;;;;REX.W;A5;;;;Valid;N.E.;8086;;MOVSQ;MOV;NA;Move qword from address (R|E)SI to (R|E)DI.;;
MOVSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 10;/r;;;Valid;Valid;SSE;;MOVSS;MOV;NA;Move scalar single-precision floating-point value from xmm2/m32 to xmm1 register.;;
MOVSS;xmm;xmm/m32;;;ModRM:reg (r);ModRM:r/m (w);;;F3;REX.W0;0F 11;/r;;;Valid;Valid;SSE;;MOVSS;MOV;NA;Move scalar single-precision floating-point value from xmm1 register to xmm2/m32.;;
MOVSW;;;;;;;;;;;A5;;;;Valid;Valid;8086;Legacy66;MOVSW;MOV;NA;For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI.;;
MOVSX;m8/r8;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BE;/r;;;Valid;Valid;8086;;MOVSX;MOV;NA;Move byte to word with sign-extension.;;
MOVSX;m8/r8<>[ABCD]H;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F BE;/r;;;Valid;N.E.;8086;;MOVSX;MOV;NA;Move byte to quadword with sign-extension.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOVSX;m8/r8;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BE;/r;;;Valid;Valid;8086;;MOVSX;MOV;NA;Move byte to doubleword with sign-extension.;;
MOVSX;m16/r16;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F BF;/r;;;Valid;N.E.;8086;;MOVSX;MOV;NA;Move word to quadword with sign-extension.;;
MOVSX;m16/r16;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F BF;/r;;;Valid;Valid;8086;;MOVSX;MOV;NA;Move word to doubleword, with sign-extension.;;
MOVSXD;m32/r32;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;63;/r;;;Valid;N.E.;8086;;MOVSXD;MOV;NA;Move doubleword to quadword with sign- extension.;** The use of MOVSXD without REX.W in 64-bit mode is discouraged, Regular MOV should be used instead of using MOVSXD without REX.W.;
MOVUPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 10;/r;;;Valid;Valid;SSE2;;MOVUPD;MOV;NA;Move packed double-precision floating-point values from xmm2/m128 to xmm1.;;
MOVUPD;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;66;REX.W0;0F 11;/r;;;Valid;Valid;SSE2;;MOVUPD;MOV;NA;Move packed double-precision floating-point values from xmm1 to xmm2/m128.;;
MOVUPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 10;/r;;;Valid;Valid;SSE;;MOVUPS;MOV;NA;Move packed single-precision floating-point values from xmm2/m128 to xmm1.;;
MOVUPS;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 11;/r;;;Valid;Valid;SSE;;MOVUPS;MOV;NA;Move packed single-precision floating-point values from xmm1 to xmm2/m128.;;
MOVZX;m8/r8;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F B6;/r;;;Valid;Valid;8086;;MOVZX;MOV;NA;Move byte to doubleword, zero-extension.;;
MOVZX;m8/r8<>[ABCD]H;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F B6;/r;;;Valid;N.E.;8086;;MOVZX;MOV;NA;Move byte to quadword, zero-extension.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MOVZX;m8/r8;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F B6;/r;;;Valid;Valid;8086;;MOVZX;MOV;NA;Move byte to word with zero-extension.;;
MOVZX;m16/r16;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F B7;/r;;;Valid;Valid;8086;;MOVZX;MOV;NA;Move word to doubleword, zero-extension.;;
MOVZX;m16/r16;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F B7;/r;;;Valid;N.E.;8086;;MOVZX;MOV;NA;Move doubleword to quadword, zero-extension.;;
MPSADBW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 3A 42;/r;;ib;Valid;Valid;SSE4_1;;MPSADBW;UNDEF;NA;Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8.;;
MUL;m8/r8;;;;ModRM:r/m (r);;;;;;F6;/4;;;Valid;Valid;8086;;MUL;MUL;NA;Unsigned multiply (AX ← AL ∗ r/m8).;;
MUL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;F6;/4;;;Valid;N.E.;8086;;MUL;MUL;NA;Unsigned multiply (AX ← AL ∗ r/m8).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
MUL;m64/r64;;;;ModRM:r/m (r);;;;;REX.W;F7;/4;;;Valid;N.E.;8086;;MUL;MUL;NA;Unsigned multiply (RDX:RAX ← RAX ∗ r/m64.;;
MUL;m32/r32;;;;ModRM:r/m (r);;;;;REX.W0;F7;/4;;;Valid;Valid;8086;;MUL;MUL;NA;Unsigned multiply (EDX:EAX ← EAX ∗ r/m32).;;
MUL;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;F7;/4;;;Valid;Valid;8086;;MUL;MUL;NA;Unsigned multiply (DX:AX ← AX ∗ r/m16).;;
MULPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 59;/r;;;Valid;Valid;SSE2;;MULPD;MUL;NA;Multiply packed double-precision floating-point values in xmm2/m128 by xmm1.;;
MULPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 59;/r;;;Valid;Valid;SSE;;MULPS;MUL;NA;Multiply packed single-precision floating-point values in xmm2/mem by xmm1.;;
MULSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 59;/r;;;Valid;Valid;SSE2;;MULSD;MUL;NA;Multiply the low double-precision floating-point value in xmm2/mem64 by low double-precision floating-point value in xmm1.;;
MULSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 59;/r;;;Valid;Valid;SSE;;MULSS;MUL;NA;Multiply the low single-precision floating-point value in xmm2/mem by the low single-precision floating-point value in xmm1.;;
MWAIT;;;;;;;;;;;0F 01 C9;;;;Valid;Valid;8086;;MWAIT;MWAIT;NA;A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events.;;
NEG;m8/r8;;;;ModRM:r/m (r, w);;;;;;F6;/3;;;Valid;Valid;8086;;NEG;NEG;NA;Two's complement negate r/m8.;;
NEG;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;;REX;F6;/3;;;Valid;N.E.;8086;;NEG;NEG;NA;Two's complement negate r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
NEG;m16/r16;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/3;;;Valid;Valid;8086;;NEG;NEG;NA;Two's complement negate r/m16.;;
NEG;m32/r32;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/3;;;Valid;Valid;8086;;NEG;NEG;NA;Two's complement negate r/m32.;;
NEG;m64/r64;;;;ModRM:r/m (r, w);;;;;REX.W;F7;/3;;;Valid;N.E.;8086;;NEG;NEG;NA;Two's complement negate r/m64.;;
NOP;m32/r32;;;;ModRM:r/m (r);;;;;;0F 1F;/0;;;Valid;Valid;8086;;NOP;NOP;NA;Multi-byte no-operation instruction.;;
NOP;m16/r16;;;;ModRM:r/m (r);;;;;;0F 1F;/0;;;Valid;Valid;8086;;NOP;NOP;NA;Multi-byte no-operation instruction.;;
NOP;;;;;;;;;;;90;;;;Valid;Valid;8086;;NOP;NOP;NA;One byte no-operation instruction.;;
NOT;m8/r8;;;;ModRM:r/m (r, w);;;;;;F6;/2;;;Valid;Valid;8086;;NOT;NOP;NA;Reverse each bit of r/m8.;;
NOT;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;;REX;F6;/2;;;Valid;N.E.;8086;;NOT;NOP;NA;Reverse each bit of r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
NOT;m64/r64;;;;ModRM:r/m (r, w);;;;;REX.W;F7;/2;;;Valid;N.E.;8086;;NOT;NOP;NA;Reverse each bit of r/m64.;;
NOT;m16/r16;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/2;;;Valid;Valid;8086;;NOT;NOP;NA;Reverse each bit of r/m16.;;
NOT;m32/r32;;;;ModRM:r/m (r, w);;;;;REX.W0;F7;/2;;;Valid;Valid;8086;;NOT;NOP;NA;Reverse each bit of r/m32.;;
OR;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;08;/r;;;Valid;N.E.;8086;;OR;OR;NA;r/m8 OR r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
OR;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;08;/r;;;Valid;Valid;8086;;OR;OR;NA;r/m8 OR r8.;;
OR;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;09;/r;;;Valid;N.E.;8086;;OR;OR;NA;r/m64 OR r64.;;
OR;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;09;/r;;;Valid;Valid;8086;;OR;OR;NA;r/m32 OR r32.;;
OR;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;09;/r;;;Valid;Valid;8086;;OR;OR;NA;r/m16 OR r16.;;
OR;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;0A;/r;;;Valid;N.E.;8086;;OR;OR;NA;r8 OR r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
OR;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;0A;/r;;;Valid;Valid;8086;;OR;OR;NA;r8 OR r/m8.;;
OR;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0B;/r;;;Valid;Valid;8086;;OR;OR;NA;r16 OR r/m16.;;
OR;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;0B;/r;;;Valid;N.E.;8086;;OR;OR;NA;r64 OR r/m64.;;
OR;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0B;/r;;;Valid;Valid;8086;;OR;OR;NA;r32 OR r/m32.;;
OR;imm8;r8=AL;;;imm8;;;;;;0C;;;ib;Valid;Valid;8086;;OR;OR;NA;AL OR imm8.;;
OR;imm16;r16=AX;;;imm16;;;;;REX.W0;0D;;;iw;Valid;Valid;8086;Legacy66;OR;OR;NA;AX OR imm16.;;
OR;imm32;r64=RAX;;;imm32;;;;;REX.W;0D;;;id;Valid;N.E.;8086;;OR;OR;NA;RAX OR imm32 (sign-extended).;;
OR;imm32;r32=EAX;;;imm32;;;;;REX.W0;0D;;;id;Valid;Valid;8086;;OR;OR;NA;EAX OR imm32.;;
OR;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/1;;ib;Valid;Valid;8086;;OR;OR;NA;r/m8 OR imm8.;;
OR;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/1;;ib;Valid;N.E.;8086;;OR;OR;NA;r/m8 OR imm8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
OR;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/1;;iw;Valid;Valid;8086;;OR;OR;NA;r/m16 OR imm16.;;
OR;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/1;;id;Valid;N.E.;8086;;OR;OR;NA;r/m64 OR imm32 (sign-extended).;;
OR;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/1;;id;Valid;Valid;8086;;OR;OR;NA;r/m32 OR imm32.;;
OR;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/1;;ib;Valid;N.E.;8086;;OR;OR;NA;r/m64 OR imm8 (sign-extended).;;
OR;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/1;;ib;Valid;Valid;8086;;OR;OR;NA;r/m16 OR imm8 (sign-extended).;;
OR;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/1;;ib;Valid;Valid;8086;;OR;OR;NA;r/m32 OR imm8 (sign-extended).;;
ORPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 56;/r;;;Valid;Valid;SSE2;;ORPD;OR;NA;Bitwise OR of xmm2/m128 and xmm1.;;
ORPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 56;/r;;;Valid;Valid;SSE;;ORPS;OR;NA;Bitwise OR of xmm2/m128 and xmm1.;;
OUT;r8=AL;imm8;;;;imm8;;;;;E6;;;ib;Valid;Valid;8086;;OUT;OUT;NA;Output byte in AL to I/O port address imm8.;;
OUT;r32=EAX;imm8;;;;imm8;;;;;E7;;;ib;Valid;Valid;8086;Legacy-3;OUT;OUT;NA;Output doubleword in EAX to I/O port address imm8.;;
OUT;r16=AX;imm8;;;;imm8;;;;;E7;;;ib;Valid;Valid;8086;Legacy66;OUT;OUT;NA;Output word in AX to I/O port address imm8.;;
OUT;r8=AL;r16=DX;;;;;;;;;EE;;;;Valid;Valid;8086;;OUT;OUT;NA;Output byte in AL to I/O port address in DX.;;
OUT;r16=AX;r16=DX;;;;;;;;;EF;;;;Valid;Valid;8086;Legacy66;OUT;OUT;NA;Output word in AX to I/O port address in DX.;;
OUT;r32=EAX;r16=DX;;;;;;;;;EF;;;;Valid;Valid;8086;Legacy-3;OUT;OUT;NA;Output doubleword in EAX to I/O port address in DX.;;
OUTS;m8=DS:(E)SI;r16=DX;;;;;;;;;6E;;;;Valid;Valid;8086;;OUTS;OUTS;NA;Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
OUTS;m32=DS:(E)SI;r16=DX;;;;;;;;;6F;;;;Valid;Valid;8086;;OUTS;OUTS;NA;Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
OUTS;m16=DS:(E)SI;r16=DX;;;;;;;;;6F;;;;Valid;Valid;8086;;OUTS;OUTS;NA;Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
OUTSB;;;;;;;;;;;6E;;;;Valid;Valid;8086;;OUTSB;OUTS;NA;Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
OUTSD;;;;;;;;;;;6F;;;;Valid;Valid;8086;;OUTSL;OUTS;NA;Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
OUTSW;;;;;;;;;;;6F;;;;Valid;Valid;8086;Legacy66;OUTSW;OUTS;NA;Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX**.;In 64-bit mode, only 64-bit (RSI) and 32-bit (ESI) address sizes are supported. In non-64-bit mode, only 32-bit (ESI) and 16-bit (SI) address sizes are supported.;
PABSB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 1C;/r;;;Valid;Valid;SSSE3;;PABSB;PABS;NA;Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1.;;
PABSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 1C;/r;;;Valid;Valid;SSSE3;;PABSB;PABS;NA;Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.;;
PABSD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 1E;/r;;;Valid;Valid;SSSE3;;PABSD;PABS;NA;Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1.;;
PABSD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 1E;/r;;;Valid;Valid;SSSE3;;PABSD;PABS;NA;Compute the absolute value of 32- bit integers in xmm2/m128 andstore UNSIGNED result in xmm1.;;
PABSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 1D;/r;;;Valid;Valid;SSSE3;;PABSW;PABS;NA;Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1.;;
PABSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 1D;/r;;;Valid;Valid;SSSE3;;PABSW;PABS;NA;Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1.;;
PACKSSDW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 6B;/r;;;Valid;Valid;MMX;;PACKSSDW;PACK;NA;Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation.;;
PACKSSDW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 6B;/r;;;Valid;Valid;SSE2;;PACKSSDW;PACK;NA;Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation.;;
PACKSSWB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 63;/r;;;Valid;Valid;MMX;;PACKSSWB;PACK;NA;Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation.;;
PACKSSWB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 63;/r;;;Valid;Valid;SSE2;;PACKSSWB;PACK;NA;Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation.;;
PACKUSDW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 2B;/r;;;Valid;Valid;SSE4_1;;PACKUSDW;PACK;NA;Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.;;
PACKUSWB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 67;/r;;;Valid;Valid;MMX;;PACKUSWB;PACK;NA;Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation.;;
PACKUSWB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 67;/r;;;Valid;Valid;SSE2;;PACKUSWB;PACK;NA;Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.;;
PADDB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F FC;/r;;;Valid;Valid;SSE2;;PADDB;PADD;NA;Add packed byte integers from xmm2/m128 and xmm1.;;
PADDB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F FC;/r;;;Valid;Valid;MMX;;PADDB;PADD;NA;Add packed byte integers from mm/m64 and mm.;;
PADDD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F FE;/r;;;Valid;Valid;SSE2;;PADDD;PADD;NA;Add packed doubleword integers from xmm2/m128 and xmm1.;;
PADDD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F FE;/r;;;Valid;Valid;MMX;;PADDD;PADD;NA;Add packed doubleword integers from mm/m64 and mm.;;
PADDQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D4;/r;;;Valid;Valid;SSE2;;PADDQ;PADD;NA;Add quadword integer mm2/m64 to mm1.;;
PADDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D4;/r;;;Valid;Valid;SSE2;;PADDQ;PADD;NA;Add packed quadword integers xmm2/m128 to xmm1.;;
PADDSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F EC;/r;;;Valid;Valid;SSE2;;PADDSB;PADD;NA;Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results.;;
PADDSB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F EC;/r;;;Valid;Valid;MMX;;PADDSB;PADD;NA;Add packed signed byte integers from mm/m64 and mm and saturate the results.;;
PADDSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F ED;/r;;;Valid;Valid;SSE2;;PADDSW;PADD;NA;Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results.;;
PADDSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F ED;/r;;;Valid;Valid;MMX;;PADDSW;PADD;NA;Add packed signed word integers from mm/m64 and mm and saturate the results.;;
PADDUSB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DC;/r;;;Valid;Valid;MMX;;PADDUSB;PADD;NA;Add packed unsigned byte integers from mm/m64 and mm and saturate the results.;;
PADDUSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DC;/r;;;Valid;Valid;SSE2;;PADDUSB;PADD;NA;Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results.;;
PADDUSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DD;/r;;;Valid;Valid;MMX;;PADDUSW;PADD;NA;Add packed unsigned word integers from mm/m64 and mm and saturate the results.;;
PADDUSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DD;/r;;;Valid;Valid;SSE2;;PADDUSW;PADD;NA;Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results.;;
PADDW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F FD;/r;;;Valid;Valid;MMX;;PADDW;PADD;NA;Add packed word integers from mm/m64 and mm.;;
PADDW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F FD;/r;;;Valid;Valid;SSE2;;PADDW;PADD;NA;Add packed word integers from xmm2/m128 and xmm1.;;
PALIGNR;imm8;mm/m64;mm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;0F 3A 0F;/r;;ib;Valid;Valid;SSSE3;;PALIGNR;PALIGNR;NA;Concatenate destination andsource operands, extract byte-aligned result shifted to the right by constant into mm1.;;
PALIGNR;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;REX.W0;0F 3A 0F;/r;;ib;Valid;Valid;SSSE3;;PALIGNR;PALIGNR;NA;Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant into xmm1;;
PAND;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DB;/r;;;Valid;Valid;SSE2;;PAND;PAND;NA;Bitwise AND of xmm2/m128 and xmm1.;;
PAND;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DB;/r;;;Valid;Valid;MMX;;PAND;PAND;NA;Bitwise AND mm/m64 and mm.;;
PANDN;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DF;/r;;;Valid;Valid;MMX;;PANDN;PAND;NA;Bitwise AND NOT of mm/m64 and mm.;;
PANDN;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DF;/r;;;Valid;Valid;SSE2;;PANDN;PAND;NA;Bitwise AND NOT of xmm2/m128 and xmm1.;;
PAUSE;;;;;;;;;F3;;90;;;;Valid;Valid;8086;;PAUSE;PAUSE;NA;Gives hint to processor that improves performance of spin-wait loops.;;
PAVGB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E0;/r;;;Valid;Valid;SSE;;PAVGB;PAVG;NA;Average packed unsigned byte integers from mm2/m64 and mm1 with rounding.;;
PAVGB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E0;/r;;;Valid;Valid;SSE2;;PAVGB;PAVG;NA;Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding.;;
PAVGUSB;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;BF;Valid;Valid;3DNow;;PAVGUSB;PAVG;NA;Averages packed 8-bit unsigned integer values in an MMX register and another MMX register or 64-bit memory location and writes the result in the destination MMX register.;;
PAVGW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E3;/r;;;Valid;Valid;SSE;;PAVGW;PAVG;NA;Average packed unsigned word integers from mm2/m64 and mm1 with rounding.;;
PAVGW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E3;/r;;;Valid;Valid;SSE2;;PAVGW;PAVG;NA;Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding.;;
PBLENDVB;xmm=XMM0;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 38 10;/r;;;Valid;Valid;SSE4_1;;PBLENDVB;UNDEF;NA;Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1.;;
PBLENDW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 3A 0E;/r;;ib;Valid;Valid;SSE4_1;;PBLENDW;UNDEF;NA;Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.;;
PCLMULQDQ;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;;0F 3A 44 ;/r;;ib;Valid;Valid;CLMUL;;PCLMULQDQ;UNDEF;NA;Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used.;;
PCMPEQB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 74;/r;;;Valid;Valid;MMX;;PCMPEQB;CMP;NA;Compare packed bytes in mm/m64 and mm for equality.;;
PCMPEQB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 74;/r;;;Valid;Valid;SSE2;;PCMPEQB;CMP;NA;Compare packed bytes in xmm2/m128 and xmm1 for equality.;;
PCMPEQD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 76;/r;;;Valid;Valid;MMX;;PCMPEQD;CMP;NA;Compare packed doublewords in mm/m64 and mm for equality.;;
PCMPEQD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 76;/r;;;Valid;Valid;SSE2;;PCMPEQD;CMP;NA;Compare packed doublewords in xmm2/m128 and xmm1 for equality.;;
PCMPEQQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 29;/r;;;Valid;Valid;SSE4_1;;PCMPEQQ;CMP;NA;Compare packed qwords in xmm2/m128 and xmm1 for equality.;;
PCMPEQW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 75;/r;;;Valid;Valid;SSE2;;PCMPEQW;CMP;NA;Compare packed words in xmm2/m128 and xmm1 for equality.;;
PCMPEQW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 75;/r;;;Valid;Valid;MMX;;PCMPEQW;CMP;NA;Compare packed words in mm/m64 and mm for equality.;;
PCMPESTRI;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;66;;0F 3A 61;/r;;ib;Valid;Valid;SSE4_2;;PCMPESTRI;CMP;NA;Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.;;
PCMPESTRM;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;66;;0F 3A 60;/r;;ib;Valid;Valid;SSE4_2;;PCMPESTRM;CMP;NA;Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0;;
PCMPGTB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 64;/r;;;Valid;Valid;SSE2;;PCMPGTB;CMP;NA;Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than.;;
PCMPGTB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 64;/r;;;Valid;Valid;MMX;;PCMPGTB;CMP;NA;Compare packed signed byte integers in mm and mm/m64 for greater than.;;
PCMPGTD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 66;/r;;;Valid;Valid;SSE2;;PCMPGTD;CMP;NA;Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than.;;
PCMPGTD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 66;/r;;;Valid;Valid;MMX;;PCMPGTD;CMP;NA;Compare packed signed doubleword integers in mm and mm/m64 for greater than.;;
PCMPGTQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 37;/r;;;Valid;Valid;SSE4_2;;PCMPGTQ;CMP;NA;Compare packed qwords in xmm2/m128 and xmm1 for greater than.;;
PCMPGTW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 65;/r;;;Valid;Valid;SSE2;;PCMPGTW;CMP;NA;Compare packed signed word integers in xmm1 and xmm2/m128 for greater than.;;
PCMPGTW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 65;/r;;;Valid;Valid;MMX;;PCMPGTW;CMP;NA;Compare packed signed word integers in mm and mm/m64 for greater than.;;
PCMPISTRI;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;66;;0F 3A 63;/r;;ib;Valid;Valid;SSE4_2;;PCMPISTRI;CMP;NA;Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.;;
PCMPISTRM;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;66;;0F 3A 62;/r;;ib;Valid;Valid;SSE4_2;;PCMPISTRM;CMP;NA;Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0.;;
PEXTRB;imm8;xmm;r32/m8;;imm8;ModRM:reg (r);ModRM:r/m (w);;66;;0F 3A 14;/r;;ib;Valid;Valid;SSE4_1;;PEXTRB;PEXTRW;NA;Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into rreg or m8. The upper bits of r32 or r64 are zeroed.;;
PEXTRD;imm8;xmm;m32/r32;;imm8;ModRM:reg (r);ModRM:r/m (w);;66;;0F 3A 16;/r;;ib;Valid;Valid;SSE4_1;;PEXTRD;PEXTRW;NA;Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32.;;
PEXTRQ;imm8;xmm;m64/r64;;imm8;ModRM:reg (r);ModRM:r/m (w);;66;REX.W;0F 3A 16;/r;;ib;Valid;N.E.;SSE4_1;;PEXTRQ;PEXTRW;NA;Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64.;;
PEXTRW;imm8;mm;r32;;imm8;ModRM:r/m (r);ModRM:reg (w);;;REX.W0;0F C5;/r;;ib;Valid;Valid;SSE;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from mm and move it to r32, bits 15-0. Zero-extend the result.;;
PEXTRW;imm8;xmm;r32;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W0;0F C5;/r;;ib;Valid;Valid;SSE2;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from xmm and move it to r32, bits 15-0. Zero-extend the result.;;
PEXTRW;imm8;mm;r64;;imm8;ModRM:r/m (r);ModRM:reg (w);;;REX.W;0F C5;/r;;ib;Valid;N.E.;SSE;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from mm and move it to r64, bits 15-0. Zero-extend the result.;;
PEXTRW;imm8;xmm;r64;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W;0F C5;/r;;ib;Valid;N.E.;SSE2;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from xmm and move it to r64, bits 15-0. Zero-extend the result.;;
PEXTRW;imm8;xmm;r32;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F C5;/r;;ib;Valid;Valid;SSE4_1;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed.;;
PEXTRW;imm8;xmm;r32/m16;;imm8;ModRM:reg (r);ModRM:r/m (w);;66;;0F 3A 15;/r;;ib;Valid;Valid;SSE4_1;;PEXTRW;PEXTRW;NA;Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64.;;
PF2ID;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;1D;Valid;Valid;3DNow;;PF2ID;PF;NA;Converts packed single-precision floating-point values in an  MMX register or memory location to a doubleword integer value  in the destination MMX register.;;
PF2IW;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;1C;Valid;Valid;3DNow;;PF2IW;PF;NA;Converts packed single-precision floating-point values in an MMX register or memory location to word integer values in the destination MMX register.;;
PFACC;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;AE;Valid;Valid;3DNow;;PFACC;PF;NA;Accumulates packed single-precision floating-point values in an MMX register or 64-bit memory location and another MMX register and writes each result in the destination MMX register.;;
PFADD;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;9E;Valid;Valid;3DNow;;PFADD;PF;NA;Adds two packed single-precision floating-point values in an MMX register or 64-bit memory location and another MMX register and writes each result in the destination MMX register.;;
PFCMPEQ;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;B0;Valid;Valid;3DNow;;PFCMPEQ;PF;NA;Compares two pairs of packed single-precision floating- point values in an MMX register and an MMX register or 64-bit memory location.;;
PFCMPGE;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;90;Valid;Valid;3DNow;;PFCMPGE;PF;NA;Compares two pairs of packed single-precision floating-point values in an MMX register and an MMX register or 64-bit memory location.;;
PFCMPGT;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;A0;Valid;Valid;3DNow;;PFCMPGT;PF;NA;Compares two pairs of packed single-precision floating-point values in an MMX register and an MMX register or 64-bit memory location.;;
PFMAX;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;A4;Valid;Valid;3DNow;;PFMAX;PF;NA;Compares two pairs of packed single-precision values in an MMX register and another MMX register or 64-bit memory location and writes the maximum value of each comparison in the destination MMX register.;;
PFMIN;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;94;Valid;Valid;3DNow;;PFMIN;PF;NA;Compares two pairs of packed single-precision values in an  MMX register and another MMX register or 64-bit memory  location and writes the minimum value of each comparison in  the destination MMX register.;;
PFMUL;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;B4;Valid;Valid;3DNow;;PFMUL;PF;NA;Multiplies packed single-precision floating-point values in an MMX register and another MMX register or 64-bit memory location and writes the result in the destination MMX register.;;
PFNACC;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;8A;Valid;Valid;3DNow;;PFNACC;PF;NA;Subtracts the packed single-precision floating-point values in an MMX register or 64-bit memory location and another MMX register and writes each value in the destination MMX register.;;
PFPNACC;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;8E;Valid;Valid;3DNow;;PFPNACC;PF;NA;Subtracts the packed single-precision floating-point values in an MMX register, adds the packed single-precision floating-point values in another MMX register or 64-bit memory location, and writes each value in the destination MMX register.;;
PFRCP;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;96;Valid;Valid;3DNow;;PFRCP;PF;NA;Computes approximate reciprocal of single-precision floating-point value in an MMX register or 64-bit memory location and writes the result in both doublewords of the destination MMX register.;;
PFRCPIT1;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;A6;Valid;Valid;3DNow;;PFRCPIT1;PF;NA;Refine approximate reciprocal of result from previous PFRCP instruction.;;
PFRCPIT2;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;B6;Valid;Valid;3DNow;;PFRCPIT2;PF;NA;Refines approximate reciprocal result from previous PFRCP and PFRCPIT1 instructions or from previous PFRSQRT and PFRSQIT1 instructions.;;
PFRSQIT1;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;A7;Valid;Valid;3DNow;;PFRSQIT1;PF;NA;Refines reciprocal square root approximation of previous PFRSQRT instruction.;;
PFRSQRT;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;97;Valid;Valid;3DNow;;PFRSQRT;PF;NA;Computes approximate reciprocal square root of a packed single-precision floating-point value.;;
PFSUB;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;9A;Valid;Valid;3DNow;;PFSUB;PF;NA;Subtracts packed single-precision floating-point values in an MMX register or 64-bit memory location from packed single-precision floating-point values in another MMX register and writes the result in the destination MMX                                 register. ;;
PFSUBR;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;AA;Valid;Valid;3DNow;;PFSUBR;PF;NA;Subtracts packed single-precision floating-point values in an MMX register from packed single-precision floating-point values in another MMX register or 64-bit memory location and writes the result in the destination MMX register.;;
PHADDD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 02;/r;;;Valid;Valid;SSSE3;;PHADDD;PHADD;NA;Add 32-bit signed integers horizontally, pack to XMM1.;;
PHADDD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 02;/r;;;Valid;Valid;SSSE3;;PHADDD;PHADD;NA;Add 32-bit signed integers horizontally, pack to MM1.;;
PHADDSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 03;/r;;;Valid;Valid;SSSE3;;PHADDSW;PHADD;NA;Add 16-bit signed integers horizontally, pack saturated integers to MM1.;;
PHADDSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 03;/r;;;Valid;Valid;SSSE3;;PHADDSW;PHADD;NA;Add 16-bit signed integers horizontally, pack saturated integers to XMM1.;;
PHADDW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 01;/r;;;Valid;Valid;SSSE3;;PHADDW;PHADD;NA;Add 16-bit signed integers horizontally, pack to XMM1.;;
PHADDW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 01;/r;;;Valid;Valid;SSSE3;;PHADDW;PHADD;NA;Add 16-bit signed integers horizontally, pack to MM1.;;
PHMINPOSUW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 41;/r;;;Valid;Valid;SSE4_1;;PHMINPOSUW;UNDEF;NA;Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.;;
PHSUBD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 06;/r;;;Valid;Valid;SSSE3;;PHSUBD;PHSUB;NA;Subtract 32-bit signed integers horizontally, pack to MM1.;;
PHSUBD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 06;/r;;;Valid;Valid;SSSE3;;PHSUBD;PHSUB;NA;Subtract 32-bit signed integers horizontally, pack to XMM1.;;
PHSUBSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 07;/r;;;Valid;Valid;SSSE3;;PHSUBSW;PHSUB;NA;Subtract 16-bit signed integer horizontally, pack saturated integers to XMM1;;
PHSUBSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 07;/r;;;Valid;Valid;SSSE3;;PHSUBSW;PHSUB;NA;Subtract 16-bit signed integer horizontally, pack saturated integers to MM1.;;
PHSUBW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 38 05;/r;;;Valid;Valid;SSSE3;;PHSUBW;PHSUB;NA;Subtract 16-bit signed integers horizontally, pack to XMM1.;;
PHSUBW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 38 05;/r;;;Valid;Valid;SSSE3;;PHSUBW;PHSUB;NA;Subtract 16-bit signed integers horizontally, pack to MM1.;;
PI2FD;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;0D;Valid;Valid;3DNow;;PI2FD;PI2F;NA;Converts packed doubleword integers in an MMX register or 64-bit memory location to single-precision floating-point values in the destination MMX register. Inexact results are truncated.;;
PI2FW;mm/m64;mm;;;ModRM:r/m;ModRM:reg;;;;REX.W0;0F 0F;/r;;0C;Valid;Valid;3DNow;;PI2FW;PI2F;NA;Converts packed 16-bit integers in an MMX register or 64-bit memory location to packed single-precision floating-point values in the destination MMX register.;;
PINSRB;imm8;r32/m8;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 20;/r;;ib;Valid;Valid;SSE4_1;;PINSRB;PINSR;NA;Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8. ;;
PINSRD;imm8;m32/r32;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 22;/r;;ib;Valid;Valid;SSE4_1;;PINSRD;PINSR;NA;Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8.;;
PINSRQ;imm8;m64/r64;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W;0F 3A 22;/r;;ib;Valid;N.E.;SSE4_1;;PINSRQ;PINSR;NA;Insert a qword integer value from r/m32 into the xmm1 at the destination element specified by imm8.;;
PINSRW;imm8;r64/m16;mm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;REX.W;0F C4;/r;;ib;Valid;N.E.;SSE;Legacy-3;PINSRW;PINSR;NA;Insert the low word from r64 or from m16 into mm at the word position specified by imm8;;
PINSRW;imm8;r64/m16;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W;0F C4;/r;;ib;Valid;N.E.;SSE2;;PINSRW;PINSR;NA;Move the low word of r64 or from m16 into xmm at the word position specified by imm8.;;
PINSRW;imm8;r32/m16;mm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;REX.W0;0F C4;/r;;ib;Valid;Valid;SSE;Legacy-3;PINSRW;PINSR;NA;Insert the low word from r32 or from m16 into mm at the word position specified by imm8;;
PINSRW;imm8;r32/m16;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W0;0F C4;/r;;ib;Valid;Valid;SSE2;;PINSRW;PINSR;NA;Move the low word of r32 or from m16 into xmm at the word position specified by imm8.;;
PMADDUBSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 04;/r;;;Valid;Valid;SSSE3;;PMADDUBSW;PMADD;NA;Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to XMM1.;;
PMADDUBSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 04;/r;;;Valid;Valid;MMX;;PMADDUBSW;PMADD;NA;Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to MM1.;;
PMADDWD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F5;/r;;;Valid;Valid;SSE;;PMADDWD;PMADD;NA;Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1.;;
PMADDWD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F5;/r;;;Valid;Valid;MMX;;PMADDWD;PMADD;NA;Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm.;;
PMAXSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3C;/r;;;Valid;Valid;SSE4_1;;PMAXSB;PMAX;NA;Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.;;
PMAXSD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3D;/r;;;Valid;Valid;SSE4_1;;PMAXSD;PMAX;NA;Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.;;
PMAXSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F EE;/r;;;Valid;Valid;SSE;;PMAXSW;PMAX;NA;Compare signed word integers in mm2/m64 and mm1 and return maximum values.;;
PMAXSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F EE;/r;;;Valid;Valid;SSE2;;PMAXSW;PMAX;NA;Compare signed word integers in xmm2/m128 and xmm1 and return maximum values.;;
PMAXUB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DE;/r;;;Valid;Valid;SSE2;;PMAXUB;PMAX;NA;Compare unsigned byte integers in xmm2/m128 and xmm1 and returns maximum values.;;
PMAXUB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DE;/r;;;Valid;Valid;SSE;;PMAXUB;PMAX;NA;Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values.;;
PMAXUD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3F;/r;;;Valid;Valid;SSE4_1;;PMAXUD;PMAX;NA;Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.;;
PMAXUW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3E;/r;;;Valid;Valid;SSE4_1;;PMAXUW;PMAX;NA;Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1.;;
PMINSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 38;/r;;;Valid;Valid;SSE4_1;;PMINSB;PMIN;NA;Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.;;
PMINSD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 39;/r;;;Valid;Valid;SSE4_1;;PMINSD;PMIN;NA;Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.;;
PMINSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F EA;/r;;;Valid;Valid;SSE2;;PMINSW;PMIN;NA;Compare signed word integers in xmm2/m128 and xmm1 and return minimum values.;;
PMINSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F EA;/r;;;Valid;Valid;SSE;;PMINSW;PMIN;NA;Compare signed word integers in mm2/m64 and mm1 and return minimum values.;;
PMINUB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F DA;/r;;;Valid;Valid;SSE;;PMINUB;PMIN;NA;Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values.;;
PMINUB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F DA;/r;;;Valid;Valid;SSE2;;PMINUB;PMIN;NA;Compare unsigned byte integers in xmm2/m128 and xmm1 and returns minimum values.;;
PMINUD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3B;/r;;;Valid;Valid;SSE4_1;;PMINUD;PMIN;NA;Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.;;
PMINUW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 3A;/r;;;Valid;Valid;SSE4_1;;PMINUW;PMIN;NA;Compare packed unsigned word integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1.;;
PMOVMSKB;xmm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F D7;/r;;;Valid;Valid;SSE2;;PMOVMSKB;PMOV;NA;Move a byte mask of xmm to r32.;;
PMOVMSKB;mm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;0F D7;/r;;;Valid;N.E.;SSE;;PMOVMSKB;PMOV;NA;Move a byte mask of mm to the lower 32-bits of r64and zero-fill the upper 32-bits.;;
PMOVMSKB;xmm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W;0F D7;/r;;;Valid;N.E.;SSE2;;PMOVMSKB;PMOV;NA;Move a byte mask of xmm to the lower 32-bits of r64 and zero-fill the upper 32-bits.;;
PMOVMSKB;mm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F D7;/r;;;Valid;Valid;SSE;;PMOVMSKB;PMOV;NA;Move a byte mask of mm to r32.;;
PMOVSXBD;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 21;/r;;;Valid;Valid;SSE4_1;;PMOVSXBD;PMOV;NA;Sign extend 4 packed signed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed signed 32-bit integers in xmm1.;;
PMOVSXBQ;xmm/m16;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 22;/r;;;Valid;Valid;SSE4_1;;PMOVSXBQ;PMOV;NA;Sign extend 2 packed signed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed signed 64-bit integers in xmm1.;;
PMOVSXBW;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 20;/r;;;Valid;Valid;SSE4_1;;PMOVSXBW;PMOV;NA;Sign extend 8 packed signed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed signed 16-bit integers in xmm1.;;
PMOVSXDQ;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 25;/r;;;Valid;Valid;SSE4_1;;PMOVSXDQ;PMOV;NA;Sign extend 2 packed signed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed signed 64-bit integers in xmm1.;;
PMOVSXWD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 23;/r;;;Valid;Valid;SSE4_1;;PMOVSXWD;PMOV;NA;Sign extend 4 packed signed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed signed 32-bit integers in xmm1.;;
PMOVSXWQ;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 24;/r;;;Valid;Valid;SSE4_1;;PMOVSXWQ;PMOV;NA;Sign extend 2 packed signed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed signed 64-bit integers in xmm1.;;
PMOVZXBD;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 31;/r;;;Valid;Valid;SSE4_1;;PMOVZXBD;PMOV;NA;Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.;;
PMOVZXBQ;xmm/m16;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 32 ;/r;;;Valid;Valid;SSE4_1;;PMOVZXBQ;PMOV;NA;Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.;;
PMOVZXBW;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 30;/r;;;Valid;Valid;SSE4_1;;PMOVZXBW;PMOV;NA;Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.;;
PMOVZXDQ;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 35;/r;;;Valid;Valid;SSE4_1;;PMOVZXDQ;PMOV;NA;Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.;;
PMOVZXWD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 33;/r;;;Valid;Valid;SSE4_1;;PMOVZXWD;PMOV;NA;Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.;;
PMOVZXWQ;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;;0F 38 34;/r;;;Valid;Valid;SSE4_1;;PMOVZXWQ;PMOV;NA;Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.;;
PMULDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 28;/r;;;Valid;Valid;SSE4_1;;PMULDQ;PMOV;NA;Multiply the packed signed dword integers in xmm1 and xmm2/m128 and store the quadword product in xmm1.;;
PMULHRSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 0B;/r;;;Valid;Valid;SSSE3;;PMULHRSW;PMUL;NA;Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to MM1.;;
PMULHRSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 0B;/r;;;Valid;Valid;SSSE3;;PMULHRSW;PMUL;NA;Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to XMM1.;;
PMULHRW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 0F;/r;;B7;Valid;Valid;3DNow;;PMULHRW;PMUL;NA;Multiply 16-bit signed integer values in an MMX register and another MMX register or 64-bit memory location and write rounded result in the destination MMX register.;;
PMULHUW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E4;/r;;;Valid;Valid;SSE2;;PMULHUW;PMUL;NA;Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.;;
PMULHUW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E4;/r;;;Valid;Valid;SSE;;PMULHUW;PMUL;NA;Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.;;
PMULHW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E5;/r;;;Valid;Valid;SSE2;;PMULHW;PMUL;NA;Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1.;;
PMULHW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E5;/r;;;Valid;Valid;MMX;;PMULHW;PMUL;NA;Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1.;;
PMULLD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;;0F 38 40;/r;;;Valid;Valid;SSE4_1;;PMULLD;PMUL;NA;Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1.;;
PMULLW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D5;/r;;;Valid;Valid;MMX;;PMULLW;PMUL;NA;Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1.;;
PMULLW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D5;/r;;;Valid;Valid;SSE2;;PMULLW;PMUL;NA;Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1.;;
PMULUDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F4;/r;;;Valid;Valid;SSE2;;PMULUDQ;PMUL;NA;Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1.;;
PMULUDQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F4;/r;;;Valid;Valid;SSE2;;PMULUDQ;PMUL;NA;Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1.;;
POP;Sreg=ES;;;;;;;;;;07;;;;Invalid;Valid;8086;;POP;POP;NA;Pop top of stack into ES+ increment stack pointer.;;
POP;Sreg=FS;;;;;;;;;;0F A1;;;;Valid;N.E.;8086;;POP;POP;NA;Pop top of stack into FS+ increment stack pointer by 64 bits.;;
POP;Sreg=FS;;;;;;;;;;0F A1;;;;Valid;Valid;8086;Legacy66;POP;POP;NA;Pop top of stack into FS+ increment stack pointer by 16 bits.;;
POP;Sreg=FS;;;;;;;;;;0F A1;;;;N.E.;Valid;8086;;POP;POP;NA;Pop top of stack into FS+ increment stack pointer by 32 bits.;;
POP;Sreg=GS;;;;;;;;;;0F A9;;;;N.E.;Valid;8086;;POP;POP;NA;Pop top of stack into GS+ increment stack pointer by 32 bits.;;
POP;Sreg=GS;;;;;;;;;;0F A9;;;;Valid;N.E.;8086;;POP;POP;NA;Pop top of stack into GS+ increment stack pointer by 64 bits.;;
POP;Sreg=GS;;;;;;;;;;0F A9;;;;Valid;Valid;8086;Legacy66;POP;POP;NA;Pop top of stack into GS+ increment stack pointer by 16 bits.;;
POP;Sreg=SS;;;;;;;;;;17;;;;Invalid;Valid;8086;;POP;POP;NA;Pop top of stack into SS+ increment stack pointer.;;
POP;Sreg=DS;;;;;;;;;;1F;;;;Invalid;Valid;8086;;POP;POP;NA;Pop top of stack into DS+ increment stack pointer.;;
POP;r64;;;;ModRM:reg (w);;;;;REX.W0;58+rd;;;;Valid;N.E.;8086;;POP;POP;NA;Pop top of stack into r64+ increment stack pointer. Cannot encode 32-bit operand size.;;
POP;r32;;;;ModRM:reg (w);;;;;;58+rd;;;;N.E.;Valid;8086;;POP;POP;NA;Pop top of stack into r32+ increment stack pointer.;;
POP;r16;;;;ModRM:reg (w);;;;;REX.W0;58+rw;;;;Valid;Valid;8086;;POP;POP;NA;Pop top of stack into r16+ increment stack pointer.;;
POP;m64/r64;;;;ModRM:r/m (w);;;;;REX.W0;8F;/0;;;Valid;N.E.;8086;;POP;POP;NA;Pop top of stack into m64+ increment stack pointer. Cannot encode 32-bit operand size.;;
POP;m32/r32;;;;ModRM:r/m (w);;;;;;8F;/0;;;N.E.;Valid;8086;;POP;POP;NA;Pop top of stack into m32+ increment stack pointer.;;
POP;m16/r16;;;;ModRM:r/m (w);;;;;REX.W0;8F;/0;;;Valid;Valid;8086;;POP;POP;NA;Pop top of stack into m16+ increment stack pointer.;;
POPA;;;;;;;;;;;61;;;;Invalid;Valid;8086;;POPA;POP;NA;Pop DI, SI, BP, BX, DX, CX, and AX.;;
POPAD;;;;;;;;;;;61;;;;Invalid;Valid;8086;;POPAD;POP;NA;Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.;;
POPCNT;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W;0F B8 ;/r;;;Valid;N.E;8086;;POPCNT;POP;NA;Return the count of number of bits set to 1 on r/m64.;;
POPCNT;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;F3;;0F B8 ;/r;;;Valid;Valid;8086;;POPCNT;POP;NA;Return the count of number of bits set to 1 on r/m32.;;
POPCNT;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;F3;;0F B8 ;/r;;;Valid;Valid;8086;;POPCNT;POP;NA;Return the count of number of bits set to 1 on r/m16.;;
POPF;;;;;;;;;;;9D;;;;Valid;Valid;8086;;POPF;POP;NA;Pop top of stack into lower 16 bits of EFLAGS.;;
POPFD;;;;;;;;;;;9D;;;;N.E.;Valid;8086;;POPFD;POP;NA;Pop top of stack into EFLAGS.;;
POPFQ;;;;;;;;;;REX.W;9D;;;;Valid;N.E.;8086;;POPFQ;POP;NA;Pop top of stack and zero-extend into RFLAGS.;;
POR;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F EB;/r;;;Valid;Valid;MMX;;POR;OR;NA;Bitwise OR of mm/m64 and mm.;;
POR;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F EB;/r;;;Valid;Valid;SSE2;;POR;OR;NA;Bitwise OR of xmm2/m128 and xmm1.;;
PREFETCHNTA;m8;;;;ModRM:r/m (r);;;;;;0F 18;/0;;;Valid;Valid;8086;;PREFETCHNTA;PREFETCH;NA;Move data from m8 closer to the processor using NTA hint.;;
PREFETCHT0;m8;;;;ModRM:r/m (r);;;;;;0F 18;/1;;;Valid;Valid;8086;;PREFETCHT0;PREFETCH;NA;Move data from m8 closer to the processor using T0 hint.;;
PREFETCHT1;m8;;;;ModRM:r/m (r);;;;;;0F 18;/2;;;Valid;Valid;8086;;PREFETCHT1;PREFETCH;NA;Move data from m8 closer to the processor using T1 hint.;;
PREFETCHT2;m8;;;;ModRM:r/m (r);;;;;;0F 18;/3;;;Valid;Valid;8086;;PREFETCHT2;PREFETCH;NA;Move data from m8 closer to the processor using T2 hint.;;
PSADBW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F6;/r;;;Valid;Valid;SSE2;;PSADBW;PSADW;NA;Computes the absolute differences of the packed unsigned byte integers from xmm2/m128 and xmm1  the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.;;
PSADBW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F6;/r;;;Valid;Valid;SSE;;PSADBW;PSADW;NA;Computes the absolute differences of the packed unsigned byte integers from mm2/m64 and mm1  differences are then summed to produce an unsigned word integer result.;;
PSHUFB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 00;/r;;;Valid;Valid;SSSE3;;PSHUFB;PSHUF;NA;Shuffle bytes in mm1 according to contents of mm2/m64.;;
PSHUFB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 00;/r;;;Valid;Valid;SSSE3;;PSHUFB;PSHUF;NA;Shuffle bytes in xmm1 according to contents of xmm2/m128.;;
PSHUFD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;REX.W0;0F 70;/r;;ib;Valid;Valid;SSE2;;PSHUFD;PSHUF;NA;Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
PSHUFHW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;F3;REX.W0;0F 70;/r;;ib;Valid;Valid;SSE2;;PSHUFHW;PSHUF;NA;Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
PSHUFLW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;F2;REX.W0;0F 70;/r;;ib;Valid;Valid;SSE2;;PSHUFLW;PSHUF;NA;Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
PSHUFW;imm8;mm/m64;mm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;REX.W0;0F 70;/r;;ib;Valid;Valid;8086;;PSHUFW;PSHUF;NA;Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1.;;
PSIGNB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 08;/r;;;Valid;Valid;SSSE3;;PSIGNB;PSIGN;NA;Negate packed byte integers in xmm1 if the corresponding sign in xmm2/m128 is less than zero.;;
PSIGNB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 08;/r;;;Valid;Valid;SSSE3;;PSIGNB;PSIGN;NA;Negate packed byte integers in mm1 if the corresponding sign in mm2/m64 is less than zero.;;
PSIGND;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 0A;/r;;;Valid;Valid;SSSE3;;PSIGND;PSIGN;NA;Negate packed doubleword integers in xmm1 if the corresponding sign in xmm2/m128 is less than zero.;;
PSIGND;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 0A;/r;;;Valid;Valid;SSSE3;;PSIGND;PSIGN;NA;Negate packed doubleword integers in mm1 if the corresponding sign in mm2/m64 is less than zero.;;
PSIGNW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 38 09;/r;;;Valid;Valid;SSSE3;;PSIGNW;PSIGN;NA;Negate packed 16-bit integers in xmm1 if the corresponding sign in xmm2/m128 is less than zero.;;
PSIGNW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 38 09;/r;;;Valid;Valid;SSSE3;;PSIGNW;PSIGN;NA;Negate packed 16-bit integers in mm1 if the corresponding sign in mm2/m64 is less than zero.;;
PSLLD;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 72;/6;;ib;Valid;Valid;8086;;PSLLD;PSLL;NA;Shift doublewords in mm left by imm8 while shifting in 0s.;;
PSLLD;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 72;/6;;ib;Valid;Valid;8086;;PSLLD;PSLL;NA;Shift doublewords in xmm1 left by imm8 while shifting in 0s.;;
PSLLD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F2;/r;;;Valid;Valid;8086;;PSLLD;PSLL;NA;Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s.;;
PSLLD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F2;/r;;;Valid;Valid;8086;;PSLLD;PSLL;NA;Shift doublewords in mm left by mm/m64 while shifting in 0s.;;
PSLLDQ;imm8;xmm;;;imm8;ModRM:reg (r, w);;;66;REX.W0;0F 73;/7;;ib;Valid;Valid;SSE2;;PSLLDQ;PSLL;NA;Shift xmm1 left by imm8 bytes while shifting in 0s.;;
PSLLQ;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 73;/6;;ib;Valid;Valid;SSE2;;PSLLQ;PSLL;NA;Shift quadwords in xmm1 left by imm8 while shifting in 0s.;;
PSLLQ;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 73;/6;;ib;Valid;Valid;MMX;;PSLLQ;PSLL;NA;Shift quadword in mm left by imm8 while shifting in 0s.;;
PSLLQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F3;/r;;;Valid;Valid;MMX;;PSLLQ;PSLL;NA;Shift quadword in mm left by mm/m64 while shifting in 0s.;;
PSLLQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F3;/r;;;Valid;Valid;SSE2;;PSLLQ;PSLL;NA;Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s.;;
PSLLW;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 71;/6;;ib;Valid;Valid;MMX;;PSLLW;PSLL;NA;Shift words in mm left by imm8 while shifting in 0s.;;
PSLLW;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 71;/6;;ib;Valid;Valid;SSE2;;PSLLW;PSLL;NA;Shift words in xmm1 left by imm8 while shifting in 0s.;;
PSLLW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F1;/r;;;Valid;Valid;MMX;;PSLLW;PSLL;NA;Shift words in mm left mm/m64 while shifting in 0s.;;
PSLLW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F1;/r;;;Valid;Valid;SSE2;;PSLLW;PSLL;NA;Shift words in xmm1 left by xmm2/m128 while shifting in 0s.;;
PSRAD;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 72;/4;;ib;Valid;Valid;MMX;;PSRAD;PSHR;NA;Shift doublewords in mm right by imm8 while shifting in sign bits.;;
PSRAD;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 72;/4;;ib;Valid;Valid;SSE2;;PSRAD;PSHR;NA;Shift doublewords in xmm1 right by imm8 while shifting in sign bits.;;
PSRAD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E2;/r;;;Valid;Valid;SSE2;;PSRAD;PSHR;NA;Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits.;;
PSRAD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E2;/r;;;Valid;Valid;MMX;;PSRAD;PSHR;NA;Shift doublewords in mm right by mm/m64 while shifting in sign bits.;;
PSRAW;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 71;/4;;ib;Valid;Valid;SSE2;;PSRAW;PSHR;NA;Shift words in xmm1 right by imm8 while shifting in sign bits;;
PSRAW;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 71;/4;;ib;Valid;Valid;MMX;;PSRAW;PSHR;NA;Shift words in mm right by imm8 while shifting in sign bits;;
PSRAW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E1;/r;;;Valid;Valid;SSE2;;PSRAW;PSHR;NA;Shift words in xmm1 right by xmm2/m128 while shifting in sign bits.;;
PSRAW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E1;/r;;;Valid;Valid;MMX;;PSRAW;PSHR;NA;Shift words in mm right by mm/m64 while shifting in sign bits.;;
PSRLD;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 72;/2;;ib;Valid;Valid;SSE2;;PSRLD;PSHR;NA;Shift doublewords in xmm1 right by imm8 while shifting in 0s.;;
PSRLD;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 72;/2;;ib;Valid;Valid;MMX;;PSRLD;PSHR;NA;Shift doublewords in mm right by imm8 while shifting in 0s.;;
PSRLD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D2;/r;;;Valid;Valid;MMX;;PSRLD;PSHR;NA;Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s.;;
PSRLD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D2;/r;;;Valid;Valid;SSE2;;PSRLD;PSHR;NA;Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s.;;
PSRLDQ;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 73;/3;;ib;Valid;Valid;SSE2;;PSRLDQ;PSHR;NA;Shift xmm1 right by imm8 while shifting in 0s.;;
PSRLQ;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 73;/2;;ib;Valid;Valid;MMX;;PSRLQ;PSHL;NA;Shift mm right by imm8 while shifting in 0s.;;
PSRLQ;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 73;/2;;ib;Valid;Valid;SSE2;;PSRLQ;PSHL;NA;Shift quadwords in xmm1 right by imm8 while shifting in 0s.;;
PSRLQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D3;/r;;;Valid;Valid;MMX;;PSRLQ;PSHL;NA;Shift mm right by amount specified in mm/m64 while shifting in 0s.;;
PSRLQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D3;/r;;;Valid;Valid;SSE2;;PSRLQ;PSHL;NA;Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.;;
PSRLW;imm8;mm;;;imm8;ModRM:r/m (r, w);;;;;0F 71;/2;;ib;Valid;Valid;MMX;;PSRLW;PSHR;NA;Shift words in mm right by imm8 while shifting in 0s.;;
PSRLW;imm8;xmm;;;imm8;ModRM:r/m (r, w);;;66;REX.W0;0F 71;/2;;ib;Valid;Valid;SSE2;;PSRLW;PSHR;NA;Shift words in xmm1 right by imm8 while shifting in 0s.;;
PSRLW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D1;/r;;;Valid;Valid;MMX;;PSRLW;PSHR;NA;Shift words in mm right by amount specified in mm/m64 while shifting in 0s.;;
PSRLW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D1;/r;;;Valid;Valid;SSE2;;PSRLW;PSHR;NA;Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s.;;
PSUBB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F8;/r;;;Valid;Valid;MMX;;PSUBB;PSUB;NA;Subtract packed byte integers in mm/m64 from packed byte integers in mm.;;
PSUBB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F8;/r;;;Valid;Valid;SSE2;;PSUBB;PSUB;NA;Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1.;;
PSUBD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F FA;/r;;;Valid;Valid;SSE2;;PSUBD;PSUB;NA;Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1.;;
PSUBD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F FA;/r;;;Valid;Valid;MMX;;PSUBD;PSUB;NA;Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm.;;
PSUBQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F FB;/r;;;Valid;Valid;SSE2;;PSUBQ;PSUB;NA;Subtract quadword integer in mm1 from mm2 /m64.;;
PSUBQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F FB;/r;;;Valid;Valid;SSE2;;PSUBQ;PSUB;NA;Subtract packed quadword integers in xmm1 from xmm2 /m128.;;
PSUBSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E8;/r;;;Valid;Valid;SSE2;;PSUBSB;PSUB;NA;Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results.;;
PSUBSB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E8;/r;;;Valid;Valid;MMX;;PSUBSB;PSUB;NA;Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results.;;
PSUBSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F E9;/r;;;Valid;Valid;MMX;;PSUBSW;PSUB;NA;Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results.;;
PSUBSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F E9;/r;;;Valid;Valid;SSE2;;PSUBSW;PSUB;NA;Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results.;;
PSUBUSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D8;/r;;;Valid;Valid;SSE2;;PSUBUSB;PSUB;NA;Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result.;;
PSUBUSB;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D8;/r;;;Valid;Valid;MMX;;PSUBUSB;PSUB;NA;Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result.;;
PSUBUSW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F D9;/r;;;Valid;Valid;MMX;;PSUBUSW;PSUB;NA;Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result.;;
PSUBUSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F D9;/r;;;Valid;Valid;SSE2;;PSUBUSW;PSUB;NA;Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result.;;
PSUBW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F F9;/r;;;Valid;Valid;MMX;;PSUBW;PSUB;NA;Subtract packed word integers in mm/m64 from packed word integers in mm.;;
PSUBW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F F9;/r;;;Valid;Valid;SSE2;;PSUBW;PSUB;NA;Subtract packed word integers in xmm2/m128 from packed word integers in xmm1.;;
PSWAPD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 0F;/r;;BB;Valid;Valid;3DNow;;PSWAPD;PSWAPD;NA;Swaps packed 32-bit values in an MMX register or 64-bit memory location and writes each value in the destination MMX register.;;
PTEST;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;66;;0F 38 17;/r;;;Valid;Valid;SSE4_1;;PTEST;UNDEF;NA;Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s.;;
PUNPCKHBW;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 68;/r;;;Valid;Valid;MMX;;PUNPCKHBW;PUNPCK;NA;Unpack and interleave high- order bytes from mm and mm/m64 into mm.;;
PUNPCKHBW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 68;/r;;;Valid;Valid;SSE2;;PUNPCKHBW;PUNPCK;NA;Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKHDQ;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 6A;/r;;;Valid;Valid;MMX;;PUNPCKHDQ;PUNPCK;NA;Unpack and interleave high-order doublewords from mm and mm/m64 into mm.;;
PUNPCKHDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 6A;/r;;;Valid;Valid;SSE2;;PUNPCKHDQ;PUNPCK;NA;Unpack and interleave high- order doublewords from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKHQDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 6D;/r;;;Valid;Valid;SSE2;;PUNPCKHQDQ;PUNPCK;NA;Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKHWD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 69;/r;;;Valid;Valid;SSE2;;PUNPCKHWD;PUNPCK;NA;Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKHWD;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 69;/r;;;Valid;Valid;MMX;;PUNPCKHWD;PUNPCK;NA;Unpack and interleave high-order words from mm and mm/m64 into mm.;;
PUNPCKLBW;mm/m32;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 60;/r;;;Valid;Valid;MMX;;PUNPCKLBW;PUNPCK;NA;Interleave low-order bytes from mm and mm/m32 into mm.;;
PUNPCKLBW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 60;/r;;;Valid;Valid;SSE2;;PUNPCKLBW;PUNPCK;NA;Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKLDQ;mm/m32;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 62;/r;;;Valid;Valid;MMX;;PUNPCKLDQ;PUNPCK;NA;Interleave low-order doublewords from mm and mm/m32 into mm.;;
PUNPCKLDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 62;/r;;;Valid;Valid;SSE2;;PUNPCKLDQ;PUNPCK;NA;Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKLQDQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 6C;/r;;;Valid;Valid;SSE2;;PUNPCKLQDQ;PUNPCK;NA;Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register.;;
PUNPCKLWD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 61;/r;;;Valid;Valid;SSE2;;PUNPCKLWD;PUNPCK;NA;Interleave low-order words from xmm1 and xmm2/m128 into xmm1.;;
PUNPCKLWD;mm/m32;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 61;/r;;;Valid;Valid;MMX;;PUNPCKLWD;PUNPCK;NA;Interleave low-order words from mm and mm/m32 into mm.;;
PUSH;Sreg=SS;;;;;;;;;;16;;;;Invalid;Valid;8086;;PUSH;PUSH;NA;Push SS.;;
PUSH;imm16;;;;imm16;;;;;;68;;;iw;Valid;Valid;8086;Legacy66;PUSH;PUSH;NA;Push sign-extended imm16. Stack pointer is incremented by the size of stack pointer.;;
PUSH;imm32;;;;imm32;;;;;;68;;;id;Valid;Valid;8086;;PUSH;PUSH;NA;Push sign-extended imm32. Stack pointer is incremented by the size of stack pointer.;;
PUSH;Sreg=ES;;;;;;;;;;06;;;;Invalid;Valid;8086;;PUSH;PUSH;NA;Push ES.;;
PUSH;Sreg=CS;;;;;;;;;;0E;;;;Invalid;Valid;8086;;PUSH;PUSH;NA;Push CS.;;
PUSH;Sreg=FS;;;;;;;;;;0F A0;;;;Valid;Valid;8086;Legacy66;PUSH;PUSH;NA;Push FS and decrement stack pointer by 16 bits.;;
PUSH;Sreg=FS;;;;;;;;;;0F A0;;;;Valid;N.E.;8086;;PUSH;PUSH;NA;Push FS. Default operand size 64-bits. (66H override causes 16-bit operation).;;
PUSH;Sreg=FS;;;;;;;;;;0F A0;;;;N.E.;Valid;8086;;PUSH;PUSH;NA;Push FS and decrement stack pointer by 32 bits.;;
PUSH;Sreg=GS;;;;;;;;;;0F A8;;;;Valid;Valid;8086;Legacy66;PUSH;PUSH;NA;Push GS and decrement stack pointer by 16 bits.;;
PUSH;Sreg=GS;;;;;;;;;;0F A8;;;;Valid;N.E.;8086;;PUSH;PUSH;NA;Push GS, default operand size 64-bits. (66H override causes 16-bit operation).;;
PUSH;Sreg=GS;;;;;;;;;;0F A8;;;;N.E.;Valid;8086;;PUSH;PUSH;NA;Push GS and decrement stack pointer by 32 bits.;;
PUSH;Sreg=DS;;;;;;;;;;1E;;;;Invalid;Valid;8086;;PUSH;PUSH;NA;Push DS.;;
PUSH;r32;;;;ModRM:reg (r);;;;;;50+rd;;;;N.E.;Valid;8086;;PUSH;PUSH;NA;Push r32.;;
PUSH;r64;;;;ModRM:reg (r);;;;;REX.W0;50+rd;;;;Valid;N.E.;8086;;PUSH;PUSH;NA;Push r64. Default operand size 64-bits.;;
PUSH;r16;;;;ModRM:reg (r);;;;;REX.W0;50+rw;;;;Valid;Valid;8086;;PUSH;PUSH;NA;Push r16.;;
PUSH;imm8;;;;imm8;;;;;;6A;;;ib;Valid;Valid;8086;;PUSH;PUSH;NA;Push sign-extended imm8. Stack pointer is incremented by the size of stack pointer.;;
PUSH;m64/r64;;;;ModRM:r/m (r);;;;;REX.W0;FF;/6;;;Valid;N.E.;8086;;PUSH;PUSH;NA;Push r/m64. Default operand size 64-bits.;;
PUSH;m32/r32;;;;ModRM:r/m (r);;;;;;FF;/6;;;N.E.;Valid;8086;;PUSH;PUSH;NA;Push r/m32.;;
PUSH;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;FF;/6;;;Valid;Valid;8086;;PUSH;PUSH;NA;Push r/m16.;;
PUSHA;;;;;;;;;;;60;;;;Invalid;Valid;8086;;PUSHA;PUSH;NA;Push AX, CX, DX, BX, original SP, BP, SI, and DI.;;
PUSHAD;;;;;;;;;;;60;;;;Invalid;Valid;8086;;PUSHAD;PUSH;NA;Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.;;
PUSHF;;;;;;;;;;;9C;;;;Valid;Valid;8086;;PUSHF;PUSH;NA;Push lower 16 bits of EFLAGS.;;
PUSHFD;;;;;;;;;;;9C;;;;N.E.;Valid;8086;;PUSHFD;PUSH;NA;Push EFLAGS.;;
PUSHFQ;;;;;;;;;;;9C;;;;Valid;N.E.;8086;;PUSHFQ;PUSH;NA;Push RFLAGS.;;
PXOR;mm/m64;mm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F EF;/r;;;Valid;Valid;MMX;;PXOR;XOR;NA;Bitwise XOR of mm/m64 and mm.;;
PXOR;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F EF;/r;;;Valid;Valid;SSE2;;PXOR;XOR;NA;Bitwise XOR of xmm2/m128 and xmm1.;;
RCL;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;C0;/2;;ib;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left imm8 times.;;
RCL;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;C0;/2;;ib;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left imm8 times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCL;imm8;m32/r32;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/2;;ib;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 33 bits (CF, r/m32) left imm8 times.;;
RCL;imm8;m16/r16;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/2;;ib;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 17 bits (CF, r/m16) left imm8 times.;;
RCL;imm8;m64/r64;;;imm8;ModRM:r/m (w);;;;REX.W;C1;/2;;ib;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 65 bits (CF, r/m64) left imm8 times. Uses a 6 bit count.;;
RCL;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D0;/2;;;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left once.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCL;imm8=1;m8/r8;;;;ModRM:r/m (w);;;;;D0;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left once.;;
RCL;imm8=1;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D1;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 17 bits (CF, r/m16) left once.;;
RCL;imm8=1;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D1;/2;;;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 65 bits (CF, r/m64) left once. Uses a 6 bit count.;;
RCL;imm8=1;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D1;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 33 bits (CF, r/m32) left once.;;
RCL;r8=CL;m8/r8;;;;ModRM:r/m (w);;;;;D2;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left CL times.;;
RCL;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D2;/2;;;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 9 bits (CF, r/m8) left CL times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCL;r8=CL;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D3;/2;;;Valid;N.E.;8086;;RCL;ROTATE;NA;Rotate 65 bits (CF, r/m64) left CL times. Uses a 6 bit count.;;
RCL;r8=CL;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D3;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 33 bits (CF, r/m32) left CL times.;;
RCL;r8=CL;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D3;/2;;;Valid;Valid;8086;;RCL;ROTATE;NA;Rotate 17 bits (CF, r/m16) left CL times.;;
RCPPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 53;/r;;;Valid;Valid;SSE;;RCPPS;RCP;NA;Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.;;
RCPSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 53;/r;;;Valid;Valid;SSE;;RCPSS;RCP;NA;Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1.;;
RCR;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;C0;/3;;ib;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right imm8 times.;;
RCR;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;C0;/3;;ib;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right imm8 times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCR;imm8;m16/r16;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/3;;ib;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 17 bits (CF, r/m16) right imm8 times.;;
RCR;imm8;m32/r32;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/3;;ib;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 33 bits (CF, r/m32) right imm8 times.;;
RCR;imm8;m64/r64;;;imm8;ModRM:r/m (w);;;;REX.W;C1;/3;;ib;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 65 bits (CF, r/m64) right imm8 times. Uses a 6 bit count.;;
RCR;imm8=1;m8/r8;;;;ModRM:r/m (w);;;;;D0;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right once.;;
RCR;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D0;/3;;;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right once.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCR;imm8=1;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D1;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 33 bits (CF, r/m32) right once. Uses a 6 bit count.;;
RCR;imm8=1;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D1;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 17 bits (CF, r/m16) right once.;;
RCR;imm8=1;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D1;/3;;;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 65 bits (CF, r/m64) right once. Uses a 6 bit count.;;
RCR;r8=CL;m8/r8;;;;ModRM:r/m (w);;;;;D2;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right CL times.;;
RCR;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D2;/3;;;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 9 bits (CF, r/m8) right CL;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
RCR;r8=CL;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D3;/3;;;Valid;N.E.;8086;;RCR;ROTATE;NA;Rotate 65 bits (CF, r/m64) right CL times. Uses a 6 bit count.;;
RCR;r8=CL;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D3;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 17 bits (CF, r/m16) right CL times.;;
RCR;r8=CL;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D3;/3;;;Valid;Valid;8086;;RCR;ROTATE;NA;Rotate 33 bits (CF, r/m32) right CL times.;;
RDMSR;;;;;;;;;;REX.W0;0F 32;;;;Valid;Valid;8086;;RDMSR;RDMSR;NA;Load MSR specified by ECX into EDX:EAX.;;
RDMSR;;;;;;;;;;REX.W;0F 32;;;;Valid;N.E.;8086;;RDMSR;RDMSR;NA;Load MSR specified by RCX into RDX:RAX.;;
RDPMC;;;;;;;;;;;0F 33;;;;Valid;Valid;8086;;RDPMC;RDPMC;NA;Read performance-monitoring counter specified by ECX into EDX:EAX.;;
RDRAND;r16;;;;ModRM:r/m (w);;;;;REX.W0;0F C7;/6;;;Valid;Valid;RDRAND;;RDRAND;UNDEF;NA;Read a 16-bit random number and store in the destination register.;;
RDRAND;r32;;;;ModRM:r/m (w);;;;;REX.W0;0F C7;/6;;;Valid;Valid;RDRAND;;RDRAND;UNDEF;NA;Read a 32-bit random number and store in the destination register.;;
RDRAND;r64;;;;ModRM:r/m (w);;;;;REX.W;0F C7;/6;;;Valid;Invalid;RDRAND;;RDRAND;UNDEF;NA;Read a 64-bit random number and store in the destination register.;;
RDTSC;;;;;;;;;;;0F 31;;;;Valid;Valid;8086;;RDTSC;RDTSC;NA;Read time-stamp counter into EDX:EAX.;;
RDTSCP;;;;;;;;;;;0F 01 F9 ;;;;Valid;Valid;8086;;RDTSCP;RDTSC;NA;Read 64-bit time-stamp counter and 32-bit IA32_TSC_AUX value into EDX:EAX and ECX.;;
REP INS;r16=DX;m8=(R)DI;;;;;;;F3;;6C;;;;Valid;N.E.;8086;;REP INS;IN;NA;Input RCX bytes from port DX into [RDI].;;
REP INS;r16=DX;m8=ES:(E)DI;;;;;;;F3;;6C;;;;Valid;Valid;8086;;REP INS;IN;NA;Input (E)CX bytes from port DX into ES:[(E)DI].;;
REP INS;r16=DX;m32=(R)DI;;;;;;;F3;;6D;;;;Valid;N.E.;8086;;REP INS;IN;NA;Input RCX default size from port DX into [RDI].;;
REP INS;r16=DX;m16=ES:(E)DI;;;;;;;F3;;6D;;;;Valid;Valid;8086;;REP INS;IN;NA;Input (E)CX words from port DX into ES:[(E)DI.];;
REP INS;r16=DX;m32=ES:(E)DI;;;;;;;F3;;6D;;;;Valid;Valid;8086;;REP INS;IN;NA;Input (E)CX doublewords from port DX into ES:[(E)DI].;;
REP LODS;m8=(R)SI;r8=AL;;;;;;;F3;REX.W;AC;;;;Valid;N.E.;8086;;REP LODS;LODS;NA;Load RCX bytes from [RSI] to AL.;;
REP LODS;m8=DS:(E)SI;r8=AL;;;;;;;F3;;AC;;;;Valid;Valid;8086;;REP LODS;LODS;NA;Load (E)CX bytes from DS:[(E)SI] to AL.;;
REP LODS;m64=(R)SI;r64=RAX;;;;;;;F3;REX.W;AD;;;;Valid;N.E.;8086;;REP LODS;LODS;NA;Load RCX quadwords from [RSI] to RAX.;;
REP LODS;m32=DS:(E)SI;r32=EAX;;;;;;;F3;;AD;;;;Valid;Valid;8086;;REP LODS;LODS;NA;Load (E)CX doublewords from DS:[(E)SI] to EAX.;;
REP LODS;m16=DS:(E)SI;r16=AX;;;;;;;F3;;AD;;;;Valid;Valid;8086;;REP LODS;LODS;NA;Load (E)CX words from DS:[(E)SI] to AX.;;
REP MOVS;m8=(R)SI;m8=(R)DI;;;;;;;F3;REX.W;A4;;;;Valid;N.E.;8086;;REP MOVS;MOVS;NA;Move RCX bytes from [RSI] to [RDI].;;
REP MOVS;m8=DS:(E)SI;m8=ES:(E)DI;;;;;;;F3;;A4;;;;Valid;Valid;8086;;REP MOVS;MOVS;NA;Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI].;;
REP MOVS;m32=DS:(E)SI;m32=ES:(E)DI;;;;;;;F3;;A5;;;;Valid;Valid;8086;;REP MOVS;MOVS;NA;Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI].;;
REP MOVS;m16=DS:(E)SI;m16=ES:(E)DI;;;;;;;F3;;A5;;;;Valid;Valid;8086;;REP MOVS;MOVS;NA;Move (E)CX words from DS:[(E)SI] to ES:[(E)DI].;;
REP MOVS;m64=(R)SI;m64=(R)DI;;;;;;;F3;REX.W;A5;;;;Valid;N.E.;8086;;REP MOVS;MOVS;NA;Move RCX quadwords from [RSI] to [RDI].;;
REP OUTS;m8=DS:(E)SI;r16=DX;;;;;;;F3;;6E;;;;Valid;Valid;8086;;REP OUTS;OUT;NA;Output (E)CX bytes from DS:[(E)SI] to port DX.;;
REP OUTS;m8=(R)SI;r16=DX;;;;;;;F3;REX.W;6E;;;;Valid;N.E.;8086;;REP OUTS;OUT;NA;Output RCX bytes from [RSI] to port DX.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
REP OUTS;m32=(R)SI;r16=DX;;;;;;;F3;REX.W;6F;;;;Valid;N.E.;8086;;REP OUTS;OUT;NA;Output RCX default size from [RSI] to port DX.;;
REP OUTS;m32=DS:(E)SI;r16=DX;;;;;;;F3;;6F;;;;Valid;Valid;8086;;REP OUTS;OUT;NA;Output (E)CX doublewords from DS:[(E)SI] to port DX.;;
REP OUTS;m16=DS:(E)SI;r16=DX;;;;;;;F3;;6F;;;;Valid;Valid;8086;;REP OUTS;OUT;NA;Output (E)CX words from DS:[(E)SI] to port DX.;;
REP STOS;m8=(R)DI;;;;;;;;F3;REX.W;AA;;;;Valid;N.E.;8086;;REP STOS;STOS;NA;Fill RCX bytes at [RDI] with AL.;;
REP STOS;m8=ES:(E)DI;;;;;;;;F3;;AA;;;;Valid;Valid;8086;;REP STOS;STOS;NA;Fill (E)CX bytes at ES:[(E)DI] with AL.;;
REP STOS;m32=ES:(E)DI;;;;;;;;F3;;AB;;;;Valid;Valid;8086;;REP STOS;STOS;NA;Fill (E)CX doublewords at ES:[(E)DI] with EAX.;;
REP STOS;m64=(R)DI;;;;;;;;F3;REX.W;AB;;;;Valid;N.E.;8086;;REP STOS;STOS;NA;Fill RCX quadwords at [RDI] with RAX.;;
REP STOS;m16=ES:(E)DI;;;;;;;;F3;;AB;;;;Valid;Valid;8086;;REP STOS;STOS;NA;Fill (E)CX words at ES:[(E)DI] with AX.;;
REPE CMPS;m8=ES:(E)DI;m8=DS:(E)SI;;;;;;;F3;;A6;;;;Valid;Valid;8086;;REPE CMPS;CMP;NA;Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI].;;
REPE CMPS;m8=(R)DI;m8=(R)SI;;;;;;;F3;REX.W;A6;;;;Valid;N.E.;8086;;REPE CMPS;CMP;NA;Find non-matching bytes in [RDI] and [RSI].;;
REPE CMPS;m32=ES:(E)DI;m32=DS:(E)SI;;;;;;;F3;;A7;;;;Valid;Valid;8086;;REPE CMPS;CMP;NA;Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI].;;
REPE CMPS;m16=ES:(E)DI;m16=DS:(E)SI;;;;;;;F3;;A7;;;;Valid;Valid;8086;;REPE CMPS;CMP;NA;Find nonmatching words in ES:[(E)DI] and DS:[(E)SI].;;
REPE CMPS;m64=(R)DI;m64=(R)SI;;;;;;;F3;REX.W;A7;;;;Valid;N.E.;8086;;REPE CMPS;CMP;NA;Find non-matching quadwords in [RDI] and [RSI].;;
REPE SCAS;m8=ES:(E)DI;;;;;;;;F3;;AE;;;;Valid;Valid;8086;;REPE SCAS;SCAS;NA;Find non-AL byte starting at ES:[(E)DI].;;
REPE SCAS;m8=(R)DI;;;;;;;;F3;REX.W;AE;;;;Valid;N.E.;8086;;REPE SCAS;SCAS;NA;Find non-AL byte starting at [RDI].;;
REPE SCAS;m64=(R)DI;;;;;;;;F3;REX.W;AF;;;;Valid;N.E.;8086;;REPE SCAS;SCAS;NA;Find non-RAX quadword starting at [RDI].;;
REPE SCAS;m16=ES:(E)DI;;;;;;;;F3;;AF;;;;Valid;Valid;8086;;REPE SCAS;SCAS;NA;Find non-AX word starting at ES:[(E)DI].;;
REPE SCAS;m32=ES:(E)DI;;;;;;;;F3;;AF;;;;Valid;Valid;8086;;REPE SCAS;SCAS;NA;Find non-EAX doubleword starting at ES:[(E)DI].;;
REPNE CMPS;m8=ES:(E)DI;m8=DS:(E)SI;;;;;;;F2;;A6;;;;Valid;Valid;8086;;REPNE CMPS;CMP;NA;Find matching bytes in ES:[(E)DI] and DS:[(E)SI].;;
REPNE CMPS;m8=(R)DI;m8=(R)SI;;;;;;;F2;REX.W;A6;;;;Valid;N.E.;8086;;REPNE CMPS;CMP;NA;Find matching bytes in [RDI] and [RSI].;;
REPNE CMPS;m64=(R)DI;m64=(R)SI;;;;;;;F2;REX.W;A7;;;;Valid;N.E.;8086;;REPNE CMPS;CMP;NA;Find matching doublewords in [RDI] and [RSI].;;
REPNE CMPS;m32=ES:(E)DI;m32=DS:(E)SI;;;;;;;F2;;A7;;;;Valid;Valid;8086;;REPNE CMPS;CMP;NA;Find matching doublewords in ES:[(E)DI] and DS:[(E)SI].;;
REPNE CMPS;m16=ES:(E)DI;m16=DS:(E)SI;;;;;;;F2;;A7;;;;Valid;Valid;8086;;REPNE CMPS;CMP;NA;Find matching words in ES:[(E)DI] and DS:[(E)SI].;;
REPNE SCAS;m8=ES:(E)DI;;;;;;;;F2;;AE;;;;Valid;Valid;8086;;REPNE SCAS;SCAS;NA;Find AL, starting at ES:[(E)DI].;;
REPNE SCAS;m8=(R)DI;;;;;;;;F2;REX.W;AE;;;;Valid;N.E.;8086;;REPNE SCAS;SCAS;NA;Find AL, starting at [RDI].;;
REPNE SCAS;m16=ES:(E)DI;;;;;;;;F2;;AF;;;;Valid;Valid;8086;;REPNE SCAS;SCAS;NA;Find AX, starting at ES:[(E)DI].;;
REPNE SCAS;m32=ES:(E)DI;;;;;;;;F2;;AF;;;;Valid;Valid;8086;;REPNE SCAS;SCAS;NA;Find EAX, starting at ES:[(E)DI].;;
REPNE SCAS;m64=(R)DI;;;;;;;;F2;REX.W;AF;;;;Valid;N.E.;8086;;REPNE SCAS;SCAS;NA;Find RAX, starting at [RDI].;;
RET;imm16;;;;imm16;;;;;;C2;;;iw;Valid;Valid;8086;;RET;RET;JRET;Near return to calling procedure and pop imm16 bytes from stack.;;
RET;;;;;;;;;;;C3;;;;Valid;Valid;8086;;RET;RET;JRET;Near return to calling procedure.;;
RET;;;;;;;;;;;CB;;;;Valid;Valid;8086;;RET;RET;JRET;Far return to calling procedure.;;
RETF;imm16;;;;imm16;;;;;;CA;;;iw;Valid;Valid;8086;;LRET;RET;JRET;Far return to calling procedure and pop imm16 bytes from stack.;;
ROL;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;C0;/0;;ib;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left imm8 times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROL;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;C0;/0;;ib;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left imm8 times.;;
ROL;imm8;m32/r32;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/0;;ib;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 32 bits r/m32 left imm8 times.;;
ROL;imm8;m64/r64;;;imm8;ModRM:r/m (w);;;;REX.W;C1;/0;;ib;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 64 bits r/m64 left imm8 times. Uses a 6 bit count.;;
ROL;imm8;m16/r16;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/0;;ib;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 16 bits r/m16 left imm8 times.;;
ROL;imm8=1;m8/r8;;;;ModRM:r/m (w);;;;;D0;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left once.;;
ROL;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D0;/0;;;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left once;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROL;imm8=1;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D1;/0;;;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 64 bits r/m64 left once.;;
ROL;imm8=1;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D1;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 16 bits r/m16 left once.;;
ROL;imm8=1;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D1;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 32 bits r/m32 left once.;;
ROL;r8=CL;m8/r8;;;;ModRM:r/m (w);;;;;D2;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left CL times.;;
ROL;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D2;/0;;;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 8 bits r/m8 left CL times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROL;r8=CL;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D3;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 32 bits r/m32 left CL times.;;
ROL;r8=CL;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D3;/0;;;Valid;Valid;8086;;ROL;ROTATE;NA;Rotate 16 bits r/m16 left CL times.;;
ROL;r8=CL;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D3;/0;;;Valid;N.E.;8086;;ROL;ROTATE;NA;Rotate 64 bits r/m64 left CL times. Uses a 6 bit count.;;
ROR;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;C0;/1;;ib;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m16 right imm8 times.;;
ROR;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;C0;/1;;ib;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m16 right imm8 times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROR;imm8;m16/r16;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/1;;ib;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 16 bits r/m16 right imm8 times.;;
ROR;imm8;m64/r64;;;imm8;ModRM:r/m (w);;;;REX.W;C1;/1;;ib;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 64 bits r/m64 right imm8 times. Uses a 6 bit count.;;
ROR;imm8;m32/r32;;;imm8;ModRM:r/m (w);;;;REX.W0;C1;/1;;ib;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 32 bits r/m32 right imm8 times.;;
ROR;imm8=1;m8/r8;;;;ModRM:r/m (w);;;;;D0;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m8 right once.;;
ROR;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D0;/1;;;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m8 right once.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROR;imm8=1;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D1;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 32 bits r/m32 right once.;;
ROR;imm8=1;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D1;/1;;;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 64 bits r/m64 right once. Uses a 6 bit count.;;
ROR;imm8=1;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D1;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 16 bits r/m16 right once.;;
ROR;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (w);;;;REX;D2;/1;;;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m8 right CL times.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
ROR;r8=CL;m8/r8;;;;ModRM:r/m (w);;;;;D2;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 8 bits r/m8 right CL times.;;
ROR;r8=CL;m32/r32;;;;ModRM:r/m (w);;;;REX.W0;D3;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 32 bits r/m32 right CL times.;;
ROR;r8=CL;m64/r64;;;;ModRM:r/m (w);;;;REX.W;D3;/1;;;Valid;N.E.;8086;;ROR;ROTATE;NA;Rotate 64 bits r/m64 right CL times. Uses a 6 bit count.;;
ROR;r8=CL;m16/r16;;;;ModRM:r/m (w);;;;REX.W0;D3;/1;;;Valid;Valid;8086;;ROR;ROTATE;NA;Rotate 16 bits r/m16 right CL times.;;
ROUNDPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 09;/r;;ib;Valid;Valid;SSE4_1;;ROUNDPD;UNDEF;NA;Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.;;
ROUNDPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 08;/r;;ib;Valid;Valid;SSE4_1;;ROUNDPS;UNDEF;NA;Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8. ;;
ROUNDSD;imm8;xmm/m64;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 0B;/r;;ib;Valid;Valid;SSE4_1;;ROUNDSD;UNDEF;NA;Round the low packed double precision floatingpoint value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by imm8.;;
ROUNDSS;imm8;xmm/m32;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;66;;0F 3A 0A;/r;;ib;Valid;Valid;SSE4_1;;ROUNDSS;UNDEF;NA;Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by imm8.;;
RSM;;;;;;;;;;;0F AA;;;;Invalid;Valid;8086;;RSM;RSM;NA;Resume operation of interrupted program.;;
RSQRTPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 52;/r;;;Valid;Valid;SSE;;RSQRTPS;RSQRT;NA;Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.;;
RSQRTSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 52;/r;;;Valid;Valid;SSE;;RSQRTSS;RSQRT;NA;Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.;;
SAHF;;;;;;;;;;;9E;;;;Invalid;Valid;8086;;SAHF;SAHF;NA;Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register.;64 bits mode valid in specific steppings. See Description section.;
SAL;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;C0;/4;;ib;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, imm8 times.;In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SAL;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;C0;/4;;ib;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, imm8 times.;;
SAL;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/4;;ib;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m16 by 2, imm8 times.;;
SAL;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/4;;ib;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m32 by 2, imm8 times.;;
SAL;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;C1;/4;;ib;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m64 by 2, imm8 times.;;
SAL;imm8=1;m8/r8;;;;ModRM:r/m (r, w);;;;;D0;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, once.;;
SAL;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D0;/4;;;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, once.;In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SAL;imm8=1;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D1;/4;;;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m64 by 2, once.;;
SAL;imm8=1;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m16 by 2, once.;;
SAL;imm8=1;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m32 by 2, once.;;
SAL;r8=CL;m8/r8;;;;ModRM:r/m (r, w);;;;;D2;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, CL times.;;
SAL;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D2;/4;;;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m8 by 2, CL times.;In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SAL;r8=CL;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m16 by 2, CL times.;;
SAL;r8=CL;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/4;;;Valid;Valid;8086;;SAL;SHIFT;NA;Multiply r/m32 by 2, CL times.;;
SAL;r8=CL;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D3;/4;;;Valid;N.E.;8086;;SAL;SHIFT;NA;Multiply r/m64 by 2, CL times.;;
SAR;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;C0;/7;;ib;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2, imm8 time.;Not the same form of division as IDIV; rounding is toward negative infinity.
SAR;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;REX;C0;/7;;ib;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2, imm8 times.;Not the same form of division as IDIV; rounding is toward negative infinity. In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.
SAR;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/7;;ib;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m32 by 2,imm8 times.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/7;;ib;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m16 by 2,imm8 times.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;C1;/7;;ib;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m64 by 2,imm8 times;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;imm8=1;m8/r8;;;;ModRM:r/m (r, w);;;;;D0;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2,once.;Not the same form of division as IDIV; rounding is toward negative infinity.
SAR;imm8=1;m8/r8;;;;ModRM:r/m (r, w);;;;REX;D0;/7;;;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2, once.;Not the same form of division as IDIV; rounding is toward negative infinity. In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.
SAR;imm8=1;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D1;/7;;;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m64 by 2,once.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;imm8=1;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m32 by 2,once.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;imm8=1;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m16 by 2, once.;Not the same form of division as IDIV; rounding is toward negative infinity.
SAR;r8=CL;m8/r8;;;;ModRM:r/m (r, w);;;;;D2;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2, CL times.;Not the same form of division as IDIV; rounding is toward negative infinity.
SAR;r8=CL;m8/r8;;;;ModRM:r/m (r, w);;;;REX;D2;/7;;;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m8 by 2, CL times.;Not the same form of division as IDIV; rounding is toward negative infinity. In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.
SAR;r8=CL;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m16 by 2,CL times.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;r8=CL;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/7;;;Valid;Valid;8086;;SAR;SHIFT;NA;Signed divide* r/m32 by 2,CL times.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SAR;r8=CL;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D3;/7;;;Valid;N.E.;8086;;SAR;SHIFT;NA;Signed divide* r/m64 by 2,CL times.;* Not the same form of division as IDIV -  rounding is toward negative infinity.;
SBB;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (w);;;;REX;18;/r;;;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow r8 from r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SBB;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (w);;;;;18;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r8 from r/m8.;;
SBB;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;19;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r16 from r/m16.;;
SBB;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;19;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r32 from r/m32.;;
SBB;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W;19;/r;;;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow r64 from r/m64.;;
SBB;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (w);;;;REX;1A;/r;;;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow r/m8 from r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SBB;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (w);;;;;1A;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r/m8 from r8.;;
SBB;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;1B;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r/m16 from r16.;;
SBB;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W;1B;/r;;;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow r/m64 from r64.;;
SBB;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;1B;/r;;;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow r/m32 from r32.;;
SBB;imm8;r8=AL;;;imm8;;;;;;1C;;;ib;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow imm8 from AL.;;
SBB;imm16;r16=AX;;;imm16;;;;;REX.W0;1D;;;iw;Valid;Valid;8086;Legacy66;SBB;SBB;NA;Subtract with borrow imm16 from AX.;;
SBB;imm32;r64=RAX;;;imm32;;;;;REX.W;1D;;;id;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow sign- extended imm.32 to 64-bits from RAX.;;
SBB;imm32;r32=EAX;;;imm32;;;;;REX.W0;1D;;;id;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow imm32 from EAX.;;
SBB;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (w);;;;REX;80;/3;;ib;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow imm8 from r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SBB;imm8;m8/r8;;;imm8;ModRM:r/m (w);;;;;80;/3;;ib;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow imm8 from r/m8.;;
SBB;imm16;m16/r16;;;imm16;ModRM:r/m (w);;;;REX.W0;81;/3;;iw;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow imm16 from r/m16.;;
SBB;imm32;m32/r32;;;imm32;ModRM:r/m (w);;;;REX.W0;81;/3;;id;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow imm32 from r/m32.;;
SBB;imm32;m64/r64;;;imm32;ModRM:r/m (w);;;;REX.W;81;/3;;id;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow sign- extended imm32 to 64-bits from r/m64.;;
SBB;imm8;m64/r64;;;imm8;ModRM:r/m (w);;;;REX.W;83;/3;;ib;Valid;N.E.;8086;;SBB;SBB;NA;Subtract with borrow sign-extended imm8 from r/m64.;;
SBB;imm8;m32/r32;;;imm8;ModRM:r/m (w);;;;REX.W0;83;/3;;ib;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow sign-extended imm8 from r/m32.;;
SBB;imm8;m16/r16;;;imm8;ModRM:r/m (w);;;;REX.W0;83;/3;;ib;Valid;Valid;8086;;SBB;SBB;NA;Subtract with borrow sign-extended imm8 from r/m16.;;
SCAS;m8=(R)DI/ES:(E)DI;;;;;;;;;REX.W0;AE;;;;Valid;Valid;8086;;SCAS;SCAS;NA;Compare AL with byte at ES:(E)DI or RDI, then set status flags1.;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SCAS;m64=(R)DI/(E)DI;;;;;;;;;REX.W;AF;;;;Valid;N.E.;8086;;SCAS;SCAS;NA;Compare RAX with quadword at RDI or EDI then set status flags.;;
SCAS;m16=(R)DI/ES:(E)DI;;;;;;;;;REX.W0;AF;;;;Valid;Valid;8086;;SCAS;SCAS;NA;Compare AX with word at ES:(E)DI or RDI, then set status flags.a;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SCAS;m32=(R)DI/ES:(E)DI;;;;;;;;;REX.W0;AF;;;;Valid;Valid;8086;;SCAS;SCAS;NA;Compare EAX with doubleword at ES(E)DI or RDI then set status flags.a;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SCASB;;;;;;;;;;;AE;;;;Valid;Valid;8086;;SCASB;SCAS;NA;Compare AL with byte at ES:(E)DI or RDI then set status flags.a;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SCASD;;;;;;;;;;;AF;;;;Valid;Valid;8086;;SCASL;SCAS;NA;Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.a;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SCASQ;;;;;;;;;;REX.W;AF;;;;Valid;N.E.;8086;;SCASQ;SCAS;NA;Compare RAX with quadword at RDI or EDI then set status flags.;;
SCASW;;;;;;;;;;;AF;;;;Valid;Valid;8086;Legacy66;SCASW;SCAS;NA;Compare AX with word at ES:(E)DI or RDI then set status flags.a;1. In 64-bit mode, only 64-bit (RDI) and 32-bit (EDI) address sizes are supported. In non-64-bit mode, only 32-bit (EDI) and 16-bit (DI) address sizes are supported.;
SETA;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 97;/0;;;Valid;N.E.;8086;;SETA;SET;NA;Set byte if above (CF=0 and ZF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETA;m8/r8;;;;ModRM:r/m (r);;;;;;0F 97;/0;;;Valid;Valid;8086;;SETA;SET;NA;Set byte if above (CF=0 and ZF=0).;;
SETAE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 93;/0;;;Valid;Valid;8086;;SETAE;SET;NA;Set byte if above or equal (CF=0).;;
SETAE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 93;/0;;;Valid;N.E.;8086;;SETAE;SET;NA;Set byte if above or equal (CF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETB;m8/r8;;;;ModRM:r/m (r);;;;;;0F 92;/0;;;Valid;Valid;8086;;SETB;SET;NA;Set byte if below (CF=1).;;
SETB;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 92;/0;;;Valid;N.E.;8086;;SETB;SET;NA;Set byte if below (CF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETBE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 96;/0;;;Valid;N.E.;8086;;SETBE;SET;NA;Set byte if below or equal (CF=1 or ZF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETBE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 96;/0;;;Valid;Valid;8086;;SETBE;SET;NA;Set byte if below or equal (CF=1 or ZF=1).;;
SETC;m8/r8;;;;ModRM:r/m (r);;;;;;0F 92;/0;;;Valid;Valid;8086;;SETC;SET;NA;Set byte if carry (CF=1).;;
SETC;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 92;/0;;;Valid;N.E.;8086;;SETC;SET;NA;Set byte if carry (CF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 94;/0;;;Valid;Valid;8086;;SETE;SET;NA;Set byte if equal (ZF=1).;;
SETE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 94;/0;;;Valid;N.E.;8086;;SETE;SET;NA;Set byte if equal (ZF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETG;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9F;/0;;;Valid;N.E.;8086;;SETG;SET;NA;Set byte if greater (ZF=0 and SF=OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETG;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9F;/0;;;Valid;Valid;8086;;SETG;SET;NA;Set byte if greater (ZF=0 and SF=OF).;;
SETGE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9D;/0;;;Valid;Valid;8086;;SETGE;SET;NA;Set byte if greater or equal (SF=OF).;;
SETGE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9D;/0;;;Valid;N.E.;8086;;SETGE;SET;NA;Set byte if greater or equal (SF=OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9C;/0;;;Valid;N.E.;8086;;SETL;SET;NA;Set byte if less (SF≠ OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETL;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9C;/0;;;Valid;Valid;8086;;SETL;SET;NA;Set byte if less (SF≠ OF).;;
SETLE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9E;/0;;;Valid;Valid;8086;;SETLE;SET;NA;Set byte if less or equal (ZF=1 or SF≠ OF).;;
SETLE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9E;/0;;;Valid;N.E.;8086;;SETLE;SET;NA;Set byte if less or equal (ZF=1 or SF≠ OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNA;m8/r8;;;;ModRM:r/m (r);;;;;;0F 96;/0;;;Valid;Valid;8086;;SETNA;SET;NA;Set byte if not above (CF=1 or ZF=1).;;
SETNA;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 96;/0;;;Valid;N.E.;8086;;SETNA;SET;NA;Set byte if not above (CF=1 or ZF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNAE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 92;/0;;;Valid;N.E.;8086;;SETNAE;SET;NA;Set byte if not above or equal (CF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNAE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 92;/0;;;Valid;Valid;8086;;SETNAE;SET;NA;Set byte if not above or equal (CF=1).;;
SETNB;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 93;/0;;;Valid;N.E.;8086;;SETNB;SET;NA;Set byte if not below (CF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNB;m8/r8;;;;ModRM:r/m (r);;;;;;0F 93;/0;;;Valid;Valid;8086;;SETNB;SET;NA;Set byte if not below (CF=0).;;
SETNBE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 97;/0;;;Valid;N.E.;8086;;SETNBE;SET;NA;Set byte if not below or equal (CF=0 and ZF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNBE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 97;/0;;;Valid;Valid;8086;;SETNBE;SET;NA;Set byte if not below or equal (CF=0 and ZF=0).;;
SETNC;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 93;/0;;;Valid;N.E.;8086;;SETNC;SET;NA;Set byte if not carry (CF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNC;m8/r8;;;;ModRM:r/m (r);;;;;;0F 93;/0;;;Valid;Valid;8086;;SETNC;SET;NA;Set byte if not carry (CF=0).;;
SETNE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 95;/0;;;Valid;N.E.;8086;;SETNE;SET;NA;Set byte if not equal (ZF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 95;/0;;;Valid;Valid;8086;;SETNE;SET;NA;Set byte if not equal (ZF=0).;;
SETNG;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9E;/0;;;Valid;N.E.;8086;;SETNG;SET;NA;Set byte if not greater (ZF=1 or SF≠ OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNG;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9E;/0;;;Valid;Valid;8086;;SETNG;SET;NA;Set byte if not greater (ZF=1 or SF≠ OF);;
SETNGE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9C;/0;;;Valid;Valid;8086;;SETNGE;SET;NA;Set byte if not greater or equal (SF≠ OF).;;
SETNGE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9C;/0;;;Valid;N.E.;8086;;SETNGE;SET;NA;Set byte if not greater or equal (SF≠ OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9D;/0;;;Valid;N.E.;8086;;SETNL;SET;NA;Set byte if not less (SF=OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNL;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9D;/0;;;Valid;Valid;8086;;SETNL;SET;NA;Set byte if not less (SF=OF).;;
SETNLE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9F;/0;;;Valid;N.E.;8086;;SETNLE;SET;NA;Set byte if not less or equal (ZF=0 and SF=OF).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNLE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9F;/0;;;Valid;Valid;8086;;SETNLE;SET;NA;Set byte if not less or equal (ZF=0 and SF=OF).;;
SETNO;m8/r8;;;;ModRM:r/m (r);;;;;;0F 91;/0;;;Valid;Valid;8086;;SETNO;SET;NA;Set byte if not overflow (OF=0).;;
SETNO;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 91;/0;;;Valid;N.E.;8086;;SETNO;SET;NA;Set byte if not overflow (OF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNP;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9B;/0;;;Valid;N.E.;8086;;SETNP;SET;NA;Set byte if not parity (PF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNP;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9B;/0;;;Valid;Valid;8086;;SETNP;SET;NA;Set byte if not parity (PF=0).;;
SETNS;m8/r8;;;;ModRM:r/m (r);;;;;;0F 99;/0;;;Valid;Valid;8086;;SETNS;SET;NA;Set byte if not sign (SF=0).;;
SETNS;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 99;/0;;;Valid;N.E.;8086;;SETNS;SET;NA;Set byte if not sign (SF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETNZ;m8/r8;;;;ModRM:r/m (r);;;;;;0F 95;/0;;;Valid;Valid;8086;;SETNZ;SET;NA;Set byte if not zero (ZF=0).;;
SETNZ;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 95;/0;;;Valid;N.E.;8086;;SETNZ;SET;NA;Set byte if not zero (ZF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETO;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 90;/0;;;Valid;N.E.;8086;;SETO;SET;NA;Set byte if overflow (OF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETO;m8/r8;;;;ModRM:r/m (r);;;;;;0F 90;/0;;;Valid;Valid;8086;;SETO;SET;NA;Set byte if overflow (OF=1);;
SETP;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9A;/0;;;Valid;N.E.;8086;;SETP;SET;NA;Set byte if parity (PF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETP;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9A;/0;;;Valid;Valid;8086;;SETP;SET;NA;Set byte if parity (PF=1).;;
SETPE;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9A;/0;;;Valid;N.E.;8086;;SETPE;SET;NA;Set byte if parity even (PF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETPE;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9A;/0;;;Valid;Valid;8086;;SETPE;SET;NA;Set byte if parity even (PF=1).;;
SETPO;m8/r8;;;;ModRM:r/m (r);;;;;;0F 9B;/0;;;Valid;Valid;8086;;SETPO;SET;NA;Set byte if parity odd (PF=0).;;
SETPO;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 9B;/0;;;Valid;N.E.;8086;;SETPO;SET;NA;Set byte if parity odd (PF=0).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETS;m8/r8;;;;ModRM:r/m (r);;;;;;0F 98;/0;;;Valid;Valid;8086;;SETS;SET;NA;Set byte if sign (SF=1).;;
SETS;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 98;/0;;;Valid;N.E.;8086;;SETS;SET;NA;Set byte if sign (SF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SETZ;m8/r8;;;;ModRM:r/m (r);;;;;;0F 94;/0;;;Valid;Valid;8086;;SETZ;SET;NA;Set byte if zero (ZF=1).;;
SETZ;m8/r8<>[ABCD]H;;;;ModRM:r/m (r);;;;;REX;0F 94;/0;;;Valid;N.E.;8086;;SETZ;SET;NA;Set byte if zero (ZF=1).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SFENCE;;;;;;;;;;;0F AE F8;;;;Valid;Valid;8086;;SFENCE;SFENCE;NA;Serializes store operations.;;
SGDT;m;;;;ModRM:r/m (w);;;;;REX.W0;0F 01;/0;;;Valid;Valid;8086;;SGDT;SGDT;NA;Store GDTR to m.;;
SHL;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;C0;/4;;ib;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, imm8 times.;;
SHL;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;C0;/4;;ib;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, imm8 times.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHL;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/4;;ib;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m16 by 2, imm8 times.;;
SHL;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;C1;/4;;ib;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m64 by 2, imm8 times.;;
SHL;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/4;;ib;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m32 by 2, imm8 times.;;
SHL;imm8=1;m8/r8;;;;ModRM:r/m (r, w);;;;;D0;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, once.;;
SHL;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D0;/4;;;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, once.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHL;imm8=1;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m16 by 2, once.;;
SHL;imm8=1;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m32 by 2, once.;;
SHL;imm8=1;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D1;/4;;;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m64 by 2, once.;;
SHL;r8=CL;m8/r8;;;;ModRM:r/m (r, w);;;;;D2;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, CL times.;;
SHL;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D2;/4;;;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m8 by 2, CL times.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHL;r8=CL;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D3;/4;;;Valid;N.E.;8086;;SHL;SHIFT;NA;Multiply r/m64 by 2, CL times.;;
SHL;r8=CL;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m16 by 2, CL times.;;
SHL;r8=CL;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/4;;;Valid;Valid;8086;;SHL;SHIFT;NA;Multiply r/m32 by 2, CL times.;;
SHLD;imm8;r16;m16/r16;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F A4;/r;;ib;Valid;Valid;8086;;SHLD;SHIFT;NA;Shift r/m16 to left imm8 places while shifting bits from r16 in from the right.;;
SHLD;imm8;r64;m64/r64;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W;0F A4;/r;;ib;Valid;N.E.;8086;;SHLD;SHIFT;NA;Shift r/m64 to left imm8 places while shifting bits from r64 in from the right.;;
SHLD;imm8;r32;m32/r32;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F A4;/r;;ib;Valid;Valid;8086;;SHLD;SHIFT;NA;Shift r/m32 to left imm8 places while shifting bits from r32 in from the right.;;
SHLD;r8=CL;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F A5;/r;;;Valid;Valid;8086;;SHLD;SHIFT;NA;Shift r/m16 to left CL places while shifting bits from r16 in from the right.;;
SHLD;r8=CL;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W;0F A5;/r;;;Valid;N.E.;8086;;SHLD;SHIFT;NA;Shift r/m64 to left CL places while shifting bits from r64 in from the right.;;
SHLD;r8=CL;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F A5;/r;;;Valid;Valid;8086;;SHLD;SHIFT;NA;Shift r/m32 to left CL places while shifting bits from r32 in from the right.;;
SHR;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;C0;/5;;ib;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, imm8 times.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHR;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;C0;/5;;ib;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, imm8 times.;;
SHR;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;C1;/5;;ib;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m64 by 2, imm8 times.;;
SHR;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/5;;ib;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m32 by 2, imm8 times.;;
SHR;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;C1;/5;;ib;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m16 by 2, imm8 times.;;
SHR;imm8=1;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D0;/5;;;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, once.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHR;imm8=1;m8/r8;;;;ModRM:r/m (r, w);;;;;D0;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, once.;;
SHR;imm8=1;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m16 by 2, once.;;
SHR;imm8=1;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D1;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m32 by 2, once.;;
SHR;imm8=1;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D1;/5;;;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m64 by 2, once.;;
SHR;r8=CL;m8/r8;;;;ModRM:r/m (r, w);;;;;D2;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, CL times.;;
SHR;r8=CL;m8/r8<>[ABCD]H;;;;ModRM:r/m (r, w);;;;REX;D2;/5;;;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m8 by 2, CL times.;** In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SHR;r8=CL;m32/r32;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m32 by 2, CL times.;;
SHR;r8=CL;m64/r64;;;;ModRM:r/m (r, w);;;;REX.W;D3;/5;;;Valid;N.E.;8086;;SHR;SHIFT;NA;Unsigned divide r/m64 by 2, CL times.;;
SHR;r8=CL;m16/r16;;;;ModRM:r/m (r, w);;;;REX.W0;D3;/5;;;Valid;Valid;8086;;SHR;SHIFT;NA;Unsigned divide r/m16 by 2, CL times;;
SHRD;imm8;r64;m64/r64;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W;0F AC;/r;;ib;Valid;N.E.;8086;;SHRD;SHIFT;NA;Shift r/m64 to right imm8 places while shifting bits from r64 in from the left.;;
SHRD;imm8;r16;m16/r16;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F AC;/r;;ib;Valid;Valid;8086;;SHRD;SHIFT;NA;Shift r/m16 to right imm8 places while shifting bits from r16 in from the left.;;
SHRD;imm8;r32;m32/r32;;imm8;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F AC;/r;;ib;Valid;Valid;8086;;SHRD;SHIFT;NA;Shift r/m32 to right imm8 places while shifting bits from r32 in from the left.;;
SHRD;r8=CL;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W;0F AD;/r;;;Valid;N.E.;8086;;SHRD;SHIFT;NA;Shift r/m64 to right CL places while shifting bits from r64 in from the left.;;
SHRD;r8=CL;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F AD;/r;;;Valid;Valid;8086;;SHRD;SHIFT;NA;Shift r/m32 to right CL places while shifting bits from r32 in from the left.;;
SHRD;r8=CL;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (w);;;REX.W0;0F AD;/r;;;Valid;Valid;8086;;SHRD;SHIFT;NA;Shift r/m16 to right CL places while shifting bits from r16 in from the left.;;
SHUFPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;66;REX.W0;0F C6;/r;;ib;Valid;Valid;SSE2;;SHUFPD;SHUFFLE;NA;Shuffle packed double-precision floating-point values selected by imm8 from xmm1 and xmm2/m128 to xmm1.;;
SHUFPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r, w);;;REX.W0;0F C6;/r;;ib;Valid;Valid;SSE;;SHUFPS;SHUFFLE;NA;Shuffle packed single-precision floating-point values selected by imm8 from xmm1 and xmm1/m128 to xmm1.;;
SIDT;m;;;;ModRM:r/m (w);;;;;REX.W0;0F 01;/1;;;Valid;Valid;8086;;SIDT;SDT;NA;Store IDTR to m.;;
SLDT;r64/m16;;;;ModRM:r/m (w);;;;;REX.W;0F 00;/0;;;Valid;Valid;8086;;SLDT;SDT;NA;Stores segment selector from LDTR in r64/m16.;;
SLDT;m16/r16;;;;ModRM:r/m (w);;;;;REX.W0;0F 00;/0;;;Valid;Valid;8086;;SLDT;SDT;NA;Stores segment selector from LDTR in r/m16.;;
SMSW;r32/m16;;;;ModRM:r/m (w);;;;;REX.W0;0F 01;/4;;;Valid;Valid;8086;Legacy-3;SMSW;SMSW;NA;Store machine status word in low-order 16 bits of r32/m16 high-order 16 bits of r32 are undefined.;;
SMSW;r64/m16;;;;ModRM:r/m (w);;;;;REX.W;0F 01;/4;;;Valid;Valid;8086;;SMSW;SMSW;NA;Store machine status word in low-order 16 bits of r64/m16 high-order 16 bits of r32 are undefined.;;
SMSW;m16/r16;;;;ModRM:r/m (w);;;;;REX.W0;0F 01;/4;;;Valid;Valid;8086;Legacy66;SMSW;SMSW;NA;Store machine status word to r/m16.;;
SQRTPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;66;REX.W0;0F 51;/r;;;Valid;Valid;SSE2;;SQRTPD;SQRT;NA;Computes square roots of the packed double-precision floating-point values in xmm2/m128 and stores the results in xmm1.;;
SQRTPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;REX.W0;0F 51;/r;;;Valid;Valid;SSE;;SQRTPS;SQRT;NA;Computes square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1.;;
SQRTSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F2;REX.W0;0F 51;/r;;;Valid;Valid;SSE2;;SQRTSD;SQRT;NA;Computes square root of the low double-precision floating-point value in xmm2/m64 and stores the results in xmm1.;;
SQRTSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;F3;REX.W0;0F 51;/r;;;Valid;Valid;SSE;;SQRTSS;SQRT;NA;Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1.;;
STC;;;;;;;;;;;F9;;;;Valid;Valid;8086;;STC;ST;NA;Set CF flag.;;
STD;;;;;;;;;;;FD;;;;Valid;Valid;8086;;STD;ST;NA;Set DF flag.;;
STI;;;;;;;;;;;FB;;;;Valid;Valid;8086;;STI;ST;NA;Set interrupt flag external, maskable interrupts enabled at the end of the next instruction.;;
STMXCSR;m32;;;;ModRM:r/m (w);;;;;;0F AE;/3;;;Valid;Valid;SSE;;STMXCSR;ST;NA;Store contents of MXCSR register to m32.;;
STOS;m8=(R)DI;;;;;;;;;REX.W0;AA;;;;Valid;Valid;8086;;STOS;STOS;NA;For legacy mode, store AL at address ES:(E)DI+ For 64-bit mode store AL at address RDI or EDI.;;
STOS;m32=(R)DI;;;;;;;;;REX.W0;AB;;;;Valid;Valid;8086;;STOS;STOS;NA;For legacy mode, store EAX at address ES:(E)DI+ For 64-bit mode store EAX at address RDI or EDI.;;
STOS;m16=(R)DI;;;;;;;;;REX.W0;AB;;;;Valid;Valid;8086;;STOS;STOS;NA;For legacy mode, store AX at address ES:(E)DI+ For 64-bit mode store AX at address RDI or EDI.;;
STOS;m64=(E)DI;;;;;;;;;REX.W;AB;;;;Valid;N.E.;8086;;STOS;STOS;NA;Store RAX at address RDI or EDI.;;
STOSB;;;;;;;;;;;AA;;;;Valid;Valid;8086;;STOSB;STOS;NA;For legacy mode, store AL at address ES:(E)DI+ For 64-bit mode store AL at address RDI or EDI.;;
STOSD;;;;;;;;;;;AB;;;;Valid;Valid;8086;;STOSL;STOS;NA;For legacy mode, store EAX at address ES:(E)DI+ For 64-bit mode store EAX at address RDI or EDI.;;
STOSQ;;;;;;;;;;REX.W;AB;;;;Valid;N.E.;8086;;STOSQ;STOS;NA;Store RAX at address RDI or EDI.;;
STOSW;;;;;;;;;;;AB;;;;Valid;Valid;8086;Legacy66;STOSW;STOS;NA;For legacy mode, store AX at address ES:(E)DI+ For 64-bit mode store AX at address RDI or EDI.;;
STR;m16/r16;;;;ModRM:r/m (w);;;;;REX.W0;0F 00;/1;;;Valid;Valid;8086;;STR;STR;NA;Stores segment selector from TR in r/m16.;;
SUB;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;28;/r;;;Valid;N.E.;8086;;SUB;SUB;NA;Subtract r8 from r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SUB;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;28;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r8 from r/m8.;;
SUB;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;29;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r32 from r/m32.;;
SUB;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;29;/r;;;Valid;N.E.;8086;;SUB;SUB;NA;Subtract r64 from r/m64.;;
SUB;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;29;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r16 from r/m16.;;
SUB;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;2A;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r/m8 from r8.;;
SUB;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;2A;/r;;;Valid;N.E.;8086;;SUB;SUB;NA;Subtract r/m8 from r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SUB;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;2B;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r/m32 from r32.;;
SUB;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;2B;/r;;;Valid;Valid;8086;;SUB;SUB;NA;Subtract r/m16 from r16.;;
SUB;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;2B;/r;;;Valid;N.E.;8086;;SUB;SUB;NA;Subtract r/m64 from r64.;;
SUB;imm8;r8=AL;;;imm8;;;;;;2C;;;ib;Valid;Valid;8086;;SUB;SUB;NA;Subtract imm8 from AL.;;
SUB;imm16;r16=AX;;;imm16;;;;;REX.W0;2D;;;iw;Valid;Valid;8086;Legacy66;SUB;SUB;NA;Subtract imm16 from AX.;;
SUB;imm32;r32=EAX;;;imm32;;;;;REX.W0;2D;;;id;Valid;Valid;8086;;SUB;SUB;NA;Subtract imm32 from EAX.;;
SUB;imm32;r64=RAX;;;imm32;;;;;REX.W;2D;;;id;Valid;N.E.;8086;;SUB;SUB;NA;Subtract imm32 sign-extended to 64-bits from RAX.;;
SUB;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/5;;ib;Valid;N.E.;8086;;SUB;SUB;NA;Subtract imm8 from r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
SUB;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/5;;ib;Valid;Valid;8086;;SUB;SUB;NA;Subtract imm8 from r/m8.;;
SUB;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/5;;iw;Valid;Valid;8086;;SUB;SUB;NA;Subtract imm16 from r/m16.;;
SUB;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/5;;id;Valid;Valid;8086;;SUB;SUB;NA;Subtract imm32 from r/m32.;;
SUB;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/5;;id;Valid;N.E.;8086;;SUB;SUB;NA;Subtract imm32 sign- extended to 64-bits from r/m64.;;
SUB;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/5;;ib;Valid;Valid;8086;;SUB;SUB;NA;Subtract sign-extended imm8 from r/m32.;;
SUB;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/5;;ib;Valid;N.E.;8086;;SUB;SUB;NA;Subtract sign-extended imm8 from r/m64.;;
SUB;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/5;;ib;Valid;Valid;8086;;SUB;SUB;NA;Subtract sign-extended imm8 from r/m16.;;
SUBPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 5C;/r;;;Valid;Valid;SSE2;;SUBPD;SUB;NA;Subtract packed double-precision floating-point values in xmm2/m128 from xmm1.;;
SUBPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 5C;/r;;;Valid;Valid;SSE;;SUBPS;SUB;NA;Subtract packed single-precision floating-point values in xmm2/mem from xmm1.;;
SUBSD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F2;REX.W0;0F 5C;/r;;;Valid;Valid;SSE2;;SUBSD;SUB;NA;Subtracts the low double-precision floating-point values in xmm2/mem64 from xmm1.;;
SUBSS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;F3;REX.W0;0F 5C;/r;;;Valid;Valid;SSE;;SUBSS;SUB;NA;Subtract the lower single-precision floating-point values in xmm2/m32 from xmm1.;;
SWAPGS;;;;;;;;;;;0F 01 F8;;;;Valid;Invalid;8086;;SWAPGS;SWAPGS;NA;Exchanges the current GS base register value with the value contained in MSR address C0000102H.;;
SYSCALL;;;;;;;;;;;0F 05;;;;Valid;Invalid;8086;;SYSCALL;SYSCALL;NA;Fast call to privilege level 0 system procedures.;;
SYSENTER;;;;;;;;;;;0F 34;;;;Valid;Valid;8086;;SYSENTER;SYSCALL;NA;Fast call to privilege level 0 system procedures.;;
SYSEXIT;;;;;;;;;;REX.W0;0F 35;;;;Valid;Valid;8086;;SYSEXIT;SYSCALL;NA;Fast return to privilege level 3 user code.;;
SYSEXIT;;;;;;;;;;REX.W;0F 35;;;;Valid;Valid;8086;;SYSEXIT;SYSCALL;NA;Fast return to 64-bit mode privilege level 3 user code.;;
SYSRET;;;;;;;;;;;0F 07;;;;Valid;Invalid;8086;;SYSRET;SYSCALL;NA;Return from fast system call;;
TEST;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r);;;;;84;/r;;;Valid;Valid;8086;;TEST;CMP;NA;AND r8 with r/m8+ set SF, ZF, PF according to result.;;
TEST;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r);;;;REX;84;/r;;;Valid;N.E.;8086;;TEST;CMP;NA;AND r8 with r/m8+ set SF, ZF, PF according to result.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
TEST;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W;85;/r;;;Valid;N.E.;8086;;TEST;CMP;NA;AND r64 with r/m64+ set SF, ZF, PF according to result.;;
TEST;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W0;85;/r;;;Valid;Valid;8086;;TEST;CMP;NA;AND r32 with r/m32+ set SF, ZF, PF according to result.;;
TEST;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r);;;;REX.W0;85;/r;;;Valid;Valid;8086;;TEST;CMP;NA;AND r16 with r/m16+ set SF, ZF, PF according to result.;;
TEST;imm8;r8=AL;;;imm8;;;;;;A8;;;ib;Valid;Valid;8086;;TEST;CMP;NA;AND imm8 with AL+ set SF,ZF, PF according to result.;;
TEST;imm16;r16=AX;;;imm16;;;;;REX.W0;A9;;;iw;Valid;Valid;8086;Legacy66;TEST;CMP;NA;AND imm16 with AX+ set SF, ZF, PF according to result.;;
TEST;imm32;r64=RAX;;;imm32;;;;;REX.W;A9;;;id;Valid;N.E.;8086;;TEST;CMP;NA;AND imm32 sign-extended to 64-bits with RAX+ set SF, ZF, PF according to result.;;
TEST;imm32;r32=EAX;;;imm32;;;;;REX.W0;A9;;;id;Valid;Valid;8086;;TEST;CMP;NA;AND imm32 with EAX+ set SF, ZF, PF according to result.;;
TEST;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r);;;;REX;F6;/0;;ib;Valid;N.E.;8086;;TEST;CMP;NA;AND imm8 with r/m8+ set SF, ZF, PF according to result.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
TEST;imm8;m8/r8;;;imm8;ModRM:r/m (r);;;;;F6;/0;;ib;Valid;Valid;8086;;TEST;CMP;NA;AND imm8 with r/m8+ set SF, ZF, PF according to result.;;
TEST;imm16;m16/r16;;;imm16;ModRM:r/m (r);;;;REX.W0;F7;/0;;iw;Valid;Valid;8086;;TEST;CMP;NA;AND imm16 with r/m16+ set SF, ZF, PF according to result.;;
TEST;imm32;m32/r32;;;imm32;ModRM:r/m (r);;;;REX.W0;F7;/0;;id;Valid;Valid;8086;;TEST;CMP;NA;AND imm32 with r/m32+ set SF, ZF, PF according to result.;;
TEST;imm32;m64/r64;;;imm32;ModRM:r/m (r);;;;REX.W;F7;/0;;id;Valid;N.E.;8086;;TEST;CMP;NA;AND imm32 sign-extended to 64-bits with r/m64+ set SF, ZF, PF according to result.;;
UCOMISD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;66;REX.W0;0F 2E;/r;;;Valid;Valid;SSE2;;UCOMISD;UCMP;NA;Compares (unordered) the low double-precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS accordingly.;;
UCOMISS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;REX.W0;0F 2E;/r;;;Valid;Valid;SSE;;UCOMISS;UCMP;NA;Compare lower single-precision floating-point value in xmm1 register with lower single-precision floating-point value in xmm2/mem and set the status flags accordingly.;;
UD2;;;;;;;;;;;0F 0B;;;;Valid;Valid;8086;;UD2;UD;NA;Raise invalid opcode exception.;;
UNPCKHPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 15;/r;;;Valid;Valid;SSE2;;UNPCKHPD;UNPCK;NA;Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128.;;
UNPCKHPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 15;/r;;;Valid;Valid;SSE;;UNPCKHPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/mem into xmm1.;;
UNPCKLPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 14;/r;;;Valid;Valid;SSE2;;UNPCKLPD;UNPCK;NA;Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128.;;
UNPCKLPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 14;/r;;;Valid;Valid;SSE;;UNPCKLPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/mem into xmm1.;;
VADDPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDPD;ADD;NA;Add packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VADDPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDPD;ADD;NA;Add packed double-precision floating-point values from ymm3 mem to ymm2 and stores result in ymm1.;;
VADDPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDPS;ADD;NA;Add packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VADDPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDPS;ADD;NA;Add packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.;;
VADDSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDSD;ADD;NA;Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.;;
VADDSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;58;/r;;;Valid;Valid;AVX;;VADDSS;ADD;NA;Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.;;
VADDSUBPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D0;/r;;;Valid;Valid;AVX;;VADDSUBPD;ADD;NA;Add/subtract packed double-precision floating- point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VADDSUBPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;D0;/r;;;Valid;Valid;AVX;;VADDSUBPD;ADD;NA;Add/subtract packed double-precision floating- point values from ymm3/mem to ymm2 and stores result in ymm1.;;
VADDSUBPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.F2.0F.WIG;D0;/r;;;Valid;Valid;AVX;;VADDSUBPS;ADD;NA;Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VADDSUBPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.F2.0F.WIG;D0;/r;;;Valid;Valid;AVX;;VADDSUBPS;ADD;NA;Add/subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.;;
VAESDEC;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;DE;/r;;;Valid;Valid;AES_AVX;;VAESDEC;UNDEF;NA;Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher;;
VAESDECLAST;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;DF;/r;;;Valid;Valid;AES_AVX;;VAESDECLAST;UNDEF;NA;Perform the last round of AES decryption flow, using the Equivalent Inverse Cipher;;
VAESENC;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;DC;/r;;;Valid;Valid;AES_AVX;;VAESENC;UNDEF;NA;Perform one round of an AES encryption flow,  operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1.;
VAESENCLAST;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;DD;/r;;;Valid;Valid;AES_AVX;;VAESENCLAST;UNDEF;NA;Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1.;
VAESIMC;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;DB;/r;;;Valid;Valid;AES_AVX;;VAESIMC;UNDEF;NA;Perform the InvMixColumn transformation on a 128-bitround key from xmm2/m128 and store the result in xmm1.;;
VAESKEYGENASSIST;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F3A.WIG;DF;/r;;ib;Valid;Valid;AES_AVX;;VAESKEYGENASSIST;UNDEF;NA;Assist in AES round key generation using 8 bits RoundConstant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.;;
VANDNPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;55;/r;;;Valid;Valid;AVX;;VANDNPD;AND;NA;Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem.;;
VANDNPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;55;/r;;;Valid;Valid;AVX;;VANDNPD;AND;NA;Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem.;;
VANDNPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;55;/r;;;Valid;Valid;AVX;;VANDNPS;AND;NA;Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem.;;
VANDNPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;55;/r;;;Valid;Valid;AVX;;VANDNPS;AND;NA;Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem.;;
VANDPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;54;/r;;;Valid;Valid;AVX;;VANDPD;XOR;NA;Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem.;;
VANDPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;54;/r;;;Valid;Valid;AVX;;VANDPD;XOR;NA;Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem.;;
VANDPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;54;/r;;;Valid;Valid;AVX;;VANDPS;XOR;NA;Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem.;;
VANDPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;54;/r;;;Valid;Valid;AVX;;VANDPS;XOR;NA;Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem.;;
VBLENDPD;imm8;xmm/m128;xmm;xmm;imm8[3:0];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;0D;/r;;ib;Valid;Valid;AVX;;VBLENDPD;UNDEF;NA;Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.;;
VBLENDPD;imm8;ymm/m256;ymm;ymm;imm8[3:0];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.WIG;0D;/r;;ib;Valid;Valid;AVX;;VBLENDPD;UNDEF;NA;Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.;;
VBLENDPS;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;0C;/r;;ib;Valid;Valid;AVX;;VBLENDPS;UNDEF;NA;Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.;;
VBLENDPS;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.WIG;0C;/r;;ib;Valid;Valid;AVX;;VBLENDPS;UNDEF;NA;Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.;;
VBLENDVPD;xmm;xmm/m128;xmm;xmm;imm8[7:4];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W0;4B;/r;;/is4;Valid;Valid;AVX;;VBLENDVPD;UNDEF;NA;Conditionally copy double-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand;;
VBLENDVPD;ymm;ymm/m256;ymm;ymm;imm8[7:4];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.W0;4B;/r;;/is4;Valid;Valid;AVX;;VBLENDVPD;UNDEF;NA;Conditionally copy double-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand;;
VBLENDVPS;xmm;xmm/m128;xmm;xmm;imm8[7:4];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W0;4A;/r;;/is4;Valid;Valid;AVX;;VBLENDVPS;UNDEF;NA;Conditionally copy single-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand;;
VBLENDVPS;ymm;ymm/m256;ymm;ymm;imm8[7:4];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.W0;4A;/r;;/is4;Valid;Valid;AVX;;VBLENDVPS;UNDEF;NA;Conditionally copy single-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register;;
VBROADCASTF128;m128;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F38.W0;1A;/r;;;Valid;Valid;AVX;;VBROADCASTF128;UNDEF;NA;Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1.;;
VBROADCASTSD;m64;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F38.W0;19;/r;;;Valid;Valid;AVX;;VBROADCASTSD;UNDEF;NA;Broadcast double-precision floating-point element in mem to four locations in ymm1.;;
VBROADCASTSS;m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.W0;18;/r;;;N.E;Valid;AVX;;VBROADCASTSS;UNDEF;NA;Broadcast single-precision floating-point element in mem to four locations in xmm1.;;
VBROADCASTSS;m32;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F38.W0;18;/r;;;Valid;Valid;AVX;;VBROADCASTSS;UNDEF;NA;Broadcast single-precision floating-point element in mem to eight locations in ymm1.;;
VCMPPD;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPPD;CMP;NA;Compare packed double-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.;;
VCMPPD;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPPD;CMP;NA;Compare packed double-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.;;
VCMPPS;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPPS;CMP;NA;Compare packed single-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate.;;
VCMPPS;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPPS;CMP;NA;Compare packed single-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate.;;
VCMPSD;imm8;xmm/m64;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.LIG.F2.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPSD;CMP;NA;Compare low doubleprecision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate.;;
VCMPSS;imm8;xmm/m32;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.LIG.F3.0F.WIG;C2;/r;;ib;Valid;Valid;AVX;;VCMPSS;CMP;NA;Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate.;;
VCOMISD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.LIG.66.0F.WIG;2F;/r;;;Valid;Valid;AVX;;VCOMISD;CMP;NA;Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.;;
VCOMISS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.LIG.0F.WIG;2F;/r;;;Valid;Valid;AVX;;VCOMISS;CMP;NA;Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.;;
VCVTDQ2PD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F3.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTDQ2PD;CONVERT;NA;Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1.;;
VCVTDQ2PD;xmm/m128;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F3.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTDQ2PD;CONVERT;NA;Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floating-point values in ymm1.;;
VCVTDQ2PS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTDQ2PS;CONVERT;NA;Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1.;;
VCVTDQ2PS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTDQ2PS;CONVERT;NA;Convert eight packed signed doubleword integers from ymm2/mem to eight packed single-precision floating-point values in ymm1.;;
VCVTPD2DQ;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F2.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTPD2DQ;CONVERT;NA;Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1.;;
VCVTPD2DQ;ymm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F2.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTPD2DQ;CONVERT;NA;Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1.;;
VCVTPD2PS;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTPD2PS;CONVERT;NA;Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating point values in xmm1.;;
VCVTPD2PS;ymm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTPD2PS;CONVERT;NA;Convert four packed double-precision floating-point values in ymm2/mem to four single-precision floating-point values in xmm1.;;
VCVTPS2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTPS2DQ;CONVERT;NA;Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1.;;
VCVTPS2DQ;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTPS2DQ;CONVERT;NA;Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1.;;
VCVTPS2PD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTPS2PD;CONVERT;NA;Convert two packed single-precision floating-point values in xmm2/mem to two  packed double-precision floating-point values in xmm1.;;
VCVTPS2PD;xmm/m128;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTPS2PD;CONVERT;NA;Convert four packed single-precision floating-point values in xmm2/mem to four packed double-precision floating-point values in ymm1.;;
VCVTSD2SI;xmm/m64;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F2.0F.W0;2D;/r;;;Valid;Valid;AVX;;VCVTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm1/m64 t one signed doubleword integer r32.;;
VCVTSD2SI;xmm/m64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F2.0F.W1;2D;/r;;;Valid;N.E;AVX;;VCVTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64.;;
VCVTSD2SS;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTSD2SS;CONVERT;NA;Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2.;;
VCVTSI2SD;m32/r32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.W0;2A;/r;;;Valid;Valid;AVX;;VCVTSI2SD;CONVERT;NA;Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1.;;
VCVTSI2SD;m64/r64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.W1;2A;/r;;;Valid;N.E;AVX;;VCVTSI2SD;CONVERT;NA;Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1.;;
VCVTSI2SS;m32/r32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.W0;2A;/r;;;Valid;Valid;AVX;;VCVTSI2SS;CONVERT;NA;Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1.;;
VCVTSI2SS;m64/r64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.W1;2A;/r;;;Valid;N.E;AVX;;VCVTSI2SS;CONVERT;NA;Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1.;;
VCVTSS2SD;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;5A;/r;;;Valid;Valid;AVX;;VCVTSS2SD;CONVERT;NA;Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2.;;
VCVTSS2SI;xmm/m32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F3.0F.W0;2D;/r;;;Valid;Valid;AVX;;VCVTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32.;;
VCVTSS2SI;xmm/m32;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F3.0F.W1;2D;/r;;;Valid;N.E;AVX;;VCVTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64.;;
VCVTTPD2DQ;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTTPD2DQ;CONVERT;NA;Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation.;;
VCVTTPD2DQ;ymm;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;E6;/r;;;Valid;Valid;AVX;;VCVTTPD2DQ;CONVERT;NA;Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation.;;
VCVTTPS2DQ;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F3.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTTPS2DQ;CONVERT;NA;Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation.;;
VCVTTPS2DQ;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F3.0F.WIG;5B;/r;;;Valid;Valid;AVX;;VCVTTPS2DQ;CONVERT;NA;Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation.;;
VCVTTSD2SI;xmm/m64;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F2.0F.W0;2C;/r;;;Valid;Valid;AVX;;VCVTTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation.;;
VCVTTSD2SI;xmm/m64;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F2.0F.W1;2C;/r;;;Valid;N.E;AVX;;VCVTTSD2SI;CONVERT;NA;Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation.;;
VCVTTSS2SI;xmm/m32;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F3.0F.W0;2C;/r;;;Valid;Valid;AVX;;VCVTTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation.;;
VCVTTSS2SI;xmm/m32;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F3.0F.W1;2C;/r;;;Valid;N.E;AVX;;VCVTTSS2SI;CONVERT;NA;Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation.;;
VDIVPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVPD;DIV;NA;Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.;;
VDIVPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVPD;DIV;NA;Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.;;
VDIVPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVPS;DIV;NA;Divide packed single-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem.;;
VDIVPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVPS;DIV;NA;Divide packed single-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem.;;
VDIVSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVSD;DIV;NA;Divide low double-precision floating point values in xmm2 by low double-precision floating-point value in xmm3/mem64.;;
VDIVSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;5E;/r;;;Valid;Valid;AVX;;VDIVSS;DIV;NA;Divide low single-precision floating point value in xmm2 by low single precision floating-point value in xmm3/m32.;;
VDPPD;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;41;/r;;ib;Valid;Valid;AVX;;VDPPD;UNDEF;NA;Selectively multiply packed DP floating-point values from xmm2 with packed DP floating-point values from xmm3, add and selectively store the packed DP floating-point values to xmm1.;;
VDPPS;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;40;/r;;ib;Valid;Valid;AVX;;VDPPS;UNDEF;NA;Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1.;;
VDPPS;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.WIG;40;/r;;ib;Valid;Valid;AVX;;VDPPS;UNDEF;NA;Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1.;;
VERR;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;0F 00;/4;;;Valid;Valid;8086;;VERR;VER;NA;Set ZF=1 if segment specified with r/m16 can be read.;;
VERW;m16/r16;;;;ModRM:r/m (r);;;;;REX.W0;0F 00;/5;;;Valid;Valid;8086;;VERW;VER;NA;Set ZF=1 if segment specified with r/m16 can be written.;;
VEXTRACTF128;imm8;ymm;xmm/m128;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.256.66.0F3A.W0;19;/r;;ib;Valid;Valid;AVX;;VEXTRACTF128;EXTRACTPS;NA;Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/mem.;;
VEXTRACTPS;imm8;xmm;m32/r32;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.128.66.0F3A.WIG;17;/r;;ib;Valid;Valid;AVX;;VEXTRACTPS;EXTRACTPS;NA;Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable.;;
VHADDPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;7C;/r;;;Valid;Valid;AVX;;VHADDPD;HADD;NA;Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem.;;
VHADDPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;7C;/r;;;Valid;Valid;AVX;;VHADDPD;HADD;NA;Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem.;;
VHADDPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.F2.0F.WIG;7C;/r;;;Valid;Valid;AVX;;VHADDPS;HADD;NA;Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem.;;
VHADDPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.F2.0F.WIG;7C;/r;;;Valid;Valid;AVX;;VHADDPS;HADD;NA;Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem.;;
VHSUBPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;7D;/r;;;Valid;Valid;AVX;;VHSUBPD;HSUB;NA;Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem.;;
VHSUBPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;7D;/r;;;Valid;Valid;AVX;;VHSUBPD;HSUB;NA;Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem.;;
VHSUBPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.F2.0F.WIG;7D;/r;;;Valid;Valid;AVX;;VHSUBPS;HSUB;NA;Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem.;;
VHSUBPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.F2.0F.WIG;7D;/r;;;Valid;Valid;AVX;;VHSUBPS;HSUB;NA;Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem.;;
VINSERTF128;imm8;xmm/m128;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.W0;18;/r;;ib;Valid;Valid;AVX;;VINSERTF128;UNDEF;NA;Insert a single precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.;;
VINSERTPS;imm8;xmm/m32;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;21;/r;;ib;Valid;Valid;AVX;;VINSERTPS;INSERTPS;NA;Insert a single precision floating point value selected by imm8 from xmm3/m32 and merge into xmm2 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8.;;
VLDDQU;m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F2.0F.WIG;F0;/r;;;Valid;Valid;AVX;;VLDDQU;LDQU;NA;Load unaligned packed integer values from mem to xmm1.;;
VLDDQU;m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F2.0F.WIG;F0;/r;;;Valid;Valid;AVX;;VLDDQU;LDQU;NA;Load unaligned packed integer values from mem to ymm1.;;
VLDMXCSR;m32;;;;ModRM:r/m (r);;;;;VEX.LZ.0F.WIG;AE;/2;;;Valid;Valid;AVX;;VLDMXCSR;LDMXCSR;NA;Load MXCSR register from m32.;;
VMASKMOVDQU;xmm;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.128.66.0F.WIG;F7;/r;;;Valid;Valid;AVX;;VMASKMOVDQU;MASKMOVQ;NA;Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI.;;
VMASKMOVPD;m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.W0;2D;/r;;;Valid;Valid;AVX;;VMASKMOVPD;MASKMOVQ;NA;Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1.;;
VMASKMOVPD;m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F38.W0;2D;/r;;;Valid;Valid;AVX;;VMASKMOVPD;MASKMOVQ;NA;Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1.;;
VMASKMOVPD;xmm;xmm;m128;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.128.66.0F38.W0;2F;/r;;;Valid;Valid;AVX;;VMASKMOVPD;MASKMOVQ;NA;Conditionally store packed double-precision values from xmm2 using mask in xmm1.;;
VMASKMOVPD;ymm;ymm;m256;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.256.66.0F38.W0;2F;/r;;;Valid;Valid;AVX;;VMASKMOVPD;MASKMOVQ;NA;Conditionally store packed double-precision values from ymm2 using mask in ymm1.;;
VMASKMOVPS;m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.W0;2C;/r;;;Valid;Valid;AVX;;VMASKMOVPS;MASKMOVQ;NA;Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1.;;
VMASKMOVPS;m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F38.W0;2C;/r;;;Valid;Valid;AVX;;VMASKMOVPS;MASKMOVQ;NA;Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1.;;
VMASKMOVPS;xmm;xmm;m128;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.128.66.0F38.W0;2E;/r;;;Valid;Valid;AVX;;VMASKMOVPS;MASKMOVQ;NA;Conditionally store packed single-precision values from xmm2 using mask in xmm1.;;
VMASKMOVPS;ymm;ymm;m256;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.256.66.0F38.W0;2E;/r;;;Valid;Valid;AVX;;VMASKMOVPS;MASKMOVQ;NA;Conditionally store packed single-precision values from ymm2 using mask in ymm1.;;
VMAXPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXPD;MAX;NA;Return the maximum double-precision floating-point values between xmm2 and xmm3/mem.;;
VMAXPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXPD;MAX;NA;Return the maximum packed double-precision floating-point values between ymm2 and ymm3/mem.;;
VMAXPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXPS;MAX;NA;Return the maximum single-precision floating-point values between xmm2 and xmm3/mem.;;
VMAXPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXPS;MAX;NA;Return the maximum single double-precision floating-point values between ymm2 and ymm3/mem.;;
VMAXSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXSD;MAX;NA;Return the maximum scalar double-precision floating-point value between xmm3/mem64 and xmm2.;;
VMAXSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;5F;/r;;;Valid;Valid;AVX;;VMAXSS;MAX;NA;Return the maximum scalar single-precision floating-point value between xmm3/mem32 and xmm2.;;
VMCALL;;;;;;;;;;;0F 01 C1;;;;Valid;Valid;VMX;;VMCALL;UNDEF;NA;Call to VM monitor by causing VM exit.;;
VMCLEAR;m64;;;;ModRM:r/m (r);;;;66;REX.W0;0F C7;/6;;;Valid;Valid;VMX;;VMCLEAR;UNDEF;NA;Copy VMCS data to VMCS region in memory.;;
VMINPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINPD;MIN;NA;Return the minimum double-precision floating-point values between xmm2 and xmm3/mem.;;
VMINPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINPD;MIN;NA;Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem.;;
VMINPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINPS;MIN;NA;Return the minimum single-precision floating-point values between xmm2 and xmm3/mem.;;
VMINPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINPS;MIN;NA;Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem.;;
VMINSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINSD;MIN;NA;Return the minimum scalar double precision floating-point value between xmm3/mem64 and xmm2.;;
VMINSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;5D;/r;;;Valid;Valid;AVX;;VMINSS;MIN;NA;Return the minimum scalar single precision floating-point value between xmm3/mem32 and xmm2.;;
VMLAUNCH;;;;;;;;;;;0F 01 C2;;;;Valid;Valid;VMX;;VMLAUNCH;UNDEF;NA;Launch virtual machine managed by current VMCS.;;
VMOVAPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;28;/r;;;Valid;Valid;AVX;;VMOVAPD;MOV;NA;Move aligned packed double-precision floating-point values from xmm2/mem to xmm1.;;
VMOVAPD;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;29;/r;;;Valid;Valid;AVX;;VMOVAPD;MOV;NA;Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem.;;
VMOVAPD;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;28;/r;;;Valid;Valid;AVX;;VMOVAPD;MOV;NA;Move aligned packed double-precision floating-point values from ymm2/mem to ymm1.;;
VMOVAPD;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.66.0F.WIG;29;/r;;;Valid;Valid;AVX;;VMOVAPD;MOV;NA;Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem.;;
VMOVAPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;28;/r;;;Valid;Valid;AVX;;VMOVAPS;MOV;NA;Move aligned packed single-precision floating-point values from xmm2/mem to xmm1.;;
VMOVAPS;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.0F.WIG;29;/r;;;Valid;Valid;AVX;;VMOVAPS;MOV;NA;Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem.;;
VMOVAPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;28;/r;;;Valid;Valid;AVX;;VMOVAPS;MOV;NA;Move aligned packed single-precision floating-point values from ymm2/mem to ymm1.;;
VMOVAPS;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.0F.WIG;29;/r;;;Valid;Valid;AVX;;VMOVAPS;MOV;NA;Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem.;;
VMOVD;m32/r32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.W0;6E;/r;;;Valid;Valid;AVX;;VMOVD;MOV;NA;Move doubleword from r/m32 to xmm1.;;
VMOVD;xmm;r32/m32;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.W0;7E;/r;;;Valid;Valid;AVX;;VMOVD;MOV;NA;Move doubleword from xmm1 register to r/m32.;;
VMOVDDUP;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F2.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVDDUP;MOV;NA;Move double-precision floating-point values from  xmm2/mem and duplicate into xmm1.;;
VMOVDDUP;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F2.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVDDUP;MOV;NA;Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1.;;
VMOVDQA;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;6F;/r;;;Valid;Valid;AVX;;VMOVDQA;MOV;NA;Move aligned packed integer values from xmm2/mem to xmm1.;;
VMOVDQA;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;7F;/r;;;Valid;Valid;AVX;;VMOVDQA;MOV;NA;Move aligned packed integer values from xmm1 to xmm2/mem.;;
VMOVDQA;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;6F;/r;;;Valid;Valid;AVX;;VMOVDQA;MOV;NA;Move aligned packed integer values from ymm2/mem to ymm1.;;
VMOVDQA;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.66.0F.WIG;7F;/r;;;Valid;Valid;AVX;;VMOVDQA;MOV;NA;Move aligned packed integer values from ymm1 to ymm2/mem.;;
VMOVDQU;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F3.0F.WIG;6F;/r;;;Valid;Valid;AVX;;VMOVDQU;MOV;NA;Move unaligned packed integer values from xmm2/mem to xmm1.;;
VMOVDQU;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.F3.0F.WIG;7F;/r;;;Valid;Valid;AVX;;VMOVDQU;MOV;NA;Move unaligned packed integer values from xmm1 to xmm2/mem.;;
VMOVDQU;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F3.0F.WIG;6F;/r;;;Valid;Valid;AVX;;VMOVDQU;MOV;NA;Move unaligned packed integer values from ymm2/mem to ymm1.;;
VMOVDQU;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.F3.0F.WIG;7F;/r;;;Valid;Valid;AVX;;VMOVDQU;MOV;NA;Move unaligned packed integer values from ymm1 to ymm2/mem.;;
VMOVHLPS;xmm;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVHLPS;MOV;NA;Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2.;;
VMOVHPD;m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;16;/r;;;Valid;Valid;AVX;;VMOVHPD;MOV;NA;Merge double-precision floating-point value from m64 and the low quadword of xmm1.;;
VMOVHPD;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;17;/r;;;Valid;Valid;AVX;;VMOVHPD;MOV;NA;Move double-precision floating-point values from high quadword of xmm1 to m64.;;
VMOVHPS;m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;16;/r;;;Valid;Valid;AVX;;VMOVHPS;MOV;NA;Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1.;;
VMOVHPS;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.0F.WIG;17;/r;;;Valid;Valid;AVX;;VMOVHPS;MOV;NA;Move two packed single-precision floating-point values from high quadword of xmm1to m64.;;
VMOVLHPS;xmm;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;16;/r;;;Valid;Valid;AVX;;VMOVLHPS;MOV;NA;Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2.;;
VMOVLPD;m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVLPD;MOV;NA;Merge double-precision floating-point value from m64 and the high quadword of xmm1.;;
VMOVLPD;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;13;/r;;;Valid;Valid;AVX;;VMOVLPD;MOV;NA;Move double-precision floating-point values from low quadword of xmm1 to m64.;;
VMOVLPS;m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVLPS;MOV;NA;Merge two packed single-precision floating-poin values from m64 and the high quadword of xmm1.;;
VMOVLPS;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.0F.WIG;13;/r;;;Valid;Valid;AVX;;VMOVLPS;MOV;NA;Move two packed single-precision floating-point values from low quadword of xmm1 to m64.;;
VMOVMSKPD;xmm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;50;/r;;;Valid;Valid;AVX;;VMOVMSKPD;MOV;NA;Extract 2-bit sign mask from xmm2 and store in r32. The upper bits of r32 are zeroed.;;
VMOVMSKPD;xmm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;50;/r;;;Valid;N.E;AVX;;VMOVMSKPD;MOV;NA;Extract 2-bit sign mask from xmm2 and store in r64. The upper bits of r64 are zeroed.;;
VMOVMSKPD;ymm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;50;/r;;;Valid;Valid;AVX;;VMOVMSKPD;MOV;NA;Extract 4-bit sign mask from ymm2 and store in r32. The upper bits of r32 are zeroed.;;
VMOVMSKPD;ymm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;50;/r;;;Valid;N.E;AVX;;VMOVMSKPD;MOV;NA;Extract 4-bit sign mask from ymm2 and store in r64. The upper bits of r64 are zeroed.;;
VMOVMSKPS;xmm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;50;/r;;;Valid;Valid;AVX;;VMOVMSKPS;MOV;NA;Extract 4-bit sign mask from xmm2 and store in r32. The upper bits of r32 are zeroed.;;
VMOVMSKPS;xmm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;50;/r;;;Valid;N.E;AVX;;VMOVMSKPS;MOV;NA;Extract 4-bit sign mask from xmm2 and store in r64. The upper bits of r64 are zeroed.;;
VMOVMSKPS;ymm;r32;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;50;/r;;;Valid;Valid;AVX;;VMOVMSKPS;MOV;NA;Extract 8-bit sign mask from ymm2 and store in r32. The upper bits of r32 are zeroed.;;
VMOVMSKPS;ymm;r64;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;50;/r;;;Valid;N.E;AVX;;VMOVMSKPS;MOV;NA;Extract 8-bit sign mask from ymm2 and store in r64. The upper bits of r64 are zeroed.;;
VMOVNTDQ;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;E7;/r;;;Valid;Valid;AVX;;VMOVNTDQ;MOV;NA;Move packed integer values in xmm1 to m128 using non-temporal hint.;;
VMOVNTDQ;ymm;m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.66.0F.WIG;E7;/r;;;Valid;Valid;AVX;;VMOVNTDQ;MOV;NA;Move packed integer values in ymm1 to m256 using non-temporal hint.;;
VMOVNTDQA;m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;2A;/r;;;Valid;Valid;AVX;;VMOVNTDQA;MOV;NA;Move double quadword from m128 to xmm using non-temporal hint if WC memory type.;;
VMOVNTPD;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;2B;/r;;;Valid;Valid;AVX;;VMOVNTPD;MOV;NA;Move packed double-precision values in xmm1 to m128 using non-temporal hint.;;
VMOVNTPD;ymm;m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.66.0F.WIG;2B;/r;;;Valid;Valid;AVX;;VMOVNTPD;MOV;NA;Move packed double-precision values in ymm1 to m256 using non-temporal hint.;;
VMOVNTPS;xmm;m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.0F.WIG;2B;/r;;;Valid;Valid;AVX;;VMOVNTPS;MOV;NA;Move packed single-precision values xmm1 to mem using non-temporal hint.;;
VMOVNTPS;ymm;m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.0F.WIG;2B;/r;;;Valid;Valid;AVX;;VMOVNTPS;MOV;NA;Move packed single-precision values ymm1 to mem using non-temporal hint.;;
VMOVQ;m64/r64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.W1;6E;/r;;;Valid;N.E;AVX;;VMOVQ;MOV;NA;Move quadword from r/m64 to xmm1.;;
VMOVQ;xmm;r64/m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.W1;7E;/r;;;Valid;N.E;AVX;;VMOVQ;MOV;NA;Move quadword from xmm1 register to r/m64.;;
VMOVSD;xmm;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVSD;MOV;NA;Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register.;;
VMOVSD;m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F2.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVSD;MOV;NA;Load scalar double-precision floating-point value from m64 to xmm1 register.;;
VMOVSD;xmm;xmm;xmm;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.LIG.F2.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVSD;MOV;NA;Merge scalar double-precision floating-poin value from xmm2 and xmm3 registers to xmm1.;;
VMOVSD;xmm;m64;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.LIG.F2.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVSD;MOV;NA;Move scalar double-precision floating-point value from xmm1 register to m64.;;
VMOVSHDUP;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F3.0F.WIG;16;/r;;;Valid;Valid;AVX;;VMOVSHDUP;MOV;NA;Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.;;
VMOVSHDUP;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F3.0F.WIG;16;/r;;;Valid;Valid;AVX;;VMOVSHDUP;MOV;NA;Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.;;
VMOVSLDUP;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.F3.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVSLDUP;MOV;NA;Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1.;;
VMOVSLDUP;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.F3.0F.WIG;12;/r;;;Valid;Valid;AVX;;VMOVSLDUP;MOV;NA;Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1.;;
VMOVSS;xmm;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVSS;MOV;NA;Merge scalar singleprecision floating-point value from xmm2 and xmm3 to xmm1 register.;;
VMOVSS;m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.LIG.F3.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVSS;MOV;NA;Load scalar single-precision floating-point value from m32 to xmm1 register.;;
VMOVSS;xmm;xmm;xmm;;ModRM:reg (r);VEX.vvvv (r);ModRM:r/m (w);;;VEX.NDS.LIG.F3.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVSS;MOV;NA;Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register.;;
VMOVSS;xmm;m32;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.LIG.F3.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVSS;MOV;NA;Move scalar single-precision floating-point value from xmm1 register to m32.;;
VMOVUPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVUPD;MOV;NA;Move unaligned packed double-precision floatingpoint from xmm2/mem to xmm1.;;
VMOVUPD;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVUPD;MOV;NA;Move unaligned packed double-precision floating-point from ymm2/mem to ymm1.;;
VMOVUPD;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.66.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVUPD;MOV;NA;Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem.;;
VMOVUPD;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.66.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVUPD;MOV;NA;Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem.;;
VMOVUPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVUPS;MOV;NA;Move unaligned packed single-precision floating-point from xmm2/mem to xmm1.;;
VMOVUPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;10;/r;;;Valid;Valid;AVX;;VMOVUPS;MOV;NA;Move unaligned packed single-precision floating-point from ymm2/mem to ymm1.;;
VMOVUPS;xmm;xmm/m128;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.128.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVUPS;MOV;NA;Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem.;;
VMOVUPS;ymm;ymm/m256;;;ModRM:reg (r);ModRM:r/m (w);;;;VEX.256.0F.WIG;11;/r;;;Valid;Valid;AVX;;VMOVUPS;MOV;NA;Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem.;;
VMPSADBW;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;42;/r;;ib;Valid;Valid;AVX;;VMPSADBW;UNDEF;NA;Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8.;;
VMPTRLD;m64;;;;ModRM:r/m (r);;;;;REX.W0;0F C7;/6;;;Valid;Valid;VMX;;VMPTRLD;UNDEF;NA;Loads the current VMCS pointer from memory.;;
VMPTRST;m64;;;;ModRM:r/m (r);;;;;REX.W0;0F C7;/7;;;Valid;Valid;VMX;;VMPTRST;UNDEF;NA;Stores the current VMCS pointer into memory.;;
VMREAD;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 78;/r;;;Valid;Invalid;VMX;;VMREAD;UNDEF;NA;Reads a specified VMCS field (in 64-bit mode).;;
VMREAD;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (w);;;;REX.W0;0F 78;/r;;;Invalid;Valid;VMX;;VMREAD;UNDEF;NA;Reads a specified VMCS field (outside 64-bit mode).;;
VMRESUME;;;;;;;;;;;0F 01 C3;;;;Valid;Valid;VMX;;VMRESUME;UNDEF;NA;Resume virtual machine managed by current VMCS.;;
VMULPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULPD;UNDEF;NA;Multiply packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VMULPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULPD;UNDEF;NA;Multiply packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.;;
VMULPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULPS;UNDEF;NA;Multiply packed single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.;;
VMULPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULPS;UNDEF;NA;Multiply packed single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1;;
VMULSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULSD;UNDEF;NA;Multiply the low double-precision floating-point value in xmm3/mem64 by low double precision floating-point value in xmm2.;;
VMULSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;59;/r;;;Valid;Valid;AVX;;VMULSS;UNDEF;NA;Multiply the low single-precision floating-point value in xmm3/mem by the low single-precision floating-point value in xmm2.;;
VMWRITE;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r);;;;REX.W0;0F 79;/r;;;Valid;Invalid;VMX;;VMWRITE;UNDEF;NA;Writes.a specified VMCS field (in 64-bit mode);;
VMWRITE;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r);;;;REX.W0;0F 79;/r;;;Invalid;Valid;VMX;;VMWRITE;UNDEF;NA;Writes.a specified VMCS field (outside 64-bit mode);;
VMXOFF;;;;;;;;;;;0F 01 C4;;;;Valid;Valid;VMX;;VMXOFF;UNDEF;NA;Leaves VMX operation.;;
VMXON;m64;;;;ModRM:r/m (r);;;;F3;REX.W0;0F C7;/6;;;Valid;Valid;VMX;;VMXON;UNDEF;NA;Enter VMX root operation.;;
VORPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;56;/r;;;Valid;Valid;AVX;;VORPD;OR;NA;Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem.;;
VORPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;56;/r;;;Valid;Valid;AVX;;VORPD;OR;NA;Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem.;;
VORPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;56;/r;;;Valid;Valid;AVX;;VORPS;OR;NA;Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem.;;
VORPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;56;/r;;;Valid;Valid;AVX;;VORPS;OR;NA;Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem.;;
VPABSB;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;1C;/r;;;Valid;Valid;AVX;;VPABSB;PABS;NA;Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1.;;
VPABSD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;1E;/r;;;Valid;Valid;AVX;;VPABSD;PABS;NA;Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.;;
VPABSW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;1D;/r;;;Valid;Valid;AVX;;VPABSW;PABS;NA;Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1.;;
VPACKSSDW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;6B;/r;;;Valid;Valid;AVX;;VPACKSSDW;PACK;NA;Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation.;;
VPACKSSWB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;63;/r;;;Valid;Valid;AVX;;VPACKSSWB;PACK;NA;Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation.;;
VPACKUSDW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;2B;/r;;;Valid;Valid;AVX;;VPACKUSDW;PACK;NA;Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation.;;
VPACKUSWB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;67;/r;;;Valid;Valid;AVX;;VPACKUSWB;PACK;NA;Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation.;;
VPADDB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;FC;/r;;;Valid;Valid;AVX;;VPADDB;PADD;NA;Add packed byte integers from xmm3/m128 and xmm2.;;
VPADDD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;FE;/r;;;Valid;Valid;AVX;;VPADDD;PADD;NA;Add packed doubleword integers from xmm3/m128 and xmm2.;;
VPADDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D4;/r;;;Valid;Valid;AVX;;VPADDQ;PADD;NA;Add packed quadword integers xmm3/m128 and xmm2.;;
VPADDSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;EC;/r;;;Valid;Valid;AVX;;VPADDSB;PADD;NA;Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results.;;
VPADDSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;ED;/r;;;Valid;Valid;AVX;;VPADDSW;PADD;NA;Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results.;;
VPADDUSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DC;/r;;;Valid;Valid;AVX;;VPADDUSB;PADD;NA;Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results.;;
VPADDUSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DD;/r;;;Valid;Valid;AVX;;VPADDUSW;PADD;NA;Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results.;;
VPADDW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;FD;/r;;;Valid;Valid;AVX;;VPADDW;PADD;NA;Add packed word integers from xmm3/m128 and xmm2.;;
VPALIGNR;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;0F;/r;;ib;Valid;Valid;AVX;;VPALIGNR;ALIGNR;NA;Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1.;;
VPAND;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DB;/r;;;Valid;Valid;AVX;;VPAND;PAND;NA;Bitwise AND of xmm3/m128 and xmm.;;
VPANDN;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DF;/r;;;Valid;Valid;AVX;;VPANDN;PAND;NA;Bitwise AND NOT of xmm3/m128 and xmm2.;;
VPAVGB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E0;/r;;;Valid;Valid;AVX;;VPAVGB;PAVG;NA;Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding.;;
VPAVGW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E3;/r;;;Valid;Valid;AVX;;VPAVGW;PAVG;NA;Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding.;;
VPBLENDVB;xmm;xmm/m128;xmm;xmm;imm8[7:4];ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W0;4C;/r;;/is4;Valid;Valid;AVX;;VPBLENDVB;UNDEF;NA;Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1.;;
VPBLENDW;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;0E;/r;;ib;Valid;Valid;AVX;;VPBLENDW;UNDEF;NA;Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1.;;
VPCLMULQDQ;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.WIG;44;/r;;ib;Valid;Valid;CLMUL_AVX;;VPCLMULQDQ;UNDEF;NA;Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used.;;
VPCMPEQB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;74;/r;;;Valid;Valid;AVX;;VPCMPEQB;CMP;NA;Compare packed bytes in xmm3/m128 and xmm2 for equality.;;
VPCMPEQD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;76;/r;;;Valid;Valid;AVX;;VPCMPEQD;CMP;NA;Compare packed doublewords in xmm3/m128 and xmm2 for equality.;;
VPCMPEQQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;29;/r;;;Valid;Valid;AVX;;VPCMPEQQ;CMP;NA;Compare packed quadwords in xmm3/m128 and xmm2 for equality.;;
VPCMPEQW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;75;/r;;;Valid;Valid;AVX;;VPCMPEQW;CMP;NA;Compare packed words in xmm3/m128 and xmm2 for equality.;;
VPCMPESTRI;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;;VEX.128.66.0F3A.W0;61;/r;;ib;Valid;Valid;AVX;;VPCMPESTRI;CMP;NA;Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX.;;
VPCMPESTRM;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;;VEX.128.66.0F3A.W0;60;/r;;ib;Valid;Valid;AVX;;VPCMPESTRM;CMP;NA;Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0.;;
VPCMPGTB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;64;/r;;;Valid;Valid;AVX;;VPCMPGTB;CMP;NA;Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than.;;
VPCMPGTD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;66;/r;;;Valid;Valid;AVX;;VPCMPGTD;CMP;NA;Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than.;;
VPCMPGTQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;37;/r;;;Valid;Valid;AVX;;VPCMPGTQ;CMP;NA;Compare packed signed qwords in xmm2 and xmm3/m128 for greater than.;;
VPCMPGTW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;65;/r;;;Valid;Valid;AVX;;VPCMPGTW;CMP;NA;Compare packed signed word integers in xmm2 and xmm3/m128 for greater than.;;
VPCMPISTRI;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;;VEX.128.66.0F3A.WIG;63;/r;;ib;Valid;Valid;AVX;;VPCMPISTRI;CMP;NA;Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX.;;
VPCMPISTRM;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (r);;;VEX.128.66.0F3A.WIG;62;/r;;ib;Valid;Valid;AVX;;VPCMPISTRM;CMP;NA;Perform a packed comparison of string data with implicit lengths generating a Mask, and storing the result in XMM0.;;
VPERM2F128;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F3A.W0;06;/r;;ib;Valid;Valid;AVX;;VPERM2F128;UNDEF;NA;Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1.;;
VPERMILPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.W0;0D;/r;;;Valid;Valid;AVX;;VPERMILPD;UNDEF;NA;Permute double-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.;;
VPERMILPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F38.W0;0D;/r;;;Valid;Valid;AVX;;VPERMILPD;UNDEF;NA;Permute double-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.;;
VPERMILPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F3A.W0;05;/r;;ib;Valid;Valid;AVX;;VPERMILPD;UNDEF;NA;Permute double-precision floating-point values in xmm2/mem using controls from imm8.;;
VPERMILPD;imm8;ymm/m256;ymm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.256.66.0F3A.W0;05;/r;;ib;Valid;Valid;AVX;;VPERMILPD;UNDEF;NA;Permute double-precision floating-point values in ymm2/mem using controls from imm8.;;
VPERMILPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.W0;0C;/r;;;Valid;Valid;AVX;;VPERMILPS;UNDEF;NA;Permute single-precision floating-point values in xmm2 using controls from xmm3/mem and store result in xmm1.;;
VPERMILPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F3A.W0;04;/r;;ib;Valid;Valid;AVX;;VPERMILPS;UNDEF;NA;Permute single-precision floating-point values in xmm2/mem using controls from imm8 and store result in xmm1.;;
VPERMILPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F38.W0;0C;/r;;;Valid;Valid;AVX;;VPERMILPS;UNDEF;NA;Permute single-precision floating-point values in ymm2 using controls from ymm3/mem and store result in ymm1.;;
VPERMILPS;imm8;ymm/m256;ymm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.256.66.0F3A.W0;04;/r;;ib;Valid;Valid;AVX;;VPERMILPS;UNDEF;NA;Permute single-precision floating-point values in ymm2/mem using controls from imm8 and store result in ymm1.;;
VPEXTRB;imm8;xmm;r32/m8;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.128.66.0F3A.W0;14;/r;;ib;Valid;Valid;AVX;;VPEXTRB;UNDEF;NA;Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros.;In 64-bit mode, VEX.W1 is ignored for VPEXTRB (similar to legacy REX.W=1 prefix in PEXTRB).;
VPEXTRD;imm8;xmm;r32/m32;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.128.66.0F3A.W0;16;/r;;ib;Valid;Valid;AVX;;VPEXTRD;UNDEF;NA;Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32.;;
VPEXTRQ;imm8;xmm;r64/m64;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.128.66.0F3A.W1;16;/r;;ib;Valid;N.E;AVX;;VPEXTRQ;UNDEF;NA;Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64.;;
VPEXTRW;imm8;xmm;r32;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F.W0;C5;/r;;ib;Valid;Valid;AVX;;VPEXTRW;UNDEF;NA;Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros.;In 64-bit mode, VEX.W1 is ignored for VPEXTRW (similar to legacy REX.W=1 prefix in PEXTRW).;
VPEXTRW;imm8;xmm;r32/m16;;imm8;ModRM:reg (r);ModRM:r/m (w);;;VEX.128.66.0F3A.W0;15;/r;;ib;Valid;Valid;AVX;;VPEXTRW;UNDEF;NA;Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros.;;
VPHADDD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;02;/r;;;Valid;Valid;AVX;;VPHADDD;PHADD;NA;Add 32-bit integers horizontally, pack to xmm1.;;
VPHADDSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;03;/r;;;Valid;Valid;AVX;;VPHADDSW;PHADD;NA;Add 16-bit signed integers horizontally, pack saturated integers to xmm1.;;
VPHADDW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;01;/r;;;Valid;Valid;AVX;;VPHADDW;PHADD;NA;Add 16-bit integers horizontally, pack to xmm1.;;
VPHMINPOSUW;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;41;/r;;;Valid;Valid;AVX;;VPHMINPOSUW;UNDEF;NA;Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1.;;
VPHSUBD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (r, w);;;VEX.NDS.128.66.0F38.WIG;06;/r;;;Valid;Valid;AVX;;VPHSUBD;PHSUB;NA;Subtract 32-bit signed integers horizontally, pack to xmm1.;;
VPHSUBSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (r, w);;;VEX.NDS.128.66.0F38.WIG;07;/r;;;Valid;Valid;AVX;;VPHSUBSW;PHSUB;NA;Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1.;;
VPHSUBW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (r, w);;;VEX.NDS.128.66.0F38.WIG;05;/r;;;Valid;Valid;AVX;;VPHSUBW;PHSUB;NA;Subtract 16-bit signed integers horizontally, pack to xmm1.;;
VPINSRB;imm8;r32/m8;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W0;20;/r;;ib;Valid;Valid;AVX;;VPINSRB;UNDEF;NA;Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8.;In 64-bit mode, VEX.W1 is ignored for VPINSRB (similar to legacy REX.W=1 prefix with PINSRB).;
VPINSRD;imm8;r32/m32;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W0;22;/r;;ib;Valid;Valid;AVX;;VPINSRD;UNDEF;NA;Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8.;;
VPINSRQ;imm8;r64/m64;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F3A.W1;22;/r;;ib;Valid;N.E;AVX;;VPINSRQ;UNDEF;NA;Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8.;;
VPINSRW;imm8;r32/m16;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F.W0;C4;/r;;ib;Valid;Valid;AVX;;VPINSRW;UNDEF;NA;Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8.;In 64-bit mode, VEX.W1 is ignored for VPINSRW (similar to legacy REX.W=1 prefix in PINSRW).;
VPMADDUBSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;04;/r;;;Valid;Valid;AVX;;VPMADDUBSW;PMADD;NA;Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1.;;
VPMADDWD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F5;/r;;;Valid;Valid;AVX;;VPMADDWD;PMADD;NA;Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1.;;
VPMAXSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3C;/r;;;Valid;Valid;AVX;;VPMAXSB;PMAX;NA;Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.;;
VPMAXSD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3D;/r;;;Valid;Valid;AVX;;VPMAXSD;PMAX;NA;Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.;;
VPMAXSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;EE;/r;;;Valid;Valid;AVX;;VPMAXSW;PMAX;NA;Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1.;;
VPMAXUB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DE;/r;;;Valid;Valid;AVX;;VPMAXUB;PMAX;NA;Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.;;
VPMAXUD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3F;/r;;;Valid;Valid;AVX;;VPMAXUD;PMAX;NA;Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1.;;
VPMAXUW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3E;/r;;;Valid;Valid;AVX;;VPMAXUW;PMAX;NA;Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1.;;
VPMINSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;38;/r;;;Valid;Valid;AVX;;VPMINSB;PMIN;NA;Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.;;
VPMINSD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;39;/r;;;Valid;Valid;AVX;;VPMINSD;PMIN;NA;Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.;;
VPMINSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;EA;/r;;;Valid;Valid;AVX;;VPMINSW;PMIN;NA;Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.;;
VPMINUB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;DA;/r;;;Valid;Valid;AVX;;VPMINUB;PMIN;NA;Compare packed unsigne byte integers in xmm2 an xmm3/m128 and store packed minimum values in xmm1.;;
VPMINUD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3B;/r;;;Valid;Valid;AVX;;VPMINUD;PMIN;NA;Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1.;;
VPMINUW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;3A;/r;;;Valid;Valid;AVX;;VPMINUW;PMIN;NA;Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1.;;
VPMOVMSKB;xmm;r32;;;ModRM:reg (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;D7;/r;;;Valid;Valid;AVX;;VPMOVMSKB;PMOV;NA;Move a byte mask of xmm1 to r32. The upper bits of r32 are filled with zeros.;;
VPMOVMSKB;xmm;r64;;;ModRM:reg (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;D7;/r;;;Valid;N.E;AVX;;VPMOVMSKB;PMOV;NA;Move a byte mask of xmm1 to r64. The upper bits of r64 are filled with zeros.;;
VPMOVSXBD;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;21;/r;;;Valid;Valid;AVX;;VPMOVSXBD;PMOV;NA;Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.;;
VPMOVSXBQ;xmm/m16;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;22;/r;;;Valid;Valid;AVX;;VPMOVSXBQ;PMOV;NA;Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.;;
VPMOVSXBW;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;20;/r;;;Valid;Valid;AVX;;VPMOVSXBW;PMOV;NA;Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.;;
VPMOVSXDQ;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;25;/r;;;Valid;Valid;AVX;;VPMOVSXDQ;PMOV;NA;Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.;;
VPMOVSXWD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;23;/r;;;Valid;Valid;AVX;;VPMOVSXWD;PMOV;NA;Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.;;
VPMOVSXWQ;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;24;/r;;;Valid;Valid;AVX;;VPMOVSXWQ;PMOV;NA;Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.;;
VPMOVZXBD;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;31;/r;;;Valid;Valid;AVX;;VPMOVZXBD;PMOV;NA;Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1.;;
VPMOVZXBQ;xmm/m16;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;32;/r;;;Valid;Valid;AVX;;VPMOVZXBQ;PMOV;NA;Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1.;;
VPMOVZXBW;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;30;/r;;;Valid;Valid;AVX;;VPMOVZXBW;PMOV;NA;Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1.;;
VPMOVZXDQ;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;35;/r;;;Valid;Valid;AVX;;VPMOVZXDQ;PMOV;NA;Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1.;;
VPMOVZXWD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;33;/r;;;Valid;Valid;AVX;;VPMOVZXWD;PMOV;NA;Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1.;;
VPMOVZXWQ;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F38.WIG;34;/r;;;Valid;Valid;AVX;;VPMOVZXWQ;PMOV;NA;Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1.;;
VPMULDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;28;/r;;;Valid;Valid;AVX;;VPMULDQ;PMUL;NA;Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1.;;
VPMULHRSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;0B;/r;;;Valid;Valid;AVX;;VPMULHRSW;PMUL;NA;Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1.;;
VPMULHUW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E4;/r;;;Valid;Valid;AVX;;VPMULHUW;PMUL;NA;Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.;;
VPMULHW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E5;/r;;;Valid;Valid;AVX;;VPMULHW;PMUL;NA;Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1.;;
VPMULLD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;40;/r;;;Valid;Valid;AVX;;VPMULLD;PMUL;NA;Multiply the packed dword signed integers in xmm2 and xmm3/m128 and stor the low 32 bits of each product in xmm1.;;
VPMULLW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D5;/r;;;Valid;Valid;AVX;;VPMULLW;PMUL;NA;Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1.;;
VPMULUDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F4;/r;;;Valid;Valid;AVX;;VPMULUDQ;PMUL;NA;Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1.;;
VPOR;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;EB;/r;;;Valid;Valid;AVX;;VPOR;OR;NA;Bitwise OR of xmm2/m128 and xmm3.;;
VPSADBW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F6;/r;;;Valid;Valid;AVX;;VPSADBW;PSADBW;NA;Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results.;
VPSHUFB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;00;/r;;;Valid;Valid;AVX;;VPSHUFB;PSHUF;NA;Shuffle bytes in xmm2 according to contents of xmm3/m128.;;
VPSHUFD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F.WIG;70;/r;;ib;Valid;Valid;AVX;;VPSHUFD;PSHUF;NA;Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
VPSHUFHW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.F3.0F.WIG;70;/r;;ib;Valid;Valid;AVX;;VPSHUFHW;PSHUF;NA;Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
VPSHUFLW;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.F2.0F.WIG;70;/r;;ib;Valid;Valid;AVX;;VPSHUFLW;PSHUF;NA;Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1.;;
VPSIGNB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;08;/r;;;Valid;Valid;AVX;;VPSIGNB;PSIGN;NA;Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128.;;
VPSIGND;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;0A;/r;;;Valid;Valid;AVX;;VPSIGND;PSIGN;NA;Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128.;;
VPSIGNW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F38.WIG;09;/r;;;Valid;Valid;AVX;;VPSIGNW;PSIGN;NA;Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128.;;
VPSLLD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F2;/r;;;Valid;Valid;AVX;;VPSLLD;PSLL;NA;Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.;;
VPSLLD;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;72;/6;;ib;Valid;Valid;AVX;;VPSLLD;PSLL;NA;Shift doublewords in xmm2 left by imm8 while shifting in 0s.;;
VPSLLDQ;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;73;/7;;ib;Valid;Valid;AVX;;VPSLLDQ;PSLL;NA;Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1.;;
VPSLLQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F3;/r;;;Valid;Valid;AVX;;VPSLLQ;PSLL;NA;Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s.;;
VPSLLQ;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;73;/6;;ib;Valid;Valid;AVX;;VPSLLQ;PSLL;NA;Shift quadwords in xmm2 left by imm8 while shifting in 0s.;;
VPSLLW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F1;/r;;;Valid;Valid;AVX;;VPSLLW;PSLL;NA;Shift words in xmm2 left b amount specified in xmm3/m128 while shifting in 0s.;;
VPSLLW;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;71;/6;;ib;Valid;Valid;AVX;;VPSLLW;PSLL;NA;Shift words in xmm2 left by imm8 while shifting in 0s.;;
VPSRAD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E2;/r;;;Valid;Valid;AVX;;VPSRAD;PSHR;NA;Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.;;
VPSRAD;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;72;/4;;ib;Valid;Valid;AVX;;VPSRAD;PSHR;NA;Shift doublewords in xmm2 right by imm8 while shifting in sign bits.;;
VPSRAW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E1;/r;;;Valid;Valid;AVX;;VPSRAW;PSHR;NA;Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits.;;
VPSRAW;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;71;/4;;ib;Valid;Valid;AVX;;VPSRAW;PSHR;NA;Shift words in xmm2 right by imm8 while shifting in sign bits.;;
VPSRLD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D2;/r;;;Valid;Valid;AVX;;VPSRLD;PSHR;NA;Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.;;
VPSRLD;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;72;/2;;ib;Valid;Valid;AVX;;VPSRLD;PSHR;NA;Shift doublewords in xmm2 right by imm8 while shifting in 0s.;;
VPSRLDQ;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;73;/3;;ib;Valid;Valid;AVX;;VPSRLDQ;PSHR;NA;Shift xmm2 right by imm8 bytes while shifting in 0s.;;
VPSRLQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D3;/r;;;Valid;Valid;AVX;;VPSRLQ;PSHR;NA;Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.;;
VPSRLQ;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;73;/2;;ib;Valid;Valid;AVX;;VPSRLQ;PSHR;NA;Shift quadwords in xmm2 right by imm8 while shifting in 0s.;;
VPSRLW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D1;/r;;;Valid;Valid;AVX;;VPSRLW;PSHR;NA;Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s.;;
VPSRLW;imm8;xmm;xmm;;imm8;ModRM:r/m (r);VEX.vvvv (w);;;VEX.NDD.128.66.0F.WIG;71;/2;;ib;Valid;Valid;AVX;;VPSRLW;PSHR;NA;Shift words in xmm2 right by imm8 while shifting in 0s.;;
VPSUBB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F8;/r;;;Valid;Valid;AVX;;VPSUBB;PSUB;NA;Subtract packed byte integers in xmm3/m128 from xmm2.;;
VPSUBD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;FA;/r;;;Valid;Valid;AVX;;VPSUBD;PSUB;NA;Subtract packed doubleword integers in xmm3/m128 from xmm2.;;
VPSUBQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;FB;/r;;;Valid;Valid;AVX;;VPSUBQ;PSUB;NA;Subtract packed quadword integers in xmm3/m128 from xmm2.;;
VPSUBSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E8;/r;;;Valid;Valid;AVX;;VPSUBSB;PSUB;NA;Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results.;;
VPSUBSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;E9;/r;;;Valid;Valid;AVX;;VPSUBSW;PSUB;NA;Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results.;;
VPSUBUSB;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D8;/r;;;Valid;Valid;AVX;;VPSUBUSB;PSUB;NA;Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result.;;
VPSUBUSW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;D9;/r;;;Valid;Valid;AVX;;VPSUBUSW;PSUB;NA;Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result.;;
VPSUBW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;F9;/r;;;Valid;Valid;AVX;;VPSUBW;PSUB;NA;Subtract packed word integers in xmm3/m128 from xmm2.;;
VPTEST;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.128.66.0F38.WIG;17;/r;;;Valid;Valid;AVX;;VPTEST;UNDEF;NA;Set ZF and CF depending on bitwise AND and ANDN of sources.;;
VPTEST;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.256.66.0F38.WIG;17;/r;;;Valid;Valid;AVX;;VPTEST;UNDEF;NA;Set ZF and CF depending on bitwise AND and ANDN of sources.;;
VPUNPCKHBW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;68;/r;;;Valid;Valid;AVX;;VPUNPCKHBW;PUNPCK;NA;Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1.;;
VPUNPCKHDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;6A;/r;;;Valid;Valid;AVX;;VPUNPCKHDQ;PUNPCK;NA;Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1.;;
VPUNPCKHQDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;6D;/r;;;Valid;Valid;AVX;;VPUNPCKHQDQ;PUNPCK;NA;Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register.;;
VPUNPCKHWD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;69;/r;;;Valid;Valid;AVX;;VPUNPCKHWD;PUNPCK;NA;Interleave high-order words from xmm2 and xmm3/m128 into xmm1.;;
VPUNPCKLBW;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;60;/r;;;Valid;Valid;AVX;;VPUNPCKLBW;PUNPCK;NA;Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1.;;
VPUNPCKLDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;62;/r;;;Valid;Valid;AVX;;VPUNPCKLDQ;PUNPCK;NA;Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1.;;
VPUNPCKLQDQ;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;6C;/r;;;Valid;Valid;AVX;;VPUNPCKLQDQ;PUNPCK;NA;Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register.;;
VPUNPCKLWD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;61;/r;;;Valid;Valid;AVX;;VPUNPCKLWD;PUNPCK;NA;Interleave low-order words from xmm2 and xmm3/m128 into xmm1.;;
VPXOR;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;EF;/r;;;Valid;Valid;AVX;;VPXOR;XOR;NA;Bitwise XOR of xmm3/m128 and xmm2.;;
VRCPPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;53;/r;;;Valid;Valid;AVX;;VRCPPS;RCP;NA;Computes the approximate reciprocals of packed single-precision values in xmm2/mem and stores the results in xmm1.;;
VRCPPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;53;/r;;;Valid;Valid;AVX;;VRCPPS;RCP;NA;Computes the approximate reciprocals of packed single-precision values in ymm2/mem and stores the results in ymm1.;;
VRCPSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;53;/r;;;Valid;Valid;AVX;;VRCPSS;RCP;NA;Computes the approximate reciprocal of the scalar single-precision floating- point value in xmm3/m32 and stores the result in xmm1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].;;
VROUNDPD;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F3A.WIG;09;/r;;ib;Valid;Valid;AVX;;VROUNDPD;UNDEF;NA;Round packed double-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.;;
VROUNDPD;imm8;ymm/m256;ymm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.256.66.0F3A.WIG;09;/r;;ib;Valid;Valid;AVX;;VROUNDPD;UNDEF;NA;Round packed double-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.;;
VROUNDPS;imm8;xmm/m128;xmm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.128.66.0F3A.WIG;08;/r;;ib;Valid;Valid;AVX;;VROUNDPS;UNDEF;NA;Round packed single-precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by imm8.;;
VROUNDPS;imm8;ymm/m256;ymm;;imm8;ModRM:r/m (r);ModRM:reg (w);;;VEX.256.66.0F3A.WIG;08;/r;;ib;Valid;Valid;AVX;;VROUNDPS;UNDEF;NA;Round packed single-precision floating-point values in ymm2/m256 and place the result in ymm1. The rounding mode is determined by imm8.;;
VROUNDSD;imm8;xmm/m64;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.LIG.66.0F3A.WIG;0B;/r;;ib;Valid;Valid;AVX;;VROUNDSD;UNDEF;NA;Round the low packed double precision floating-point value in xmm3/m64 and place the result in xmm1. The rounding mode is determined by imm8. Upper packed double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].;;
VROUNDSS;imm8;xmm/m32;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.LIG.66.0F3A.WIG;0A;/r;;ib;Valid;Valid;AVX;;VROUNDSS;UNDEF;NA;Round the low packed single-precision floating-point value in xmm3/m32 and place the result in xmm1. The rounding mode is determined by imm8. Also, upper packed single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].;;
VRSQRTPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;52;/r;;;Valid;Valid;AVX;;VRSQRTPS;RSQRT;NA;Computes the approximate reciprocals of the square roots of packed single-precision values in xmm2/mem and stores the results in xmm1.;;
VRSQRTPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;52;/r;;;Valid;Valid;AVX;;VRSQRTPS;RSQRT;NA;Computes the approximate reciprocals of the square roots of packed single-precision values in ymm2/mem and stores the results in ymm1.;;
VRSQRTSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;52;/r;;;Valid;Valid;AVX;;VRSQRTSS;RSQRT;NA;Computes the approximate reciprocal of the square root of the low single precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].;;
VSHUFPD;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.66.0F.WIG;C6;/r;;ib;Valid;Valid;AVX;;VSHUFPD;SHUFFLE;NA;Shuffle Packed double-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.;;
VSHUFPD;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.66.0F.WIG;C6;/r;;ib;Valid;Valid;AVX;;VSHUFPD;SHUFFLE;NA;Shuffle Packed double-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.;;
VSHUFPS;imm8;xmm/m128;xmm;xmm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.128.0F.WIG;C6;/r;;ib;Valid;Valid;AVX;;VSHUFPS;SHUFFLE;NA;Shuffle Packed single-precision floating-point values selected by imm8 from xmm2 and xmm3/mem.;;
VSHUFPS;imm8;ymm/m256;ymm;ymm;imm8;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;VEX.NDS.256.0F.WIG;C6;/r;;ib;Valid;Valid;AVX;;VSHUFPS;SHUFFLE;NA;Shuffle Packed single-precision floating-point values selected by imm8 from ymm2 and ymm3/mem.;;
VSQRTPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.66.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTPD;SQRT;NA;Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1.;;
VSQRTPD;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.66.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTPD;SQRT;NA;Computes Square Roots of the packed double-precision floating-point values in ymm2/m256 and stores the result in ymm1.;;
VSQRTPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.128.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTPS;SQRT;NA;Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1.;;
VSQRTPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (w);;;;VEX.256.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTPS;SQRT;NA;Computes Square Roots of the packed single-precision floating-point values in ymm2/m256 and stores the result in ymm1.;;
VSQRTSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTSD;SQRT;NA;Computes square root of the low double-precision floating point value in xmm3/m64 and stores the results in xmm2. Also, upper double precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64].;;
VSQRTSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;51;/r;;;Valid;Valid;AVX;;VSQRTSS;SQRT;NA;Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32].;;
VSTMXCSR;m32;;;;ModRM:r/m (w);;;;;VEX.LZ.0F.WIG;AE;/3;;;Valid;Valid;AVX;;VSTMXCSR;ST;NA;Store contents of MXCSR register to m32.;;
VSUBPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBPD;SUB;NA;Subtract packed double-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.;;
VSUBPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBPD;SUB;NA;Subtract packed double-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.;;
VSUBPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBPS;SUB;NA;Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1.;;
VSUBPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBPS;SUB;NA;Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1.;;
VSUBSD;xmm/m64;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F2.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBSD;SUB;NA;Subtract the low double-precision floating-point value in xmm3/mem from xmm2 and store the result in xmm1.;;
VSUBSS;xmm/m32;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.LIG.F3.0F.WIG;5C;/r;;;Valid;Valid;AVX;;VSUBSS;SUB;NA;Subtract the low single-precision floating-point value in xmm3/mem from xmm2 and store the result in xmm1.;;
VTESTPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.128.66.0F38.W0;0F;/r;;;Valid;Valid;AVX;;VTESTPD;CMP;NA;Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources.;;
VTESTPD;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.256.66.0F38.W0;0F;/r;;;Valid;Valid;AVX;;VTESTPD;CMP;NA;Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources.;;
VTESTPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.128.66.0F38.W0;0E;/r;;;Valid;Valid;AVX;;VTESTPS;CMP;NA;Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.;;
VTESTPS;ymm/m256;ymm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.256.66.0F38.W0;0E;/r;;;Valid;Valid;AVX;;VTESTPS;CMP;NA;Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources.;;
VUCOMISD;xmm/m64;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.LIG.66.0F.WIG;2E;/r;;;Valid;Valid;AVX;;VUCOMISD;UCMP;NA;Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly.;;
VUCOMISS;xmm/m32;xmm;;;ModRM:r/m (r);ModRM:reg (r);;;;VEX.LIG.0F.WIG;2E;/r;;;Valid;Valid;AVX;;VUCOMISS;UCMP;NA;Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly.;;
VUNPCKHPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;15;/r;;;Valid;Valid;AVX;;VUNPCKHPD;UNPCK;NA;Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128.;;
VUNPCKHPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;15;/r;;;Valid;Valid;AVX;;VUNPCKHPD;UNPCK;NA;Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256.;;
VUNPCKHPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;15;/r;;;Valid;Valid;AVX;;VUNPCKHPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128.;;
VUNPCKHPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;15;/r;;;Valid;Valid;AVX;;VUNPCKHPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256.;;
VUNPCKLPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;14;/r;;;Valid;Valid;AVX;;VUNPCKLPD;UNPCK;NA;Unpacks and Interleaves double precision floating-point values low high quadwords of xmm2 and xmm3/m128.;;
VUNPCKLPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;14;/r;;;Valid;Valid;AVX;;VUNPCKLPD;UNPCK;NA;Unpacks and Interleaves double precision floating-point values low high quadwords of ymm2 and ymm3/m256.;;
VUNPCKLPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;14;/r;;;Valid;Valid;AVX;;VUNPCKLPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128.;;
VUNPCKLPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;14;/r;;;Valid;Valid;AVX;;VUNPCKLPS;UNPCK;NA;Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256.;;
VXORPD;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.66.0F.WIG;57;/r;;;Valid;Valid;AVX;;VXORPD;XOR;NA;Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem.;;
VXORPD;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.66.0F.WIG;57;/r;;;Valid;Valid;AVX;;VXORPD;XOR;NA;Return the bitwise logical XOR of packed doubleprecision floating-point values in ymm2 and ymm3/mem.;;
VXORPS;xmm/m128;xmm;xmm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.128.0F.WIG;57;/r;;;Valid;Valid;AVX;;VXORPS;XOR;NA;Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem.;;
VXORPS;ymm/m256;ymm;ymm;;ModRM:r/m (r);VEX.vvvv (r);ModRM:reg (w);;;VEX.NDS.256.0F.WIG;57;/r;;;Valid;Valid;AVX;;VXORPS;XOR;NA;Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem.;;
VZEROALL;;;;;;;;;;VEX.256.0F.WIG;77;;;;Valid;Valid;AVX;;VZEROALL;UNDEF;NA;Zero all YMM registers.;;
VZEROUPPER;;;;;;;;;;VEX.128.0F.WIG;77;;;;Valid;Valid;AVX;;VZEROUPPER;UNDEF;NA;Zero upper 128 bits of all YMM registers.;;
WAIT;;;;;;;;;;;9B;;;;Valid;Valid;8086;;WAIT;UNDEF;NA;Check pending unmasked floating-point exceptions.;;
WBINVD;;;;;;;;;;;0F 09;;;;Valid;Valid;8086;;WBINVD;UNDEF;NA;Write back and flush Internal caches+ initiate writing-back and flushing of external caches.;;
WRMSR;;;;;;;;;;REX.W;0F 30;;;;Valid;N.E.;8086;;WRMSR;UNDEF;NA;Write the value in RDX[31:0]:RAX[31:0] to MSR specified by RCX.;;
WRMSR;;;;;;;;;;REX.W0;0F 30;;;;Valid;Valid;8086;;WRMSR;UNDEF;NA;Write the value in EDX:EAX to MSR specified by ECX.;;
XADD;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;0F C0;/r;;;Valid;N.E.;8086;;XADD;XADD;NA;Exchange r8 and r/m8+load sum into r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XADD;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;0F C0;/r;;;Valid;Valid;8086;;XADD;XADD;NA;Exchange r8 and r/m8+load sum into r/m8.;;
XADD;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F C1;/r;;;Valid;Valid;8086;;XADD;XADD;NA;Exchange r32 and r/m32+load sum into r/m32.;;
XADD;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;0F C1;/r;;;Valid;N.E.;8086;;XADD;XADD;NA;Exchange r64 and r/m64+load sum into r/m64.;;
XADD;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;0F C1;/r;;;Valid;Valid;8086;;XADD;XADD;NA;Exchange r16 and r/m16+load sum into r/m16.;;
XCHG;r8;m8/r8;;;ModRM:reg (r, w);ModRM:r/m (r, w);;;;;86;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange r8 (byte register) with byte from r/m8.;;
XCHG;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r, w);ModRM:reg (r, w);;;;REX;86;/r;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange byte from r/m8 with r8 (byte register).;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XCHG;m8/r8;r8;;;ModRM:r/m (r, w);ModRM:reg (r, w);;;;;86;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange byte from r/m8 with r8 (byte register).;;
XCHG;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r, w);ModRM:r/m (r, w);;;;REX;86;/r;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange r8 (byte register) with byte from r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XCHG;r64;m64/r64;;;ModRM:reg (r, w);ModRM:r/m (r, w);;;;REX.W;87;/r;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange r64 with quadword from r/m64.;;
XCHG;m32/r32;r32;;;ModRM:r/m (r, w);ModRM:reg (r, w);;;;REX.W0;87;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange doubleword from r/m32 with r32.;;
XCHG;m16/r16;r16;;;ModRM:r/m (r, w);ModRM:reg (r, w);;;;REX.W0;87;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange word from r/m16 with r16.;;
XCHG;m64/r64;r64;;;ModRM:r/m (r, w);ModRM:reg (r, w);;;;REX.W;87;/r;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange quadword from r/m64 with r64.;;
XCHG;r16;m16/r16;;;ModRM:reg (r, w);ModRM:r/m (r, w);;;;REX.W0;87;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange r16 with word from r/m16.;;
XCHG;r32;m32/r32;;;ModRM:reg (r, w);ModRM:r/m (r, w);;;;REX.W0;87;/r;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange r32 with doubleword from r/m32.;;
XCHG;r64=RAX;r64;;;;ModRM:reg (r, w);;;;REX.W;90+rd;;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange RAX with r64.;;
XCHG;r64;r64=RAX;;;ModRM:reg (r, w);;;;;REX.W;90+rd;;;;Valid;N.E.;8086;;XCHG;XCHG;NA;Exchange r64 with RAX.;;
XCHG;r32=EAX;r32;;;;ModRM:reg (r, w);;;;REX.W0;90+rd;;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange EAX with r32.;;
XCHG;r32;r32=EAX;;;ModRM:reg (r, w);;;;;REX.W0;90+rd;;;;Valid;Valid;8086;;XCHG;XCHG;NA;Exchange r32 with EAX.;;
XCHG;r16=AX;r16;;;;ModRM:reg (r, w);;;;REX.W0;90+rw;;;;Valid;Valid;8086;Legacy66;XCHG;XCHG;NA;Exchange AX with r16.;;
XCHG;r16;r16=AX;;;ModRM:reg (r, w);;;;;REX.W0;90+rw;;;;Valid;Valid;8086;Legacy66;XCHG;XCHG;NA;Exchange r16 with AX.;;
XGETBV;;;;;;;;;;;0F 01 D0 ;;;;Valid;Valid;8086;;XGETBV;UNDEF;NA;Reads an XCR specified by ECX into EDX:EAX.;;
XLAT;m8=DS:(R)BX/DS:(E)BX;;;;;;;;;REX.W0;D7;;;;Valid;Valid;8086;;XLAT;TLT;NA;Set AL to memory byte DS:[(E)BX + unsigned AL].;;
XLATB;;;;;;;;;;REX.W;D7;;;;Valid;N.E.;8086;;XLATB;TLT;NA;Set AL to memory byte [RBX + unsigned AL].;;
XLATB;;;;;;;;;;;D7;;;;Valid;Valid;8086;;XLATB;TLT;NA;Set AL to memory byte DS:[(E)BX + unsigned AL].;;
XOR;r8;m8/r8;;;ModRM:reg (r);ModRM:r/m (r, w);;;;;30;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r/m8 XOR r8.;;
XOR;r8<>[ABCD]H;m8/r8<>[ABCD]H;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX;30;/r;;;Valid;N.E.;8086;;XOR;XOR;NA;r/m8 XOR r8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XOR;r32;m32/r32;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;31;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r/m32 XOR r32.;;
XOR;r64;m64/r64;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W;31;/r;;;Valid;N.E.;8086;;XOR;XOR;NA;r/m64 XOR r64.;;
XOR;r16;m16/r16;;;ModRM:reg (r);ModRM:r/m (r, w);;;;REX.W0;31;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r/m16 XOR r16.;;
XOR;m8/r8<>[ABCD]H;r8<>[ABCD]H;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX;32;/r;;;Valid;N.E.;8086;;XOR;XOR;NA;r8 XOR r/m8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XOR;m8/r8;r8;;;ModRM:r/m (r);ModRM:reg (r, w);;;;;32;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r8 XOR r/m8.;;
XOR;m64/r64;r64;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W;33;/r;;;Valid;N.E.;8086;;XOR;XOR;NA;r64 XOR r/m64.;;
XOR;m16/r16;r16;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;33;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r16 XOR r/m16.;;
XOR;m32/r32;r32;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;33;/r;;;Valid;Valid;8086;;XOR;XOR;NA;r32 XOR r/m32.;;
XOR;imm8;r8=AL;;;imm8;;;;;;34;;;ib;Valid;Valid;8086;;XOR;XOR;NA;AL XOR imm8.;;
XOR;imm16;r16=AX;;;imm16;;;;;REX.W0;35;;;iw;Valid;Valid;8086;Legacy66;XOR;XOR;NA;AX XOR imm16.;;
XOR;imm32;r32=EAX;;;imm32;;;;;REX.W0;35;;;id;Valid;Valid;8086;;XOR;XOR;NA;EAX XOR imm32.;;
XOR;imm32;r64=RAX;;;imm32;;;;;REX.W;35;;;id;Valid;N.E.;8086;;XOR;XOR;NA;RAX XOR imm32 (sign-extended).;;
XOR;imm8;m8/r8<>[ABCD]H;;;imm8;ModRM:r/m (r, w);;;;REX;80;/6;;ib;Valid;N.E.;8086;;XOR;XOR;NA;r/m8 XOR imm8.;* In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.;
XOR;imm8;m8/r8;;;imm8;ModRM:r/m (r, w);;;;;80;/6;;ib;Valid;Valid;8086;;XOR;XOR;NA;r/m8 XOR imm8.;;
XOR;imm16;m16/r16;;;imm16;ModRM:r/m (r, w);;;;REX.W0;81;/6;;iw;Valid;Valid;8086;;XOR;XOR;NA;r/m16 XOR imm16.;;
XOR;imm32;m32/r32;;;imm32;ModRM:r/m (r, w);;;;REX.W0;81;/6;;id;Valid;Valid;8086;;XOR;XOR;NA;r/m32 XOR imm32.;;
XOR;imm32;m64/r64;;;imm32;ModRM:r/m (r, w);;;;REX.W;81;/6;;id;Valid;N.E.;8086;;XOR;XOR;NA;r/m64 XOR imm32 (sign-extended).;;
XOR;imm8;m16/r16;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/6;;ib;Valid;Valid;8086;;XOR;XOR;NA;r/m16 XOR imm8 (sign-extended).;;
XOR;imm8;m32/r32;;;imm8;ModRM:r/m (r, w);;;;REX.W0;83;/6;;ib;Valid;Valid;8086;;XOR;XOR;NA;r/m32 XOR imm8 (sign-extended).;;
XOR;imm8;m64/r64;;;imm8;ModRM:r/m (r, w);;;;REX.W;83;/6;;ib;Valid;N.E.;8086;;XOR;XOR;NA;r/m64 XOR imm8 (sign-extended).;;
XORPD;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;66;REX.W0;0F 57;/r;;;Valid;Valid;SSE2;;XORPD;XOR;NA;Bitwise exclusive-OR of xmm2/m128 and xmm1.;;
XORPS;xmm/m128;xmm;;;ModRM:r/m (r);ModRM:reg (r, w);;;;REX.W0;0F 57;/r;;;Valid;Valid;SSE;;XORPS;XOR;NA;Bitwise exclusive-OR of xmm2/m128 and xmm1.;;
XRSTOR;m;;;;ModRM:r/m (r);;;;;;0F AE;/5;;;Valid;Valid;8086;;XRSTOR;UNDEF;NA;Restore processor extended states from memory. The states are specified by EDX:EAX;;
XRSTOR64;m;;;;ModRM:r/m (r);;;;;REX.W;0F AE;/5;;;Valid;N.E;8086;;XRSTOR64;UNDEF;NA;Restore processor extended states from memory. The states are specified by EDX:EAX;;
XSAVE;m;;;;ModRM:r/m (w);;;;;;0F AE;/4;;;Valid;Valid;8086;;XSAVE;UNDEF;NA;Save processor extended states to memory. The states are specified by EDX:EAX;;
XSAVE64;m;;;;ModRM:r/m (w);;;;;REX.W;0F AE;/4;;;Valid;N.E;8086;;XSAVE64;UNDEF;NA;Save processor extended states to memory. The states are specified by EDX:EAX;;
XSETBV;;;;;;;;;;;0F 01 D1;;;;Valid;Valid;8086;;XSETBV;UNDEF;NA;Write the value in EDX:EAX to the XCR specified by ECX.;;
XSAVEOPT;m;;;;ModRM:r/m (w);;;;;;0F AE;/6;;;Valid;Valid;XSAVEOPT;;XSAVEOPT;UNDEF;NA;Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.;;
XSAVEOPT;m;;;;ModRM:r/m (w);;;;;REX.W;0F AE;/6;;;Valid;Valid;XSAVEOPT;;XSAVEOPT;UNDEF;NA;Save processor extended states specified in EDX:EAX to memory, optimizing the state save operation if possible.;;
